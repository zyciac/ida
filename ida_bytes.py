# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
IDA Plugin SDK API wrapper: bytes
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ida_bytes', [dirname(__file__)])
        except ImportError:
            import _ida_bytes
            return _ida_bytes
        if fp is not None:
            try:
                _mod = imp.load_module('_ida_bytes', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ida_bytes = swig_import_helper()
    del swig_import_helper
else:
    import _ida_bytes
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import ida_idaapi

import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        func.func_dict["bc695redef"] = True
        return func

import ida_range

def enable_flags(*args):
  """
  enable_flags(start_ea, end_ea, stt) -> error_t
  """
  return _ida_bytes.enable_flags(*args)

def disable_flags(*args):
  """
  disable_flags(start_ea, end_ea) -> error_t
  """
  return _ida_bytes.disable_flags(*args)

def change_storage_type(*args):
  """
  change_storage_type(start_ea, end_ea, stt) -> error_t
  """
  return _ida_bytes.change_storage_type(*args)

def next_addr(*args):
  """
  next_addr(ea) -> ea_t
  """
  return _ida_bytes.next_addr(*args)

def prev_addr(*args):
  """
  prev_addr(ea) -> ea_t
  """
  return _ida_bytes.prev_addr(*args)

def next_chunk(*args):
  """
  next_chunk(ea) -> ea_t
  """
  return _ida_bytes.next_chunk(*args)

def prev_chunk(*args):
  """
  prev_chunk(ea) -> ea_t
  """
  return _ida_bytes.prev_chunk(*args)

def chunk_start(*args):
  """
  chunk_start(ea) -> ea_t
  """
  return _ida_bytes.chunk_start(*args)

def chunk_size(*args):
  """
  chunk_size(ea) -> asize_t
  """
  return _ida_bytes.chunk_size(*args)

def free_chunk(*args):
  """
  free_chunk(bottom, size, step) -> ea_t
  """
  return _ida_bytes.free_chunk(*args)

def next_unknown(*args):
  """
  next_unknown(ea, maxea) -> ea_t
  """
  return _ida_bytes.next_unknown(*args)

def prev_unknown(*args):
  """
  prev_unknown(ea, minea) -> ea_t
  """
  return _ida_bytes.prev_unknown(*args)

def prev_head(*args):
  """
  prev_head(ea, minea) -> ea_t
  """
  return _ida_bytes.prev_head(*args)

def next_head(*args):
  """
  next_head(ea, maxea) -> ea_t
  """
  return _ida_bytes.next_head(*args)

def prev_not_tail(*args):
  """
  prev_not_tail(ea) -> ea_t
  """
  return _ida_bytes.prev_not_tail(*args)

def next_not_tail(*args):
  """
  next_not_tail(ea) -> ea_t
  """
  return _ida_bytes.next_not_tail(*args)

def get_item_head(*args):
  """
  get_item_head(ea) -> ea_t
  """
  return _ida_bytes.get_item_head(*args)

def get_item_end(*args):
  """
  get_item_end(ea) -> ea_t
  """
  return _ida_bytes.get_item_end(*args)

def calc_max_item_end(*args):
  """
  calc_max_item_end(ea, how=15) -> ea_t
  """
  return _ida_bytes.calc_max_item_end(*args)
ITEM_END_FIXUP = _ida_bytes.ITEM_END_FIXUP
ITEM_END_INITED = _ida_bytes.ITEM_END_INITED
ITEM_END_NAME = _ida_bytes.ITEM_END_NAME
ITEM_END_XREF = _ida_bytes.ITEM_END_XREF

def get_item_size(*args):
  """
  get_item_size(ea) -> asize_t
  """
  return _ida_bytes.get_item_size(*args)

def is_mapped(*args):
  """
  is_mapped(ea) -> bool
  """
  return _ida_bytes.is_mapped(*args)

def get_flags_ex(*args):
  """
  get_flags_ex(ea, how) -> flags_t
  """
  return _ida_bytes.get_flags_ex(*args)
GFE_VALUE = _ida_bytes.GFE_VALUE

def get_flags(*args):
  """
  get_flags(ea) -> flags_t
  """
  return _ida_bytes.get_flags(*args)

def get_full_flags(*args):
  """
  get_full_flags(ea) -> flags_t
  """
  return _ida_bytes.get_full_flags(*args)

def get_item_flag(*args):
  """
  get_item_flag(_from, n, ea, appzero) -> flags_t
  """
  return _ida_bytes.get_item_flag(*args)
MS_VAL = _ida_bytes.MS_VAL
FF_IVL = _ida_bytes.FF_IVL

def has_value(*args):
  """
  has_value(F) -> bool
  """
  return _ida_bytes.has_value(*args)

def del_value(*args):
  """
  del_value(ea)
  """
  return _ida_bytes.del_value(*args)

def is_loaded(*args):
  """
  is_loaded(ea) -> bool
  """
  return _ida_bytes.is_loaded(*args)

def nbits(*args):
  """
  nbits(ea) -> int
  """
  return _ida_bytes.nbits(*args)

def bytesize(*args):
  """
  bytesize(ea) -> int
  """
  return _ida_bytes.bytesize(*args)

def get_byte(*args):
  """
  get_byte(ea) -> uchar
  """
  return _ida_bytes.get_byte(*args)

def get_db_byte(*args):
  """
  get_db_byte(ea) -> uchar
  """
  return _ida_bytes.get_db_byte(*args)

def get_word(*args):
  """
  get_word(ea) -> ushort
  """
  return _ida_bytes.get_word(*args)

def get_dword(*args):
  """
  get_dword(ea) -> uint32
  """
  return _ida_bytes.get_dword(*args)

def get_qword(*args):
  """
  get_qword(ea) -> uint64
  """
  return _ida_bytes.get_qword(*args)

def get_wide_byte(*args):
  """
  get_wide_byte(ea) -> uint32
  """
  return _ida_bytes.get_wide_byte(*args)

def get_wide_word(*args):
  """
  get_wide_word(ea) -> uint64
  """
  return _ida_bytes.get_wide_word(*args)

def get_wide_dword(*args):
  """
  get_wide_dword(ea) -> uint64
  """
  return _ida_bytes.get_wide_dword(*args)

def get_16bit(*args):
  """
  get_16bit(ea) -> uint32
  """
  return _ida_bytes.get_16bit(*args)

def get_32bit(*args):
  """
  get_32bit(ea) -> uint32
  """
  return _ida_bytes.get_32bit(*args)

def get_64bit(*args):
  """
  get_64bit(ea) -> uint64
  """
  return _ida_bytes.get_64bit(*args)

def get_data_value(*args):
  """
  get_data_value(v, ea, size) -> bool
  """
  return _ida_bytes.get_data_value(*args)

def get_original_byte(*args):
  """
  get_original_byte(ea) -> uint32
  """
  return _ida_bytes.get_original_byte(*args)

def get_original_word(*args):
  """
  get_original_word(ea) -> uint64
  """
  return _ida_bytes.get_original_word(*args)

def get_original_dword(*args):
  """
  get_original_dword(ea) -> uint64
  """
  return _ida_bytes.get_original_dword(*args)

def get_original_qword(*args):
  """
  get_original_qword(ea) -> uint64
  """
  return _ida_bytes.get_original_qword(*args)

def put_byte(*args):
  """
  put_byte(ea, x) -> bool
  """
  return _ida_bytes.put_byte(*args)

def put_word(*args):
  """
  put_word(ea, x)
  """
  return _ida_bytes.put_word(*args)

def put_dword(*args):
  """
  put_dword(ea, x)
  """
  return _ida_bytes.put_dword(*args)

def put_qword(*args):
  """
  put_qword(ea, x)
  """
  return _ida_bytes.put_qword(*args)

def patch_byte(*args):
  """
  patch_byte(ea, x) -> bool
  """
  return _ida_bytes.patch_byte(*args)

def patch_word(*args):
  """
  patch_word(ea, x) -> bool
  """
  return _ida_bytes.patch_word(*args)

def patch_dword(*args):
  """
  patch_dword(ea, x) -> bool
  """
  return _ida_bytes.patch_dword(*args)

def patch_qword(*args):
  """
  patch_qword(ea, x) -> bool
  """
  return _ida_bytes.patch_qword(*args)

def revert_byte(*args):
  """
  revert_byte(ea) -> bool
  """
  return _ida_bytes.revert_byte(*args)

def add_byte(*args):
  """
  add_byte(ea, value)
  """
  return _ida_bytes.add_byte(*args)

def add_word(*args):
  """
  add_word(ea, value)
  """
  return _ida_bytes.add_word(*args)

def add_dword(*args):
  """
  add_dword(ea, value)
  """
  return _ida_bytes.add_dword(*args)

def add_qword(*args):
  """
  add_qword(ea, value)
  """
  return _ida_bytes.add_qword(*args)

def get_zero_ranges(*args):
  """
  get_zero_ranges(zranges, range) -> bool
  """
  return _ida_bytes.get_zero_ranges(*args)
GMB_READALL = _ida_bytes.GMB_READALL
GMB_WAITBOX = _ida_bytes.GMB_WAITBOX

def put_bytes(*args):
  """
  put_bytes(ea, buf)
  """
  return _ida_bytes.put_bytes(*args)

def patch_bytes(*args):
  """
  patch_bytes(ea, buf)
  """
  return _ida_bytes.patch_bytes(*args)
MS_CLS = _ida_bytes.MS_CLS
FF_CODE = _ida_bytes.FF_CODE
FF_DATA = _ida_bytes.FF_DATA
FF_TAIL = _ida_bytes.FF_TAIL
FF_UNK = _ida_bytes.FF_UNK

def is_code(*args):
  """
  is_code(F) -> bool
  """
  return _ida_bytes.is_code(*args)

def f_is_code(*args):
  """
  f_is_code(F, arg2) -> bool
  """
  return _ida_bytes.f_is_code(*args)

def is_data(*args):
  """
  is_data(F) -> bool
  """
  return _ida_bytes.is_data(*args)

def f_is_data(*args):
  """
  f_is_data(F, arg2) -> bool
  """
  return _ida_bytes.f_is_data(*args)

def is_tail(*args):
  """
  is_tail(F) -> bool
  """
  return _ida_bytes.is_tail(*args)

def f_is_tail(*args):
  """
  f_is_tail(F, arg2) -> bool
  """
  return _ida_bytes.f_is_tail(*args)

def is_not_tail(*args):
  """
  is_not_tail(F) -> bool
  """
  return _ida_bytes.is_not_tail(*args)

def f_is_not_tail(*args):
  """
  f_is_not_tail(F, arg2) -> bool
  """
  return _ida_bytes.f_is_not_tail(*args)

def is_unknown(*args):
  """
  is_unknown(F) -> bool
  """
  return _ida_bytes.is_unknown(*args)

def is_head(*args):
  """
  is_head(F) -> bool
  """
  return _ida_bytes.is_head(*args)

def f_is_head(*args):
  """
  f_is_head(F, arg2) -> bool
  """
  return _ida_bytes.f_is_head(*args)

def del_items(*args):
  """
  del_items(ea, flags=0, nbytes=1, may_destroy=None) -> bool
  """
  return _ida_bytes.del_items(*args)
DELIT_SIMPLE = _ida_bytes.DELIT_SIMPLE
DELIT_EXPAND = _ida_bytes.DELIT_EXPAND
DELIT_DELNAMES = _ida_bytes.DELIT_DELNAMES
DELIT_NOTRUNC = _ida_bytes.DELIT_NOTRUNC
DELIT_NOUNAME = _ida_bytes.DELIT_NOUNAME
DELIT_NOCMT = _ida_bytes.DELIT_NOCMT

def is_manual_insn(*args):
  """
  is_manual_insn(ea) -> bool
  """
  return _ida_bytes.is_manual_insn(*args)

def get_manual_insn(*args):
  """
  get_manual_insn(ea) -> ssize_t
  """
  return _ida_bytes.get_manual_insn(*args)

def set_manual_insn(*args):
  """
  set_manual_insn(ea, manual_insn)
  """
  return _ida_bytes.set_manual_insn(*args)
MS_COMM = _ida_bytes.MS_COMM
FF_COMM = _ida_bytes.FF_COMM
FF_REF = _ida_bytes.FF_REF
FF_LINE = _ida_bytes.FF_LINE
FF_NAME = _ida_bytes.FF_NAME
FF_LABL = _ida_bytes.FF_LABL
FF_FLOW = _ida_bytes.FF_FLOW
FF_SIGN = _ida_bytes.FF_SIGN
FF_BNOT = _ida_bytes.FF_BNOT
FF_UNUSED = _ida_bytes.FF_UNUSED

def is_flow(*args):
  """
  is_flow(F) -> bool
  """
  return _ida_bytes.is_flow(*args)

def has_extra_cmts(*args):
  """
  has_extra_cmts(F) -> bool
  """
  return _ida_bytes.has_extra_cmts(*args)

def has_cmt(*args):
  """
  has_cmt(F) -> bool
  """
  return _ida_bytes.has_cmt(*args)

def has_xref(*args):
  """
  has_xref(F) -> bool
  """
  return _ida_bytes.has_xref(*args)

def f_has_xref(*args):
  """
  f_has_xref(f, arg2) -> bool
  """
  return _ida_bytes.f_has_xref(*args)

def has_name(*args):
  """
  has_name(F) -> bool
  """
  return _ida_bytes.has_name(*args)

def f_has_name(*args):
  """
  f_has_name(f, arg2) -> bool
  """
  return _ida_bytes.f_has_name(*args)
FF_ANYNAME = _ida_bytes.FF_ANYNAME

def has_dummy_name(*args):
  """
  has_dummy_name(F) -> bool
  """
  return _ida_bytes.has_dummy_name(*args)

def f_has_dummy_name(*args):
  """
  f_has_dummy_name(f, arg2) -> bool
  """
  return _ida_bytes.f_has_dummy_name(*args)

def has_auto_name(*args):
  """
  has_auto_name(F) -> bool
  """
  return _ida_bytes.has_auto_name(*args)

def has_any_name(*args):
  """
  has_any_name(F) -> bool
  """
  return _ida_bytes.has_any_name(*args)

def has_user_name(*args):
  """
  has_user_name(F) -> bool
  """
  return _ida_bytes.has_user_name(*args)

def f_has_user_name(*args):
  """
  f_has_user_name(F, arg2) -> bool
  """
  return _ida_bytes.f_has_user_name(*args)

def is_invsign(*args):
  """
  is_invsign(ea, F, n) -> bool
  """
  return _ida_bytes.is_invsign(*args)

def toggle_sign(*args):
  """
  toggle_sign(ea, n) -> bool
  """
  return _ida_bytes.toggle_sign(*args)

def is_bnot(*args):
  """
  is_bnot(ea, F, n) -> bool
  """
  return _ida_bytes.is_bnot(*args)

def toggle_bnot(*args):
  """
  toggle_bnot(ea, n) -> bool
  """
  return _ida_bytes.toggle_bnot(*args)

def is_lzero(*args):
  """
  is_lzero(ea, n) -> bool
  """
  return _ida_bytes.is_lzero(*args)

def set_lzero(*args):
  """
  set_lzero(ea, n) -> bool
  """
  return _ida_bytes.set_lzero(*args)

def clr_lzero(*args):
  """
  clr_lzero(ea, n) -> bool
  """
  return _ida_bytes.clr_lzero(*args)

def toggle_lzero(*args):
  """
  toggle_lzero(ea, n) -> bool
  """
  return _ida_bytes.toggle_lzero(*args)

def leading_zero_important(*args):
  """
  leading_zero_important(ea, n) -> bool
  """
  return _ida_bytes.leading_zero_important(*args)
MS_0TYPE = _ida_bytes.MS_0TYPE
FF_0VOID = _ida_bytes.FF_0VOID
FF_0NUMH = _ida_bytes.FF_0NUMH
FF_0NUMD = _ida_bytes.FF_0NUMD
FF_0CHAR = _ida_bytes.FF_0CHAR
FF_0SEG = _ida_bytes.FF_0SEG
FF_0OFF = _ida_bytes.FF_0OFF
FF_0NUMB = _ida_bytes.FF_0NUMB
FF_0NUMO = _ida_bytes.FF_0NUMO
FF_0ENUM = _ida_bytes.FF_0ENUM
FF_0FOP = _ida_bytes.FF_0FOP
FF_0STRO = _ida_bytes.FF_0STRO
FF_0STK = _ida_bytes.FF_0STK
FF_0FLT = _ida_bytes.FF_0FLT
FF_0CUST = _ida_bytes.FF_0CUST
MS_1TYPE = _ida_bytes.MS_1TYPE
FF_1VOID = _ida_bytes.FF_1VOID
FF_1NUMH = _ida_bytes.FF_1NUMH
FF_1NUMD = _ida_bytes.FF_1NUMD
FF_1CHAR = _ida_bytes.FF_1CHAR
FF_1SEG = _ida_bytes.FF_1SEG
FF_1OFF = _ida_bytes.FF_1OFF
FF_1NUMB = _ida_bytes.FF_1NUMB
FF_1NUMO = _ida_bytes.FF_1NUMO
FF_1ENUM = _ida_bytes.FF_1ENUM
FF_1FOP = _ida_bytes.FF_1FOP
FF_1STRO = _ida_bytes.FF_1STRO
FF_1STK = _ida_bytes.FF_1STK
FF_1FLT = _ida_bytes.FF_1FLT
FF_1CUST = _ida_bytes.FF_1CUST

def is_defarg0(*args):
  """
  is_defarg0(F) -> bool
  """
  return _ida_bytes.is_defarg0(*args)

def is_defarg1(*args):
  """
  is_defarg1(F) -> bool
  """
  return _ida_bytes.is_defarg1(*args)

def is_off0(*args):
  """
  is_off0(F) -> bool
  """
  return _ida_bytes.is_off0(*args)

def is_off1(*args):
  """
  is_off1(F) -> bool
  """
  return _ida_bytes.is_off1(*args)

def is_char0(*args):
  """
  is_char0(F) -> bool
  """
  return _ida_bytes.is_char0(*args)

def is_char1(*args):
  """
  is_char1(F) -> bool
  """
  return _ida_bytes.is_char1(*args)

def is_seg0(*args):
  """
  is_seg0(F) -> bool
  """
  return _ida_bytes.is_seg0(*args)

def is_seg1(*args):
  """
  is_seg1(F) -> bool
  """
  return _ida_bytes.is_seg1(*args)

def is_enum0(*args):
  """
  is_enum0(F) -> bool
  """
  return _ida_bytes.is_enum0(*args)

def is_enum1(*args):
  """
  is_enum1(F) -> bool
  """
  return _ida_bytes.is_enum1(*args)

def is_stroff0(*args):
  """
  is_stroff0(F) -> bool
  """
  return _ida_bytes.is_stroff0(*args)

def is_stroff1(*args):
  """
  is_stroff1(F) -> bool
  """
  return _ida_bytes.is_stroff1(*args)

def is_stkvar0(*args):
  """
  is_stkvar0(F) -> bool
  """
  return _ida_bytes.is_stkvar0(*args)

def is_stkvar1(*args):
  """
  is_stkvar1(F) -> bool
  """
  return _ida_bytes.is_stkvar1(*args)

def is_float0(*args):
  """
  is_float0(F) -> bool
  """
  return _ida_bytes.is_float0(*args)

def is_float1(*args):
  """
  is_float1(F) -> bool
  """
  return _ida_bytes.is_float1(*args)

def is_custfmt0(*args):
  """
  is_custfmt0(F) -> bool
  """
  return _ida_bytes.is_custfmt0(*args)

def is_custfmt1(*args):
  """
  is_custfmt1(F) -> bool
  """
  return _ida_bytes.is_custfmt1(*args)

def is_numop0(*args):
  """
  is_numop0(F) -> bool
  """
  return _ida_bytes.is_numop0(*args)

def is_numop1(*args):
  """
  is_numop1(F) -> bool
  """
  return _ida_bytes.is_numop1(*args)

def get_optype_flags0(*args):
  """
  get_optype_flags0(F) -> flags_t
  """
  return _ida_bytes.get_optype_flags0(*args)

def get_optype_flags1(*args):
  """
  get_optype_flags1(F) -> flags_t
  """
  return _ida_bytes.get_optype_flags1(*args)
OPND_OUTER = _ida_bytes.OPND_OUTER
OPND_MASK = _ida_bytes.OPND_MASK
OPND_ALL = _ida_bytes.OPND_ALL

def is_defarg(*args):
  """
  is_defarg(F, n) -> bool
  """
  return _ida_bytes.is_defarg(*args)

def is_off(*args):
  """
  is_off(F, n) -> bool
  """
  return _ida_bytes.is_off(*args)

def is_char(*args):
  """
  is_char(F, n) -> bool
  """
  return _ida_bytes.is_char(*args)

def is_seg(*args):
  """
  is_seg(F, n) -> bool
  """
  return _ida_bytes.is_seg(*args)

def is_enum(*args):
  """
  is_enum(F, n) -> bool
  """
  return _ida_bytes.is_enum(*args)

def is_manual(*args):
  """
  is_manual(F, n) -> bool
  """
  return _ida_bytes.is_manual(*args)

def is_stroff(*args):
  """
  is_stroff(F, n) -> bool
  """
  return _ida_bytes.is_stroff(*args)

def is_stkvar(*args):
  """
  is_stkvar(F, n) -> bool
  """
  return _ida_bytes.is_stkvar(*args)

def is_fltnum(*args):
  """
  is_fltnum(F, n) -> bool
  """
  return _ida_bytes.is_fltnum(*args)

def is_custfmt(*args):
  """
  is_custfmt(F, n) -> bool
  """
  return _ida_bytes.is_custfmt(*args)

def is_numop(*args):
  """
  is_numop(F, n) -> bool
  """
  return _ida_bytes.is_numop(*args)

def is_suspop(*args):
  """
  is_suspop(ea, F, n) -> bool
  """
  return _ida_bytes.is_suspop(*args)

def op_adds_xrefs(*args):
  """
  op_adds_xrefs(F, n) -> bool
  """
  return _ida_bytes.op_adds_xrefs(*args)

def set_op_type(*args):
  """
  set_op_type(ea, type, n) -> bool
  """
  return _ida_bytes.set_op_type(*args)

def op_seg(*args):
  """
  op_seg(ea, n) -> bool
  """
  return _ida_bytes.op_seg(*args)

def op_enum(*args):
  """
  op_enum(ea, n, id, serial) -> bool
  """
  return _ida_bytes.op_enum(*args)

def get_enum_id(*args):
  """
  get_enum_id(ea, n) -> enum_t
  """
  return _ida_bytes.get_enum_id(*args)

def op_stroff(*args):
  """
  op_stroff(insn, n, path, path_len, delta) -> bool
  """
  return _ida_bytes.op_stroff(*args)

def get_stroff_path(*args):
  """
  get_stroff_path(path, delta, ea, n) -> int
  """
  return _ida_bytes.get_stroff_path(*args)

def op_stkvar(*args):
  """
  op_stkvar(ea, n) -> bool
  """
  return _ida_bytes.op_stkvar(*args)

def set_forced_operand(*args):
  """
  set_forced_operand(ea, n, op) -> bool
  """
  return _ida_bytes.set_forced_operand(*args)

def get_forced_operand(*args):
  """
  get_forced_operand(ea, n) -> ssize_t
  """
  return _ida_bytes.get_forced_operand(*args)

def is_forced_operand(*args):
  """
  is_forced_operand(ea, n) -> bool
  """
  return _ida_bytes.is_forced_operand(*args)

def char_flag(*args):
  """
  char_flag() -> flags_t
  """
  return _ida_bytes.char_flag(*args)

def off_flag(*args):
  """
  off_flag() -> flags_t
  """
  return _ida_bytes.off_flag(*args)

def enum_flag(*args):
  """
  enum_flag() -> flags_t
  """
  return _ida_bytes.enum_flag(*args)

def stroff_flag(*args):
  """
  stroff_flag() -> flags_t
  """
  return _ida_bytes.stroff_flag(*args)

def stkvar_flag(*args):
  """
  stkvar_flag() -> flags_t
  """
  return _ida_bytes.stkvar_flag(*args)

def flt_flag(*args):
  """
  flt_flag() -> flags_t
  """
  return _ida_bytes.flt_flag(*args)

def custfmt_flag(*args):
  """
  custfmt_flag() -> flags_t
  """
  return _ida_bytes.custfmt_flag(*args)

def seg_flag(*args):
  """
  seg_flag() -> flags_t
  """
  return _ida_bytes.seg_flag(*args)

def num_flag(*args):
  """
  num_flag() -> flags_t
  """
  return _ida_bytes.num_flag(*args)

def hex_flag(*args):
  """
  hex_flag() -> flags_t
  """
  return _ida_bytes.hex_flag(*args)

def dec_flag(*args):
  """
  dec_flag() -> flags_t
  """
  return _ida_bytes.dec_flag(*args)

def oct_flag(*args):
  """
  oct_flag() -> flags_t
  """
  return _ida_bytes.oct_flag(*args)

def bin_flag(*args):
  """
  bin_flag() -> flags_t
  """
  return _ida_bytes.bin_flag(*args)

def op_chr(*args):
  """
  op_chr(ea, n) -> bool
  """
  return _ida_bytes.op_chr(*args)

def op_num(*args):
  """
  op_num(ea, n) -> bool
  """
  return _ida_bytes.op_num(*args)

def op_hex(*args):
  """
  op_hex(ea, n) -> bool
  """
  return _ida_bytes.op_hex(*args)

def op_dec(*args):
  """
  op_dec(ea, n) -> bool
  """
  return _ida_bytes.op_dec(*args)

def op_oct(*args):
  """
  op_oct(ea, n) -> bool
  """
  return _ida_bytes.op_oct(*args)

def op_bin(*args):
  """
  op_bin(ea, n) -> bool
  """
  return _ida_bytes.op_bin(*args)

def op_flt(*args):
  """
  op_flt(ea, n) -> bool
  """
  return _ida_bytes.op_flt(*args)

def op_custfmt(*args):
  """
  op_custfmt(ea, n, fid) -> bool
  """
  return _ida_bytes.op_custfmt(*args)

def clr_op_type(*args):
  """
  clr_op_type(ea, n) -> bool
  """
  return _ida_bytes.clr_op_type(*args)

def get_default_radix(*args):
  """
  get_default_radix() -> int
  """
  return _ida_bytes.get_default_radix(*args)

def get_radix(*args):
  """
  get_radix(F, n) -> int
  """
  return _ida_bytes.get_radix(*args)
DT_TYPE = _ida_bytes.DT_TYPE
FF_BYTE = _ida_bytes.FF_BYTE
FF_WORD = _ida_bytes.FF_WORD
FF_DWORD = _ida_bytes.FF_DWORD
FF_QWORD = _ida_bytes.FF_QWORD
FF_TBYTE = _ida_bytes.FF_TBYTE
FF_STRLIT = _ida_bytes.FF_STRLIT
FF_STRUCT = _ida_bytes.FF_STRUCT
FF_OWORD = _ida_bytes.FF_OWORD
FF_FLOAT = _ida_bytes.FF_FLOAT
FF_DOUBLE = _ida_bytes.FF_DOUBLE
FF_PACKREAL = _ida_bytes.FF_PACKREAL
FF_ALIGN = _ida_bytes.FF_ALIGN
FF_CUSTOM = _ida_bytes.FF_CUSTOM
FF_YWORD = _ida_bytes.FF_YWORD
FF_ZWORD = _ida_bytes.FF_ZWORD

def code_flag(*args):
  """
  code_flag() -> flags_t
  """
  return _ida_bytes.code_flag(*args)

def byte_flag(*args):
  """
  byte_flag() -> flags_t
  """
  return _ida_bytes.byte_flag(*args)

def word_flag(*args):
  """
  word_flag() -> flags_t
  """
  return _ida_bytes.word_flag(*args)

def dword_flag(*args):
  """
  dword_flag() -> flags_t
  """
  return _ida_bytes.dword_flag(*args)

def qword_flag(*args):
  """
  qword_flag() -> flags_t
  """
  return _ida_bytes.qword_flag(*args)

def oword_flag(*args):
  """
  oword_flag() -> flags_t
  """
  return _ida_bytes.oword_flag(*args)

def yword_flag(*args):
  """
  yword_flag() -> flags_t
  """
  return _ida_bytes.yword_flag(*args)

def zword_flag(*args):
  """
  zword_flag() -> flags_t
  """
  return _ida_bytes.zword_flag(*args)

def tbyte_flag(*args):
  """
  tbyte_flag() -> flags_t
  """
  return _ida_bytes.tbyte_flag(*args)

def strlit_flag(*args):
  """
  strlit_flag() -> flags_t
  """
  return _ida_bytes.strlit_flag(*args)

def stru_flag(*args):
  """
  stru_flag() -> flags_t
  """
  return _ida_bytes.stru_flag(*args)

def cust_flag(*args):
  """
  cust_flag() -> flags_t
  """
  return _ida_bytes.cust_flag(*args)

def align_flag(*args):
  """
  align_flag() -> flags_t
  """
  return _ida_bytes.align_flag(*args)

def float_flag(*args):
  """
  float_flag() -> flags_t
  """
  return _ida_bytes.float_flag(*args)

def double_flag(*args):
  """
  double_flag() -> flags_t
  """
  return _ida_bytes.double_flag(*args)

def packreal_flag(*args):
  """
  packreal_flag() -> flags_t
  """
  return _ida_bytes.packreal_flag(*args)

def is_byte(*args):
  """
  is_byte(F) -> bool
  """
  return _ida_bytes.is_byte(*args)

def is_word(*args):
  """
  is_word(F) -> bool
  """
  return _ida_bytes.is_word(*args)

def is_dword(*args):
  """
  is_dword(F) -> bool
  """
  return _ida_bytes.is_dword(*args)

def is_qword(*args):
  """
  is_qword(F) -> bool
  """
  return _ida_bytes.is_qword(*args)

def is_oword(*args):
  """
  is_oword(F) -> bool
  """
  return _ida_bytes.is_oword(*args)

def is_yword(*args):
  """
  is_yword(F) -> bool
  """
  return _ida_bytes.is_yword(*args)

def is_zword(*args):
  """
  is_zword(F) -> bool
  """
  return _ida_bytes.is_zword(*args)

def is_tbyte(*args):
  """
  is_tbyte(F) -> bool
  """
  return _ida_bytes.is_tbyte(*args)

def is_float(*args):
  """
  is_float(F) -> bool
  """
  return _ida_bytes.is_float(*args)

def is_double(*args):
  """
  is_double(F) -> bool
  """
  return _ida_bytes.is_double(*args)

def is_pack_real(*args):
  """
  is_pack_real(F) -> bool
  """
  return _ida_bytes.is_pack_real(*args)

def is_strlit(*args):
  """
  is_strlit(F) -> bool
  """
  return _ida_bytes.is_strlit(*args)

def is_struct(*args):
  """
  is_struct(F) -> bool
  """
  return _ida_bytes.is_struct(*args)

def is_align(*args):
  """
  is_align(F) -> bool
  """
  return _ida_bytes.is_align(*args)

def is_custom(*args):
  """
  is_custom(F) -> bool
  """
  return _ida_bytes.is_custom(*args)

def f_is_byte(*args):
  """
  f_is_byte(F, arg2) -> bool
  """
  return _ida_bytes.f_is_byte(*args)

def f_is_word(*args):
  """
  f_is_word(F, arg2) -> bool
  """
  return _ida_bytes.f_is_word(*args)

def f_is_dword(*args):
  """
  f_is_dword(F, arg2) -> bool
  """
  return _ida_bytes.f_is_dword(*args)

def f_is_qword(*args):
  """
  f_is_qword(F, arg2) -> bool
  """
  return _ida_bytes.f_is_qword(*args)

def f_is_oword(*args):
  """
  f_is_oword(F, arg2) -> bool
  """
  return _ida_bytes.f_is_oword(*args)

def f_is_yword(*args):
  """
  f_is_yword(F, arg2) -> bool
  """
  return _ida_bytes.f_is_yword(*args)

def f_is_tbyte(*args):
  """
  f_is_tbyte(F, arg2) -> bool
  """
  return _ida_bytes.f_is_tbyte(*args)

def f_is_float(*args):
  """
  f_is_float(F, arg2) -> bool
  """
  return _ida_bytes.f_is_float(*args)

def f_is_double(*args):
  """
  f_is_double(F, arg2) -> bool
  """
  return _ida_bytes.f_is_double(*args)

def f_is_pack_real(*args):
  """
  f_is_pack_real(F, arg2) -> bool
  """
  return _ida_bytes.f_is_pack_real(*args)

def f_is_strlit(*args):
  """
  f_is_strlit(F, arg2) -> bool
  """
  return _ida_bytes.f_is_strlit(*args)

def f_is_struct(*args):
  """
  f_is_struct(F, arg2) -> bool
  """
  return _ida_bytes.f_is_struct(*args)

def f_is_align(*args):
  """
  f_is_align(F, arg2) -> bool
  """
  return _ida_bytes.f_is_align(*args)

def f_is_custom(*args):
  """
  f_is_custom(F, arg2) -> bool
  """
  return _ida_bytes.f_is_custom(*args)

def is_same_data_type(*args):
  """
  is_same_data_type(F1, F2) -> bool
  """
  return _ida_bytes.is_same_data_type(*args)

def get_flags_by_size(*args):
  """
  get_flags_by_size(size) -> flags_t
  """
  return _ida_bytes.get_flags_by_size(*args)

def create_data(*args):
  """
  create_data(ea, dataflag, size, tid) -> bool
  """
  return _ida_bytes.create_data(*args)

def create_byte(*args):
  """
  create_byte(ea, length) -> bool
  """
  return _ida_bytes.create_byte(*args)

def create_word(*args):
  """
  create_word(ea, length) -> bool
  """
  return _ida_bytes.create_word(*args)

def create_dword(*args):
  """
  create_dword(ea, length) -> bool
  """
  return _ida_bytes.create_dword(*args)

def create_qword(*args):
  """
  create_qword(ea, length) -> bool
  """
  return _ida_bytes.create_qword(*args)

def create_oword(*args):
  """
  create_oword(ea, length) -> bool
  """
  return _ida_bytes.create_oword(*args)

def create_yword(*args):
  """
  create_yword(ea, length) -> bool
  """
  return _ida_bytes.create_yword(*args)

def create_zword(*args):
  """
  create_zword(ea, length) -> bool
  """
  return _ida_bytes.create_zword(*args)

def create_tbyte(*args):
  """
  create_tbyte(ea, length) -> bool
  """
  return _ida_bytes.create_tbyte(*args)

def create_float(*args):
  """
  create_float(ea, length) -> bool
  """
  return _ida_bytes.create_float(*args)

def create_double(*args):
  """
  create_double(ea, length) -> bool
  """
  return _ida_bytes.create_double(*args)

def create_packed_real(*args):
  """
  create_packed_real(ea, length) -> bool
  """
  return _ida_bytes.create_packed_real(*args)

def create_struct(*args):
  """
  create_struct(ea, length, tid) -> bool
  """
  return _ida_bytes.create_struct(*args)

def create_custdata(*args):
  """
  create_custdata(ea, length, dtid, fid) -> bool
  """
  return _ida_bytes.create_custdata(*args)

def create_align(*args):
  """
  create_align(ea, length, alignment) -> bool
  """
  return _ida_bytes.create_align(*args)

def calc_min_align(*args):
  """
  calc_min_align(length) -> int
  """
  return _ida_bytes.calc_min_align(*args)

def calc_max_align(*args):
  """
  calc_max_align(endea) -> int
  """
  return _ida_bytes.calc_max_align(*args)

def calc_def_align(*args):
  """
  calc_def_align(ea, mina, maxa) -> int
  """
  return _ida_bytes.calc_def_align(*args)

def create_16bit_data(*args):
  """
  create_16bit_data(ea, length) -> bool
  """
  return _ida_bytes.create_16bit_data(*args)

def create_32bit_data(*args):
  """
  create_32bit_data(ea, length) -> bool
  """
  return _ida_bytes.create_32bit_data(*args)
ALOPT_IGNHEADS = _ida_bytes.ALOPT_IGNHEADS
ALOPT_IGNPRINT = _ida_bytes.ALOPT_IGNPRINT
ALOPT_IGNCLT = _ida_bytes.ALOPT_IGNCLT
ALOPT_MAX4K = _ida_bytes.ALOPT_MAX4K

def get_max_strlit_length(*args):
  """
  get_max_strlit_length(ea, strtype, options=0) -> size_t
  """
  return _ida_bytes.get_max_strlit_length(*args)
STRCONV_ESCAPE = _ida_bytes.STRCONV_ESCAPE
STRCONV_REPLCHAR = _ida_bytes.STRCONV_REPLCHAR
STRCONV_INCLLEN = _ida_bytes.STRCONV_INCLLEN

def create_strlit(*args):
  """
  create_strlit(start, len, strtype) -> bool
  """
  return _ida_bytes.create_strlit(*args)
PSTF_TNORM = _ida_bytes.PSTF_TNORM
PSTF_TBRIEF = _ida_bytes.PSTF_TBRIEF
PSTF_TINLIN = _ida_bytes.PSTF_TINLIN
PSTF_TMASK = _ida_bytes.PSTF_TMASK
PSTF_HOTKEY = _ida_bytes.PSTF_HOTKEY
PSTF_ENC = _ida_bytes.PSTF_ENC

def get_opinfo(*args):
  """
  get_opinfo(buf, ea, n, flags) -> opinfo_t
  """
  return _ida_bytes.get_opinfo(*args)

def set_opinfo(*args):
  """
  set_opinfo(ea, n, flag, ti, suppress_events=False) -> bool
  """
  return _ida_bytes.set_opinfo(*args)

def get_data_elsize(*args):
  """
  get_data_elsize(ea, F, ti=None) -> asize_t
  """
  return _ida_bytes.get_data_elsize(*args)

def get_full_data_elsize(*args):
  """
  get_full_data_elsize(ea, F, ti=None) -> asize_t
  """
  return _ida_bytes.get_full_data_elsize(*args)

def is_varsize_item(*args):
  """
  is_varsize_item(ea, F, ti=None, itemsize=None) -> int
  """
  return _ida_bytes.is_varsize_item(*args)

def can_define_item(*args):
  """
  can_define_item(ea, length, flags) -> bool
  """
  return _ida_bytes.can_define_item(*args)
MS_CODE = _ida_bytes.MS_CODE
FF_FUNC = _ida_bytes.FF_FUNC
FF_IMMD = _ida_bytes.FF_IMMD
FF_JUMP = _ida_bytes.FF_JUMP

def has_immd(*args):
  """
  has_immd(F) -> bool
  """
  return _ida_bytes.has_immd(*args)

def is_func(*args):
  """
  is_func(F) -> bool
  """
  return _ida_bytes.is_func(*args)

def set_immd(*args):
  """
  set_immd(ea) -> bool
  """
  return _ida_bytes.set_immd(*args)
class data_type_t(object):
    """
    Proxy of C++ data_type_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    props = _swig_property(_ida_bytes.data_type_t_props_get, _ida_bytes.data_type_t_props_set)
    name = _swig_property(_ida_bytes.data_type_t_name_get, _ida_bytes.data_type_t_name_set)
    menu_name = _swig_property(_ida_bytes.data_type_t_menu_name_get, _ida_bytes.data_type_t_menu_name_set)
    hotkey = _swig_property(_ida_bytes.data_type_t_hotkey_get, _ida_bytes.data_type_t_hotkey_set)
    asm_keyword = _swig_property(_ida_bytes.data_type_t_asm_keyword_get, _ida_bytes.data_type_t_asm_keyword_set)
    value_size = _swig_property(_ida_bytes.data_type_t_value_size_get, _ida_bytes.data_type_t_value_size_set)
    def __init__(self, *args):
        """
        __init__(self, self, name, value_size=0, menu_name=None, hotkey=None, asm_keyword=None, props=0) -> data_type_t
        """
        this = _ida_bytes.new_data_type_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_bytes.delete_data_type_t
    __del__ = lambda self : None;
    def __get_id(self, *args):
        """
        __get_id(self) -> int
        """
        return _ida_bytes.data_type_t___get_id(self, *args)

    id = property(__get_id)
    __real__init__ = __init__
    def __init__(self, *args):
        self.__real__init__(self, *args) # pass 'self' as part of args

    if _BC695:
        def __init__(self, name, value_size = 0, menu_name = None, hotkey = None, asm_keyword = None, props = 0):
            args = (name, value_size, menu_name, hotkey, asm_keyword, props)
            self.__real__init__(self, *args) # pass 'self' as part of args


data_type_t_swigregister = _ida_bytes.data_type_t_swigregister
data_type_t_swigregister(data_type_t)
DTP_NODUP = _ida_bytes.DTP_NODUP

class data_format_t(object):
    """
    Proxy of C++ data_format_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    props = _swig_property(_ida_bytes.data_format_t_props_get, _ida_bytes.data_format_t_props_set)
    name = _swig_property(_ida_bytes.data_format_t_name_get, _ida_bytes.data_format_t_name_set)
    menu_name = _swig_property(_ida_bytes.data_format_t_menu_name_get, _ida_bytes.data_format_t_menu_name_set)
    hotkey = _swig_property(_ida_bytes.data_format_t_hotkey_get, _ida_bytes.data_format_t_hotkey_set)
    value_size = _swig_property(_ida_bytes.data_format_t_value_size_get, _ida_bytes.data_format_t_value_size_set)
    text_width = _swig_property(_ida_bytes.data_format_t_text_width_get, _ida_bytes.data_format_t_text_width_set)
    def __init__(self, *args):
        """
        __init__(self, self, name, value_size=0, menu_name=None, props=0, hotkey=None, text_width=0) -> data_format_t
        """
        this = _ida_bytes.new_data_format_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_bytes.delete_data_format_t
    __del__ = lambda self : None;
    def __get_id(self, *args):
        """
        __get_id(self) -> int
        """
        return _ida_bytes.data_format_t___get_id(self, *args)

    id = property(__get_id)
    __real__init__ = __init__
    def __init__(self, *args):
        self.__real__init__(self, *args) # pass 'self' as part of args

    if _BC695:
        def __init__(self, name, value_size = 0, menu_name = None, props = 0, hotkey = None, text_width = 0):
            args = (name, value_size, menu_name, props, hotkey, text_width)
            self.__real__init__(self, *args) # pass 'self' as part of args


data_format_t_swigregister = _ida_bytes.data_format_t_swigregister
data_format_t_swigregister(data_format_t)


def get_custom_data_type(*args):
  """
  get_custom_data_type(dtid) -> data_type_t
  """
  return _ida_bytes.get_custom_data_type(*args)

def get_custom_data_format(*args):
  """
  get_custom_data_format(dfid) -> data_format_t
  """
  return _ida_bytes.get_custom_data_format(*args)

def attach_custom_data_format(*args):
  """
  attach_custom_data_format(dtid, dfid) -> bool
  """
  return _ida_bytes.attach_custom_data_format(*args)

def detach_custom_data_format(*args):
  """
  detach_custom_data_format(dtid, dfid) -> bool
  """
  return _ida_bytes.detach_custom_data_format(*args)

def is_attached_custom_data_format(*args):
  """
  is_attached_custom_data_format(dtid, dfid) -> bool
  """
  return _ida_bytes.is_attached_custom_data_format(*args)

def get_custom_data_types(*args):
  """
  get_custom_data_types(out, min_size=0, max_size=BADADDR) -> int
  """
  return _ida_bytes.get_custom_data_types(*args)

def get_custom_data_formats(*args):
  """
  get_custom_data_formats(out, dtid) -> int
  """
  return _ida_bytes.get_custom_data_formats(*args)

def find_custom_data_type(*args):
  """
  find_custom_data_type(name) -> int
  """
  return _ida_bytes.find_custom_data_type(*args)

def find_custom_data_format(*args):
  """
  find_custom_data_format(name) -> int
  """
  return _ida_bytes.find_custom_data_format(*args)

def set_cmt(*args):
  """
  set_cmt(ea, comm, rptble) -> bool
  """
  return _ida_bytes.set_cmt(*args)

def get_cmt(*args):
  """
  get_cmt(ea, rptble) -> ssize_t
  """
  return _ida_bytes.get_cmt(*args)

def append_cmt(*args):
  """
  append_cmt(ea, str, rptble) -> bool
  """
  return _ida_bytes.append_cmt(*args)

def get_predef_insn_cmt(*args):
  """
  get_predef_insn_cmt(ins) -> ssize_t
  """
  return _ida_bytes.get_predef_insn_cmt(*args)

def find_byte(*args):
  """
  find_byte(sEA, size, value, bin_search_flags) -> ea_t
  """
  return _ida_bytes.find_byte(*args)

def find_byter(*args):
  """
  find_byter(sEA, size, value, bin_search_flags) -> ea_t
  """
  return _ida_bytes.find_byter(*args)
BIN_SEARCH_FORWARD = _ida_bytes.BIN_SEARCH_FORWARD
BIN_SEARCH_BACKWARD = _ida_bytes.BIN_SEARCH_BACKWARD
BIN_SEARCH_CASE = _ida_bytes.BIN_SEARCH_CASE
BIN_SEARCH_NOCASE = _ida_bytes.BIN_SEARCH_NOCASE
BIN_SEARCH_NOBREAK = _ida_bytes.BIN_SEARCH_NOBREAK
BIN_SEARCH_INITED = _ida_bytes.BIN_SEARCH_INITED
BIN_SEARCH_NOSHOW = _ida_bytes.BIN_SEARCH_NOSHOW

def next_inited(*args):
  """
  next_inited(ea, maxea) -> ea_t
  """
  return _ida_bytes.next_inited(*args)

def prev_inited(*args):
  """
  prev_inited(ea, minea) -> ea_t
  """
  return _ida_bytes.prev_inited(*args)

def equal_bytes(*args):
  """
  equal_bytes(ea, image, mask, len, sense_case) -> bool
  """
  return _ida_bytes.equal_bytes(*args)
class hidden_range_t(ida_range.range_t):
    """
    Proxy of C++ hidden_range_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    description = _swig_property(_ida_bytes.hidden_range_t_description_get, _ida_bytes.hidden_range_t_description_set)
    header = _swig_property(_ida_bytes.hidden_range_t_header_get, _ida_bytes.hidden_range_t_header_set)
    footer = _swig_property(_ida_bytes.hidden_range_t_footer_get, _ida_bytes.hidden_range_t_footer_set)
    visible = _swig_property(_ida_bytes.hidden_range_t_visible_get, _ida_bytes.hidden_range_t_visible_set)
    color = _swig_property(_ida_bytes.hidden_range_t_color_get, _ida_bytes.hidden_range_t_color_set)
    def __init__(self, *args):
        """
        __init__(self) -> hidden_range_t
        """
        this = _ida_bytes.new_hidden_range_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_bytes.delete_hidden_range_t
    __del__ = lambda self : None;
hidden_range_t_swigregister = _ida_bytes.hidden_range_t_swigregister
hidden_range_t_swigregister(hidden_range_t)


def update_hidden_range(*args):
  """
  update_hidden_range(ha) -> bool
  """
  return _ida_bytes.update_hidden_range(*args)

def add_hidden_range(*args):
  """
  add_hidden_range(ea1, ea2, description, header, footer, color) -> bool
  """
  return _ida_bytes.add_hidden_range(*args)

def get_hidden_range(*args):
  """
  get_hidden_range(ea) -> hidden_range_t
  """
  return _ida_bytes.get_hidden_range(*args)

def getn_hidden_range(*args):
  """
  getn_hidden_range(n) -> hidden_range_t
  """
  return _ida_bytes.getn_hidden_range(*args)

def get_hidden_range_qty(*args):
  """
  get_hidden_range_qty() -> int
  """
  return _ida_bytes.get_hidden_range_qty(*args)

def get_hidden_range_num(*args):
  """
  get_hidden_range_num(ea) -> int
  """
  return _ida_bytes.get_hidden_range_num(*args)

def get_prev_hidden_range(*args):
  """
  get_prev_hidden_range(ea) -> hidden_range_t
  """
  return _ida_bytes.get_prev_hidden_range(*args)

def get_next_hidden_range(*args):
  """
  get_next_hidden_range(ea) -> hidden_range_t
  """
  return _ida_bytes.get_next_hidden_range(*args)

def get_first_hidden_range(*args):
  """
  get_first_hidden_range() -> hidden_range_t
  """
  return _ida_bytes.get_first_hidden_range(*args)

def get_last_hidden_range(*args):
  """
  get_last_hidden_range() -> hidden_range_t
  """
  return _ida_bytes.get_last_hidden_range(*args)

def del_hidden_range(*args):
  """
  del_hidden_range(ea) -> bool
  """
  return _ida_bytes.del_hidden_range(*args)

def add_mapping(*args):
  """
  add_mapping(_from, to, size) -> bool
  """
  return _ida_bytes.add_mapping(*args)

def del_mapping(*args):
  """
  del_mapping(ea)
  """
  return _ida_bytes.del_mapping(*args)

def use_mapping(*args):
  """
  use_mapping(ea) -> ea_t
  """
  return _ida_bytes.use_mapping(*args)

def get_mappings_qty(*args):
  """
  get_mappings_qty() -> size_t
  """
  return _ida_bytes.get_mappings_qty(*args)

def get_mapping(*args):
  """
  get_mapping(n) -> bool
  """
  return _ida_bytes.get_mapping(*args)

def visit_patched_bytes(*args):
  """
  visit_patched_bytes(ea1, ea2, py_callable) -> int


  Enumerates patched bytes in the given range and invokes a callable
  @param ea1: start address
  @param ea2: end address
  @param callable: a Python callable with the following prototype:
                   callable(ea, fpos, org_val, patch_val).
                   If the callable returns non-zero then that value will be
                   returned to the caller and the enumeration will be
                   interrupted.
  @return: Zero if the enumeration was successful or the return
           value of the callback if enumeration was interrupted.
  """
  return _ida_bytes.visit_patched_bytes(*args)

def next_that(*args):
  """
  next_that(ea, maxea, callable) -> ea_t


  Find next address with a flag satisfying the function 'testf'.
  Start searching from address 'ea'+1 and inspect bytes up to 'maxea'.
  maxea is not included in the search range.
  
  @param callable: a Python callable with the following prototype:
                   callable(flags). Return True to stop enumeration.
  @return: the found address or BADADDR.
  """
  return _ida_bytes.next_that(*args)

def prev_that(*args):
  """
  prev_that(ea, minea, callable) -> ea_t
  """
  return _ida_bytes.prev_that(*args)

def get_bytes(*args):
  """
  get_bytes(ea, size, gmb_flags=0x01) -> PyObject *


  Get the specified number of bytes of the program.
  @param ea: program address
  @param size: number of bytes to return
  @return: the bytes (as a str), or None in case of failure
  """
  return _ida_bytes.get_bytes(*args)

def get_bytes_and_mask(*args):
  """
  get_bytes_and_mask(ea, size, gmb_flags=0x01) -> PyObject *


  Get the specified number of bytes of the program, and a bitmask
  specifying what bytes are defined and what bytes are not.
  @param ea: program address
  @param size: number of bytes to return
  @return: a tuple (bytes, mask), or None in case of failure.
           Both 'bytes' and 'mask' are 'str' instances.
  """
  return _ida_bytes.get_bytes_and_mask(*args)

def get_strlit_contents(*args):
  """
  get_strlit_contents(ea, len, type, flags=0) -> PyObject *


  Get bytes contents at location, possibly converted.
  It works even if the string has not been created in the database yet.
  
  Note that this will <b>always</b> return a simple string of bytes
  (i.e., a 'str' instance), and not a string of unicode characters.
  
  If you want auto-conversion to unicode strings (that is: real strings),
  you should probably be using the idautils.Strings class.
  
  @param ea: linear address of the string
  @param len: length of the string in bytes (including terminating 0)
  @param type: type of the string. Represents both the character encoding,
               <u>and</u> the 'type' of string at the given location.
  @param flags: combination of STRCONV_..., to perform output conversion.
  @return: a bytes-filled str object.
  """
  return _ida_bytes.get_strlit_contents(*args)

def bin_search(*args):
  """
  bin_search(start_ea, end_ea, image, mask, step, flags) -> ea_t
  """
  return _ida_bytes.bin_search(*args)

def print_strlit_type(*args):
  """
  print_strlit_type(strtype, flags=0) -> PyObject *
  """
  return _ida_bytes.print_strlit_type(*args)
#<pycode(py_bytes)>
#</pycode(py_bytes)>


def register_custom_data_type(*args):
  """
  register_custom_data_type(py_dt) -> int


  Registers a custom data type.
  @param dt: an instance of the data_type_t class
  @return:
      < 0 if failed to register
      > 0 data type id
  """
  return _ida_bytes.register_custom_data_type(*args)

def unregister_custom_data_type(*args):
  """
  unregister_custom_data_type(dtid) -> bool


  Unregisters a custom data type.
  @param dtid: the data type id
  @return: Boolean
  """
  return _ida_bytes.unregister_custom_data_type(*args)

def register_custom_data_format(*args):
  """
  register_custom_data_format(py_df) -> int


  Registers a custom data format with a given data type.
  @param df: an instance of data_format_t
  @return:
      < 0 if failed to register
      > 0 data format id
  """
  return _ida_bytes.register_custom_data_format(*args)

def unregister_custom_data_format(*args):
  """
  unregister_custom_data_format(dfid) -> bool


  Unregisters a custom data format
  @param dfid: data format id
  @return: Boolean
  """
  return _ida_bytes.unregister_custom_data_format(*args)
#<pycode(py_bytes_custdata)>
DTP_NODUP = 0x0001
# -----------------------------------------------------------------------
def __walk_types_and_formats(formats, type_action, format_action, installing):
    broken = False
    for f in formats:
        if len(f) == 1:
            if not format_action(f[0], 0):
                broken = True
                break
        else:
            dt  = f[0]
            dfs = f[1:]
            # install data type before installing formats
            if installing and not type_action(dt):
                broken = True
                break
            # process formats using the correct dt.id
            for df in dfs:
                if not format_action(df, dt.id):
                    broken = True
                    break
            # uninstall data type after uninstalling formats
            if not installing and not type_action(dt):
                broken = True
                break
    return not broken

# -----------------------------------------------------------------------
def register_data_types_and_formats(formats):
    """
    Registers multiple data types and formats at once.
    To register one type/format at a time use register_custom_data_type/register_custom_data_format

    It employs a special table of types and formats described below:

    The 'formats' is a list of tuples. If a tuple has one element then it is the format to be registered with dtid=0
    If the tuple has more than one element, then tuple[0] is the data type and tuple[1:] are the data formats. For example:
    many_formats = [
      (pascal_data_type(), pascal_data_format()),
      (simplevm_data_type(), simplevm_data_format()),
      (makedword_data_format(),),
      (simplevm_data_format(),)
    ]
    The first two tuples describe data types and their associated formats.
    The last two tuples describe two data formats to be used with built-in data types.
    The data format may be attached to several data types. The id of the
    data format is stored in the first data_format_t object. For example:
    assert many_formats[1][1] != -1
    assert many_formats[2][0] != -1
    assert many_formats[3][0] == -1
    """
    def __reg_format(df, dtid):
        dfid = register_custom_data_format(df);
        if dfid == -1:
            dfid = find_custom_data_format(df.name);
            if dfid == -1:
              return False
        attach_custom_data_format(dtid, dfid)
        if dtid == 0:
            print "Registered format '%s' with built-in types, ID=%d" % (df.name, dfid)
        else:
            print "   Registered format '%s', ID=%d (dtid=%d)" % (df.name, dfid, dtid)
        return True

    def __reg_type(dt):
        register_custom_data_type(dt)
        print "Registered type '%s', ID=%d" % (dt.name, dt.id)
        return dt.id != -1
    ok = __walk_types_and_formats(formats, __reg_type, __reg_format, True)
    return 1 if ok else -1

# -----------------------------------------------------------------------
def unregister_data_types_and_formats(formats):
    """
    As opposed to register_data_types_and_formats(), this function
    unregisters multiple data types and formats at once.
    """
    def __unreg_format(df, dtid):
        print "%snregistering format '%s'" % ("U" if dtid == 0 else "   u", df.name)
        unregister_custom_data_format(df.id)
        return True

    def __unreg_type(dt):
        print "Unregistering type '%s', ID=%d" % (dt.name, dt.id)
        unregister_custom_data_type(dt.id)
        return True
    ok = __walk_types_and_formats(formats, __unreg_type, __unreg_format, False)
    return 1 if ok else -1

#--------------------------------------------------------------------------
#
#
#<pydoc>
#class data_type_t(object):
#    """
#    The following optional callback methods can be implemented
#    in a data_type_t subclass
#    """
#
#    def may_create_at(ea, nbytes):
#        """May create data?
#        No such callback means: always succeed (i.e., no restriction where
#        such a data type can be created.)
#        @param ea: candidate address for the data item
#        @param nbytes: candidate size for the data item
#        @return: True/False
#        """
#        return True
#
#    def calc_item_size(ea, maxsize):
#        """This callback is used to determine size of the (possible)
#        item at `ea`.
#        No such callback means that datatype is of fixed size `value_size`.
#        (thus, this callback is required only for varsize datatypes.)
#        @param ea: address of the item
#        @param maxsize: maximum size of the item
#        @return: 0 - no such item can be created/displayed
#        """
#        return 0
#
#
#class data_format_t(object):
#    """
#    The following callback methods can be implemented
#    in a data_format_t subclass
#    """
#
#    def printf(value, current_ea, operand_num, dtid):
#        """Convert `value` to colored string using custom format.
#        @param value: value to print (of type 'str', sequence of bytes)
#        @param current_ea: current address (BADADDR if unknown)
#        @param operand_num: current operand number
#        @param dtid: custom data type id
#        @return: string representing data
#        """
#        return None
#
#    def scan(input, current_ea, operand_num):
#        """Convert uncolored string (user input) to the value.
#        This callback is called from the debugger when an user enters a
#        new value for a register with a custom data representation (e.g.,
#        an MMX register.)
#        @param input: input string
#        @param current_ea: current address (BADADDR if unknown)
#        @param operand_num: current operand number (-1 if unknown)
#        @return: tuple(bool, string)
#                 (True, output value) or
#                 (False, error message)
#        """
#        return (False, "Not implemented")
#
#    def analyze(current_ea, operand_num):
#        """Analyze custom data format occurrence.
#        This callback is called in 2 cases:
#        - after emulating an instruction (after a call of
#          'ev_emu_insn') if its operand is marked as "custom data
#          representation"
#        - when emulating data (this is done using a call of
#          'ev_out_data' with analyze_only == true). This is the right
#          place to create cross references from the current item.
#        @param current_ea: current address (BADADDR if unknown)
#        @param operand_num: current operand number
#        """
#        pass
#
#
#</pydoc>
#</pycode(py_bytes_custdata)>

if _BC695:
    ACFOPT_ASCII=0
    ACFOPT_CONVMASK=0
    ACFOPT_ESCAPE=STRCONV_ESCAPE
    ACFOPT_UTF16=0
    ACFOPT_UTF8=0
    DOUNK_DELNAMES=DELIT_DELNAMES
    DOUNK_EXPAND=DELIT_EXPAND
    DOUNK_NOTRUNC=DELIT_NOTRUNC
    DOUNK_SIMPLE=DELIT_SIMPLE
    FF_ASCI=FF_STRLIT
    FF_DWRD=FF_DWORD
    FF_OWRD=FF_OWORD
    FF_QWRD=FF_QWORD
    FF_STRU=FF_STRUCT
    FF_TBYT=FF_TBYTE
    FF_VAR=0
    FF_YWRD=FF_YWORD
    FF_ZWRD=FF_ZWORD
    GFE_NOVALUE=0
    add_hidden_area=add_hidden_range
    asciflag=strlit_flag
    delValue=del_value
    del_hidden_area=del_hidden_range
    do16bit=create_16bit_data
    do32bit=create_32bit_data
    doAlign=create_align
    doByte=create_byte
    doCustomData=create_custdata
    doDouble=create_double
    doDwrd=create_dword
    doExtra=ida_idaapi._BC695.false_p
    doFloat=create_float
    doImmd=set_immd
    doOwrd=create_oword
    doPackReal=create_packed_real
    doQwrd=create_qword
    doStruct=create_struct
    doTbyt=create_tbyte
    doWord=create_word
    doYwrd=create_yword
    doZwrd=create_zword
    do_data_ex=create_data
    do_unknown=del_items
    @bc695redef
    def do_unknown_range(ea, size, flags):
        return del_items(ea, flags, size) # swap 2 last args
    dwrdflag=dword_flag
    f_hasRef=f_has_xref
    f_isASCII=f_is_strlit
    f_isAlign=f_is_align
    f_isByte=f_is_byte
    f_isCode=f_is_code
    f_isCustom=f_is_custom
    f_isData=f_is_data
    f_isDouble=f_is_double
    f_isDwrd=f_is_dword
    f_isFloat=f_is_float
    f_isHead=f_is_head
    f_isNotTail=f_is_not_tail
    f_isOwrd=f_is_oword
    f_isPackReal=f_is_pack_real
    f_isQwrd=f_is_qword
    f_isStruct=f_is_struct
    f_isTail=f_is_tail
    f_isTbyt=f_is_tbyte
    f_isWord=f_is_word
    f_isYwrd=f_is_yword
    getDefaultRadix=get_default_radix
    getFlags=get_full_flags
    get_long=get_dword
    get_full_byte=get_wide_byte
    get_full_word=get_wide_word
    get_full_long=get_wide_dword
    get_original_long=get_original_dword
    put_long=put_dword
    patch_long=patch_dword
    add_long=add_dword
    getRadix=get_radix
    get_ascii_contents=get_strlit_contents
    get_ascii_contents2=get_strlit_contents
    get_flags_novalue=get_flags
    get_hidden_area=get_hidden_range
    get_hidden_area_num=get_hidden_range_num
    get_hidden_area_qty=get_hidden_range_qty
    @bc695redef
    def get_many_bytes(ea, size):
        return get_bytes(ea, size)
    @bc695redef
    def get_many_bytes_ex(ea, size):
        return get_bytes_and_mask(ea, size)
    get_max_ascii_length=get_max_strlit_length
    get_next_hidden_area=get_next_hidden_range
    get_prev_hidden_area=get_prev_hidden_range
    get_zero_areas=get_zero_ranges
    getn_hidden_area=getn_hidden_range
    hasExtra=has_extra_cmts
    hasRef=has_xref
    hasValue=has_value
    hidden_area_t=hidden_range_t
    isASCII=is_strlit
    isAlign=is_align
    isByte=is_byte
    isChar=is_char
    isChar0=is_char0
    isChar1=is_char1
    isCode=is_code
    isCustFmt=is_custfmt
    isCustFmt0=is_custfmt0
    isCustFmt1=is_custfmt1
    isCustom=is_custom
    isData=is_data
    isDefArg=is_defarg
    isDefArg0=is_defarg0
    isDefArg1=is_defarg1
    isDouble=is_double
    isDwrd=is_dword
    isEnabled=is_mapped
    isEnum=is_enum
    isEnum0=is_enum0
    isEnum1=is_enum1
    isFloat=is_float
    isFloat0=is_float0
    isFloat1=is_float1
    isFlow=is_flow
    isFltnum=is_fltnum
    isFop=is_forced_operand
    isFunc=is_func
    isHead=is_head
    isImmd=has_immd
    isLoaded=is_loaded
    isNotTail=is_not_tail
    isNum=is_numop
    isNum0=is_numop0
    isNum1=is_numop1
    isOff=is_off
    isOff0=is_off0
    isOff1=is_off1
    isOwrd=is_oword
    isPackReal=is_pack_real
    isQwrd=is_qword
    isSeg=is_seg
    isSeg0=is_seg0
    isSeg1=is_seg1
    isStkvar=is_stkvar
    isStkvar0=is_stkvar0
    isStkvar1=is_stkvar1
    isStroff=is_stroff
    isStroff0=is_stroff0
    isStroff1=is_stroff1
    isStruct=is_struct
    isTail=is_tail
    isTbyt=is_tbyte
    isUnknown=is_unknown
    isVoid=is_suspop
    isWord=is_word
    isYwrd=is_yword
    isZwrd=is_zword
    make_ascii_string=create_strlit
    noExtra=ida_idaapi._BC695.false_p
    noType=clr_op_type
    owrdflag=oword_flag
    patch_many_bytes=patch_bytes
    print_ascii_string_type=print_strlit_type
    put_many_bytes=put_bytes
    qwrdflag=qword_flag
    tbytflag=tbyte_flag
    update_hidden_area=update_hidden_range
    ywrdflag=yword_flag
    zwrdflag=zword_flag
    def get_opinfo(*args):
        import ida_nalt
        if isinstance(args[3], ida_nalt.opinfo_t): # 6.95: ea, n, flags, buf
            ea, n, flags, buf = args
        else:                                      # 7.00: buf, ea, n, flags
            buf, ea, n, flags = args
        return _ida_bytes.get_opinfo(buf, ea, n, flags)
    @bc695redef
    def doASCI(ea, length):
        import ida_netnode
        return create_data(ea, FF_STRLIT, length, ida_netnode.BADNODE)
    FF_3BYTE=FF_BYTE
    chunksize=chunk_size
    chunkstart=chunk_start
    do3byte=ida_idaapi._BC695.false_p
    f_is3byte=ida_idaapi._BC695.false_p
    freechunk=free_chunk
    get_3byte=ida_idaapi._BC695.false_p
    is3byte=ida_idaapi._BC695.false_p
    nextaddr=next_addr
    nextchunk=next_chunk
    nextthat=next_that
    prevaddr=prev_addr
    prevchunk=prev_chunk
    prevthat=prev_that
    tribyteflag=byte_flag
    alignflag=align_flag
    binflag=bin_flag
    byteflag=byte_flag
    charflag=char_flag
    codeflag=code_flag
    custflag=cust_flag
    custfmtflag=custfmt_flag
    decflag=dec_flag
    doubleflag=double_flag
    enumflag=enum_flag
    floatflag=float_flag
    fltflag=flt_flag
    hexflag=hex_flag
    numflag=num_flag
    octflag=oct_flag
    offflag=off_flag
    packrealflag=packreal_flag
    segflag=seg_flag
    stkvarflag=stkvar_flag
    stroffflag=stroff_flag
    struflag=stru_flag
    wordflag=word_flag
    invalidate_visea_cache=ida_idaapi._BC695.false_p




