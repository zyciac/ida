# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
IDA Plugin SDK API wrapper: loader
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ida_loader', [dirname(__file__)])
        except ImportError:
            import _ida_loader
            return _ida_loader
        if fp is not None:
            try:
                _mod = imp.load_module('_ida_loader', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ida_loader = swig_import_helper()
    del swig_import_helper
else:
    import _ida_loader
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import ida_idaapi

import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        func.func_dict["bc695redef"] = True
        return func

class qvector_snapshotvec_t(object):
    """
    Proxy of C++ qvector<(p.snapshot_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> qvector_snapshotvec_t
        __init__(self, x) -> qvector_snapshotvec_t
        """
        this = _ida_loader.new_qvector_snapshotvec_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_loader.delete_qvector_snapshotvec_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> snapshot_t *&
        """
        return _ida_loader.qvector_snapshotvec_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_loader.qvector_snapshotvec_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_loader.qvector_snapshotvec_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_loader.qvector_snapshotvec_t_empty(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_loader.qvector_snapshotvec_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_loader.qvector_snapshotvec_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_loader.qvector_snapshotvec_t_resize(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_loader.qvector_snapshotvec_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_loader.qvector_snapshotvec_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_loader.qvector_snapshotvec_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_loader.qvector_snapshotvec_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> snapshot_t **
        """
        return _ida_loader.qvector_snapshotvec_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_loader.qvector_snapshotvec_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_loader.qvector_snapshotvec_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_loader.qvector_snapshotvec_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> qvector< snapshot_t * >::iterator
        begin(self) -> qvector< snapshot_t * >::const_iterator
        """
        return _ida_loader.qvector_snapshotvec_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> qvector< snapshot_t * >::iterator
        end(self) -> qvector< snapshot_t * >::const_iterator
        """
        return _ida_loader.qvector_snapshotvec_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> qvector< snapshot_t * >::iterator
        """
        return _ida_loader.qvector_snapshotvec_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> qvector< snapshot_t * >::iterator
        erase(self, first, last) -> qvector< snapshot_t * >::iterator
        """
        return _ida_loader.qvector_snapshotvec_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> qvector< snapshot_t * >::iterator
        find(self, x) -> qvector< snapshot_t * >::const_iterator
        """
        return _ida_loader.qvector_snapshotvec_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_loader.qvector_snapshotvec_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_loader.qvector_snapshotvec_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_loader.qvector_snapshotvec_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_loader.qvector_snapshotvec_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> snapshot_t
        """
        return _ida_loader.qvector_snapshotvec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_loader.qvector_snapshotvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

    def at(self, *args):
        """
        at(self, n) -> snapshot_t
        """
        return _ida_loader.qvector_snapshotvec_t_at(self, *args)

qvector_snapshotvec_t_swigregister = _ida_loader.qvector_snapshotvec_t_swigregister
qvector_snapshotvec_t_swigregister(qvector_snapshotvec_t)

class loader_t(object):
    """
    Proxy of C++ loader_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    version = _swig_property(_ida_loader.loader_t_version_get, _ida_loader.loader_t_version_set)
    flags = _swig_property(_ida_loader.loader_t_flags_get, _ida_loader.loader_t_flags_set)
    def __init__(self, *args):
        """
        __init__(self) -> loader_t
        """
        this = _ida_loader.new_loader_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_loader.delete_loader_t
    __del__ = lambda self : None;
loader_t_swigregister = _ida_loader.loader_t_swigregister
loader_t_swigregister(loader_t)
LDRF_RELOAD = _ida_loader.LDRF_RELOAD
LDRF_REQ_PROC = _ida_loader.LDRF_REQ_PROC
ACCEPT_ARCHIVE = _ida_loader.ACCEPT_ARCHIVE
ACCEPT_CONTINUE = _ida_loader.ACCEPT_CONTINUE
ACCEPT_FIRST = _ida_loader.ACCEPT_FIRST
NEF_SEGS = _ida_loader.NEF_SEGS
NEF_RSCS = _ida_loader.NEF_RSCS
NEF_NAME = _ida_loader.NEF_NAME
NEF_MAN = _ida_loader.NEF_MAN
NEF_FILL = _ida_loader.NEF_FILL
NEF_IMPS = _ida_loader.NEF_IMPS
NEF_FIRST = _ida_loader.NEF_FIRST
NEF_CODE = _ida_loader.NEF_CODE
NEF_RELOAD = _ida_loader.NEF_RELOAD
NEF_FLAT = _ida_loader.NEF_FLAT
NEF_MINI = _ida_loader.NEF_MINI
NEF_LOPT = _ida_loader.NEF_LOPT
NEF_LALL = _ida_loader.NEF_LALL

LOADER_EXT = _ida_loader.LOADER_EXT
PLUGIN_EXT = _ida_loader.PLUGIN_EXT
IDP_EXT = _ida_loader.IDP_EXT
LOADER_DLL = _ida_loader.LOADER_DLL

def load_binary_file(*args):
  """
  load_binary_file(filename, li, _neflags, fileoff, basepara, binoff, nbytes) -> bool
  """
  return _ida_loader.load_binary_file(*args)

def process_archive(*args):
  """
  process_archive(temp_file, li, module_name, neflags, defmember, loader) -> int
  """
  return _ida_loader.process_archive(*args)
OFILE_MAP = _ida_loader.OFILE_MAP
OFILE_EXE = _ida_loader.OFILE_EXE
OFILE_IDC = _ida_loader.OFILE_IDC
OFILE_LST = _ida_loader.OFILE_LST
OFILE_ASM = _ida_loader.OFILE_ASM
OFILE_DIF = _ida_loader.OFILE_DIF

def gen_file(*args):
  """
  gen_file(otype, fp, ea1, ea2, flags) -> int
  """
  return _ida_loader.gen_file(*args)
GENFLG_MAPSEG = _ida_loader.GENFLG_MAPSEG
GENFLG_MAPNAME = _ida_loader.GENFLG_MAPNAME
GENFLG_MAPDMNG = _ida_loader.GENFLG_MAPDMNG
GENFLG_MAPLOC = _ida_loader.GENFLG_MAPLOC
GENFLG_IDCTYPE = _ida_loader.GENFLG_IDCTYPE
GENFLG_ASMTYPE = _ida_loader.GENFLG_ASMTYPE
GENFLG_GENHTML = _ida_loader.GENFLG_GENHTML
GENFLG_ASMINC = _ida_loader.GENFLG_ASMINC

def file2base(*args):
  """
  file2base(li, pos, ea1, ea2, patchable) -> int
  """
  return _ida_loader.file2base(*args)
FILEREG_PATCHABLE = _ida_loader.FILEREG_PATCHABLE
FILEREG_NOTPATCHABLE = _ida_loader.FILEREG_NOTPATCHABLE

def base2file(*args):
  """
  base2file(fp, pos, ea1, ea2) -> int
  """
  return _ida_loader.base2file(*args)

def extract_module_from_archive(*args):
  """
  extract_module_from_archive(filename, bufsize, temp_file_ptr, is_remote) -> bool
  """
  return _ida_loader.extract_module_from_archive(*args)

def get_basic_file_type(*args):
  """
  get_basic_file_type(li) -> filetype_t
  """
  return _ida_loader.get_basic_file_type(*args)

def get_file_type_name(*args):
  """
  get_file_type_name() -> size_t
  """
  return _ida_loader.get_file_type_name(*args)

def load_ids_module(*args):
  """
  load_ids_module(fname) -> int
  """
  return _ida_loader.load_ids_module(*args)

def get_plugin_options(*args):
  """
  get_plugin_options(plugin) -> char const *
  """
  return _ida_loader.get_plugin_options(*args)
PLUGIN_DLL = _ida_loader.PLUGIN_DLL
MODULE_ENTRY_LOADER = _ida_loader.MODULE_ENTRY_LOADER
MODULE_ENTRY_PLUGIN = _ida_loader.MODULE_ENTRY_PLUGIN
MODULE_ENTRY_IDP = _ida_loader.MODULE_ENTRY_IDP
class idp_name_t(object):
    """
    Proxy of C++ idp_name_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    lname = _swig_property(_ida_loader.idp_name_t_lname_get, _ida_loader.idp_name_t_lname_set)
    sname = _swig_property(_ida_loader.idp_name_t_sname_get, _ida_loader.idp_name_t_sname_set)
    hidden = _swig_property(_ida_loader.idp_name_t_hidden_get, _ida_loader.idp_name_t_hidden_set)
    def __init__(self, *args):
        """
        __init__(self) -> idp_name_t
        """
        this = _ida_loader.new_idp_name_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_loader.delete_idp_name_t
    __del__ = lambda self : None;
idp_name_t_swigregister = _ida_loader.idp_name_t_swigregister
idp_name_t_swigregister(idp_name_t)

class idp_desc_t(object):
    """
    Proxy of C++ idp_desc_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    path = _swig_property(_ida_loader.idp_desc_t_path_get, _ida_loader.idp_desc_t_path_set)
    mtime = _swig_property(_ida_loader.idp_desc_t_mtime_get, _ida_loader.idp_desc_t_mtime_set)
    family = _swig_property(_ida_loader.idp_desc_t_family_get, _ida_loader.idp_desc_t_family_set)
    names = _swig_property(_ida_loader.idp_desc_t_names_get, _ida_loader.idp_desc_t_names_set)
    is_script = _swig_property(_ida_loader.idp_desc_t_is_script_get, _ida_loader.idp_desc_t_is_script_set)
    checked = _swig_property(_ida_loader.idp_desc_t_checked_get, _ida_loader.idp_desc_t_checked_set)
    def __init__(self, *args):
        """
        __init__(self) -> idp_desc_t
        """
        this = _ida_loader.new_idp_desc_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_loader.delete_idp_desc_t
    __del__ = lambda self : None;
idp_desc_t_swigregister = _ida_loader.idp_desc_t_swigregister
idp_desc_t_swigregister(idp_desc_t)

IDP_DLL = _ida_loader.IDP_DLL
class plugin_info_t(object):
    """
    Proxy of C++ plugin_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    next = _swig_property(_ida_loader.plugin_info_t_next_get, _ida_loader.plugin_info_t_next_set)
    path = _swig_property(_ida_loader.plugin_info_t_path_get, _ida_loader.plugin_info_t_path_set)
    org_name = _swig_property(_ida_loader.plugin_info_t_org_name_get, _ida_loader.plugin_info_t_org_name_set)
    name = _swig_property(_ida_loader.plugin_info_t_name_get, _ida_loader.plugin_info_t_name_set)
    org_hotkey = _swig_property(_ida_loader.plugin_info_t_org_hotkey_get, _ida_loader.plugin_info_t_org_hotkey_set)
    hotkey = _swig_property(_ida_loader.plugin_info_t_hotkey_get, _ida_loader.plugin_info_t_hotkey_set)
    arg = _swig_property(_ida_loader.plugin_info_t_arg_get, _ida_loader.plugin_info_t_arg_set)
    entry = _swig_property(_ida_loader.plugin_info_t_entry_get, _ida_loader.plugin_info_t_entry_set)
    dllmem = _swig_property(_ida_loader.plugin_info_t_dllmem_get, _ida_loader.plugin_info_t_dllmem_set)
    flags = _swig_property(_ida_loader.plugin_info_t_flags_get, _ida_loader.plugin_info_t_flags_set)
    comment = _swig_property(_ida_loader.plugin_info_t_comment_get, _ida_loader.plugin_info_t_comment_set)
    def __init__(self, *args):
        """
        __init__(self) -> plugin_info_t
        """
        this = _ida_loader.new_plugin_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_loader.delete_plugin_info_t
    __del__ = lambda self : None;
plugin_info_t_swigregister = _ida_loader.plugin_info_t_swigregister
plugin_info_t_swigregister(plugin_info_t)


def find_plugin(*args):
  """
  find_plugin(name, load_if_needed=False) -> plugin_t *
  """
  return _ida_loader.find_plugin(*args)

def load_and_run_plugin(*args):
  """
  load_and_run_plugin(name, arg) -> bool
  """
  return _ida_loader.load_and_run_plugin(*args)

def get_fileregion_offset(*args):
  """
  get_fileregion_offset(ea) -> qoff64_t
  """
  return _ida_loader.get_fileregion_offset(*args)

def get_fileregion_ea(*args):
  """
  get_fileregion_ea(offset) -> ea_t
  """
  return _ida_loader.get_fileregion_ea(*args)

def gen_exe_file(*args):
  """
  gen_exe_file(fp) -> int
  """
  return _ida_loader.gen_exe_file(*args)

def reload_file(*args):
  """
  reload_file(file, is_remote) -> int
  """
  return _ida_loader.reload_file(*args)
MAX_DATABASE_DESCRIPTION = _ida_loader.MAX_DATABASE_DESCRIPTION
class snapshot_t(object):
    """
    Proxy of C++ snapshot_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    id = _swig_property(_ida_loader.snapshot_t_id_get, _ida_loader.snapshot_t_id_set)
    flags = _swig_property(_ida_loader.snapshot_t_flags_get, _ida_loader.snapshot_t_flags_set)
    desc = _swig_property(_ida_loader.snapshot_t_desc_get, _ida_loader.snapshot_t_desc_set)
    filename = _swig_property(_ida_loader.snapshot_t_filename_get, _ida_loader.snapshot_t_filename_set)
    children = _swig_property(_ida_loader.snapshot_t_children_get, _ida_loader.snapshot_t_children_set)
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_loader.snapshot_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_loader.snapshot_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_loader.snapshot_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_loader.snapshot_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_loader.snapshot_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_loader.snapshot_t___ge__(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_loader.snapshot_t_clear(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> snapshot_t
        """
        this = _ida_loader.new_snapshot_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_loader.delete_snapshot_t
    __del__ = lambda self : None;
snapshot_t_swigregister = _ida_loader.snapshot_t_swigregister
snapshot_t_swigregister(snapshot_t)
SSF_AUTOMATIC = _ida_loader.SSF_AUTOMATIC


def build_snapshot_tree(*args):
  """
  build_snapshot_tree(root) -> bool
  """
  return _ida_loader.build_snapshot_tree(*args)
SSUF_DESC = _ida_loader.SSUF_DESC
SSUF_PATH = _ida_loader.SSUF_PATH
SSUF_FLAGS = _ida_loader.SSUF_FLAGS

def flush_buffers(*args):
  """
  flush_buffers() -> int
  """
  return _ida_loader.flush_buffers(*args)

def is_trusted_idb(*args):
  """
  is_trusted_idb() -> bool
  """
  return _ida_loader.is_trusted_idb(*args)

def save_database(*args):
  """
  save_database(outfile, flags, root=None, attr=None) -> bool
  """
  return _ida_loader.save_database(*args)
DBFL_KILL = _ida_loader.DBFL_KILL
DBFL_COMP = _ida_loader.DBFL_COMP
DBFL_BAK = _ida_loader.DBFL_BAK
DBFL_TEMP = _ida_loader.DBFL_TEMP

def is_database_flag(*args):
  """
  is_database_flag(dbfl) -> bool
  """
  return _ida_loader.is_database_flag(*args)

def set_database_flag(*args):
  """
  set_database_flag(dbfl, cnd=True)
  """
  return _ida_loader.set_database_flag(*args)

def clr_database_flag(*args):
  """
  clr_database_flag(dbfl)
  """
  return _ida_loader.clr_database_flag(*args)
PATH_TYPE_CMD = _ida_loader.PATH_TYPE_CMD
PATH_TYPE_IDB = _ida_loader.PATH_TYPE_IDB
PATH_TYPE_ID0 = _ida_loader.PATH_TYPE_ID0

def get_path(*args):
  """
  get_path(pt) -> char const *
  """
  return _ida_loader.get_path(*args)

def set_path(*args):
  """
  set_path(pt, path)
  """
  return _ida_loader.set_path(*args)

def mem2base(*args):
  """
  mem2base(py_mem, ea, fpos=-1) -> int


  Load database from the memory.
  @param mem: the buffer
  @param ea: start linear addresses
  @param fpos: position in the input file the data is taken from.
               if == -1, then no file position correspond to the data.
  @return:
      - Returns zero if the passed buffer was not a string
      - Otherwise 1 is returned
  """
  return _ida_loader.mem2base(*args)

def load_plugin(*args):
  """
  load_plugin(name) -> PyObject *


  Loads a plugin
  @return:
      - None if plugin could not be loaded
      - An opaque object representing the loaded plugin
  """
  return _ida_loader.load_plugin(*args)

def run_plugin(*args):
  """
  run_plugin(plg, arg) -> bool


  Runs a plugin
  @param plg: A plugin object (returned by load_plugin())
  @return: Boolean
  """
  return _ida_loader.run_plugin(*args)
if _BC695:
    NEF_TIGHT=0
    @bc695redef
    def save_database(outfile, flags=0):
        if isinstance(flags, bool):
            flags = DBFL_KILL if flags else 0
        return _ida_loader.save_database(outfile, flags)
    save_database_ex=save_database




