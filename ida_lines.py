# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
IDA Plugin SDK API wrapper: lines
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ida_lines', [dirname(__file__)])
        except ImportError:
            import _ida_lines
            return _ida_lines
        if fp is not None:
            try:
                _mod = imp.load_module('_ida_lines', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ida_lines = swig_import_helper()
    del swig_import_helper
else:
    import _ida_lines
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import ida_idaapi

import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        func.func_dict["bc695redef"] = True
        return func

COLOR_ON = _ida_lines.COLOR_ON
COLOR_OFF = _ida_lines.COLOR_OFF
COLOR_ESC = _ida_lines.COLOR_ESC
COLOR_INV = _ida_lines.COLOR_INV
SCOLOR_ON = _ida_lines.SCOLOR_ON
SCOLOR_OFF = _ida_lines.SCOLOR_OFF
SCOLOR_ESC = _ida_lines.SCOLOR_ESC
SCOLOR_INV = _ida_lines.SCOLOR_INV
SCOLOR_DEFAULT = _ida_lines.SCOLOR_DEFAULT
SCOLOR_REGCMT = _ida_lines.SCOLOR_REGCMT
SCOLOR_RPTCMT = _ida_lines.SCOLOR_RPTCMT
SCOLOR_AUTOCMT = _ida_lines.SCOLOR_AUTOCMT
SCOLOR_INSN = _ida_lines.SCOLOR_INSN
SCOLOR_DATNAME = _ida_lines.SCOLOR_DATNAME
SCOLOR_DNAME = _ida_lines.SCOLOR_DNAME
SCOLOR_DEMNAME = _ida_lines.SCOLOR_DEMNAME
SCOLOR_SYMBOL = _ida_lines.SCOLOR_SYMBOL
SCOLOR_CHAR = _ida_lines.SCOLOR_CHAR
SCOLOR_STRING = _ida_lines.SCOLOR_STRING
SCOLOR_NUMBER = _ida_lines.SCOLOR_NUMBER
SCOLOR_VOIDOP = _ida_lines.SCOLOR_VOIDOP
SCOLOR_CREF = _ida_lines.SCOLOR_CREF
SCOLOR_DREF = _ida_lines.SCOLOR_DREF
SCOLOR_CREFTAIL = _ida_lines.SCOLOR_CREFTAIL
SCOLOR_DREFTAIL = _ida_lines.SCOLOR_DREFTAIL
SCOLOR_ERROR = _ida_lines.SCOLOR_ERROR
SCOLOR_PREFIX = _ida_lines.SCOLOR_PREFIX
SCOLOR_BINPREF = _ida_lines.SCOLOR_BINPREF
SCOLOR_EXTRA = _ida_lines.SCOLOR_EXTRA
SCOLOR_ALTOP = _ida_lines.SCOLOR_ALTOP
SCOLOR_HIDNAME = _ida_lines.SCOLOR_HIDNAME
SCOLOR_LIBNAME = _ida_lines.SCOLOR_LIBNAME
SCOLOR_LOCNAME = _ida_lines.SCOLOR_LOCNAME
SCOLOR_CODNAME = _ida_lines.SCOLOR_CODNAME
SCOLOR_ASMDIR = _ida_lines.SCOLOR_ASMDIR
SCOLOR_MACRO = _ida_lines.SCOLOR_MACRO
SCOLOR_DSTR = _ida_lines.SCOLOR_DSTR
SCOLOR_DCHAR = _ida_lines.SCOLOR_DCHAR
SCOLOR_DNUM = _ida_lines.SCOLOR_DNUM
SCOLOR_KEYWORD = _ida_lines.SCOLOR_KEYWORD
SCOLOR_REG = _ida_lines.SCOLOR_REG
SCOLOR_IMPNAME = _ida_lines.SCOLOR_IMPNAME
SCOLOR_SEGNAME = _ida_lines.SCOLOR_SEGNAME
SCOLOR_UNKNAME = _ida_lines.SCOLOR_UNKNAME
SCOLOR_CNAME = _ida_lines.SCOLOR_CNAME
SCOLOR_UNAME = _ida_lines.SCOLOR_UNAME
SCOLOR_COLLAPSED = _ida_lines.SCOLOR_COLLAPSED
SCOLOR_ADDR = _ida_lines.SCOLOR_ADDR

def tag_strlen(*args):
  """
  tag_strlen(line) -> ssize_t
  """
  return _ida_lines.tag_strlen(*args)
COLOR_SELECTED = _ida_lines.COLOR_SELECTED
COLOR_LIBFUNC = _ida_lines.COLOR_LIBFUNC
COLOR_REGFUNC = _ida_lines.COLOR_REGFUNC
COLOR_CODE = _ida_lines.COLOR_CODE
COLOR_DATA = _ida_lines.COLOR_DATA
COLOR_UNKNOWN = _ida_lines.COLOR_UNKNOWN
COLOR_EXTERN = _ida_lines.COLOR_EXTERN
COLOR_CURITEM = _ida_lines.COLOR_CURITEM
COLOR_CURLINE = _ida_lines.COLOR_CURLINE
COLOR_HIDLINE = _ida_lines.COLOR_HIDLINE
COLOR_BG_MAX = _ida_lines.COLOR_BG_MAX

def calc_prefix_color(*args):
  """
  calc_prefix_color(ea) -> color_t
  """
  return _ida_lines.calc_prefix_color(*args)

def calc_bg_color(*args):
  """
  calc_bg_color(ea) -> bgcolor_t
  """
  return _ida_lines.calc_bg_color(*args)
class bgcolors_t(object):
    """
    Proxy of C++ bgcolors_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    prolog_color = _swig_property(_ida_lines.bgcolors_t_prolog_color_get, _ida_lines.bgcolors_t_prolog_color_set)
    epilog_color = _swig_property(_ida_lines.bgcolors_t_epilog_color_get, _ida_lines.bgcolors_t_epilog_color_set)
    switch_color = _swig_property(_ida_lines.bgcolors_t_switch_color_get, _ida_lines.bgcolors_t_switch_color_set)
    def __init__(self, *args):
        """
        __init__(self) -> bgcolors_t
        """
        this = _ida_lines.new_bgcolors_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_lines.delete_bgcolors_t
    __del__ = lambda self : None;
bgcolors_t_swigregister = _ida_lines.bgcolors_t_swigregister
bgcolors_t_swigregister(bgcolors_t)
cvar = _ida_lines.cvar
COLOR_DEFAULT = cvar.COLOR_DEFAULT
COLOR_REGCMT = cvar.COLOR_REGCMT
COLOR_RPTCMT = cvar.COLOR_RPTCMT
COLOR_AUTOCMT = cvar.COLOR_AUTOCMT
COLOR_INSN = cvar.COLOR_INSN
COLOR_DATNAME = cvar.COLOR_DATNAME
COLOR_DNAME = cvar.COLOR_DNAME
COLOR_DEMNAME = cvar.COLOR_DEMNAME
COLOR_SYMBOL = cvar.COLOR_SYMBOL
COLOR_CHAR = cvar.COLOR_CHAR
COLOR_STRING = cvar.COLOR_STRING
COLOR_NUMBER = cvar.COLOR_NUMBER
COLOR_VOIDOP = cvar.COLOR_VOIDOP
COLOR_CREF = cvar.COLOR_CREF
COLOR_DREF = cvar.COLOR_DREF
COLOR_CREFTAIL = cvar.COLOR_CREFTAIL
COLOR_DREFTAIL = cvar.COLOR_DREFTAIL
COLOR_ERROR = cvar.COLOR_ERROR
COLOR_PREFIX = cvar.COLOR_PREFIX
COLOR_BINPREF = cvar.COLOR_BINPREF
COLOR_EXTRA = cvar.COLOR_EXTRA
COLOR_ALTOP = cvar.COLOR_ALTOP
COLOR_HIDNAME = cvar.COLOR_HIDNAME
COLOR_LIBNAME = cvar.COLOR_LIBNAME
COLOR_LOCNAME = cvar.COLOR_LOCNAME
COLOR_CODNAME = cvar.COLOR_CODNAME
COLOR_ASMDIR = cvar.COLOR_ASMDIR
COLOR_MACRO = cvar.COLOR_MACRO
COLOR_DSTR = cvar.COLOR_DSTR
COLOR_DCHAR = cvar.COLOR_DCHAR
COLOR_DNUM = cvar.COLOR_DNUM
COLOR_KEYWORD = cvar.COLOR_KEYWORD
COLOR_REG = cvar.COLOR_REG
COLOR_IMPNAME = cvar.COLOR_IMPNAME
COLOR_SEGNAME = cvar.COLOR_SEGNAME
COLOR_UNKNAME = cvar.COLOR_UNKNAME
COLOR_CNAME = cvar.COLOR_CNAME
COLOR_UNAME = cvar.COLOR_UNAME
COLOR_COLLAPSED = cvar.COLOR_COLLAPSED
COLOR_FG_MAX = cvar.COLOR_FG_MAX
COLOR_ADDR = cvar.COLOR_ADDR
COLOR_OPND1 = cvar.COLOR_OPND1
COLOR_OPND2 = cvar.COLOR_OPND2
COLOR_OPND3 = cvar.COLOR_OPND3
COLOR_OPND4 = cvar.COLOR_OPND4
COLOR_OPND5 = cvar.COLOR_OPND5
COLOR_OPND6 = cvar.COLOR_OPND6
COLOR_OPND7 = cvar.COLOR_OPND7
COLOR_OPND8 = cvar.COLOR_OPND8
COLOR_RESERVED1 = cvar.COLOR_RESERVED1


def add_sourcefile(*args):
  """
  add_sourcefile(ea1, ea2, filename) -> bool
  """
  return _ida_lines.add_sourcefile(*args)

def get_sourcefile(*args):
  """
  get_sourcefile(ea, bounds=None) -> char const *
  """
  return _ida_lines.get_sourcefile(*args)

def del_sourcefile(*args):
  """
  del_sourcefile(ea) -> bool
  """
  return _ida_lines.del_sourcefile(*args)
VEL_POST = _ida_lines.VEL_POST
VEL_CMT = _ida_lines.VEL_CMT

def add_extra_line(*args):
  """
  add_extra_line(ea, isprev, format) -> bool
  """
  return _ida_lines.add_extra_line(*args)

def add_extra_cmt(*args):
  """
  add_extra_cmt(ea, isprev, format) -> bool
  """
  return _ida_lines.add_extra_cmt(*args)

def add_pgm_cmt(*args):
  """
  add_pgm_cmt(format) -> bool
  """
  return _ida_lines.add_pgm_cmt(*args)

def generate_disasm_line(*args):
  """
  generate_disasm_line(ea, flags=0) -> bool
  """
  return _ida_lines.generate_disasm_line(*args)
GENDSM_FORCE_CODE = _ida_lines.GENDSM_FORCE_CODE
GENDSM_MULTI_LINE = _ida_lines.GENDSM_MULTI_LINE
GENDSM_REMOVE_TAGS = _ida_lines.GENDSM_REMOVE_TAGS

def get_first_free_extra_cmtidx(*args):
  """
  get_first_free_extra_cmtidx(ea, start) -> int
  """
  return _ida_lines.get_first_free_extra_cmtidx(*args)

def update_extra_cmt(*args):
  """
  update_extra_cmt(ea, what, str)
  """
  return _ida_lines.update_extra_cmt(*args)

def del_extra_cmt(*args):
  """
  del_extra_cmt(ea, what)
  """
  return _ida_lines.del_extra_cmt(*args)

def get_extra_cmt(*args):
  """
  get_extra_cmt(ea, what) -> ssize_t
  """
  return _ida_lines.get_extra_cmt(*args)

def delete_extra_cmts(*args):
  """
  delete_extra_cmts(ea, cmtidx)
  """
  return _ida_lines.delete_extra_cmts(*args)

def tag_remove(*args):
  """
  tag_remove(nonnul_instr) -> PyObject *


  Remove color escape sequences from a string
  @param colstr: the colored string with embedded tags
  @return: a new string w/o the tags
  """
  return _ida_lines.tag_remove(*args)

def set_user_defined_prefix(*args):
  """
  set_user_defined_prefix(width, pycb) -> PyObject *


  User-defined line-prefixes are displayed just after the autogenerated
  line prefixes. In order to use them, the plugin should call the
  following function to specify its width and contents.
  @param width: the width of the user-defined prefix
  @param callback: a get_user_defined_prefix callback to get the contents of the prefix.
      Its arguments:
        ea     - linear address
        lnnum  - line number
        indent - indent of the line contents (-1 means the default instruction)
                 indent and is used for instruction itself. see explanations for printf_line()
        line   - the line to be generated. the line usually contains color tags this argument
                 can be examined to decide whether to generated the prefix
      It returns a buffer of size < bufsize
  
  In order to remove the callback before unloading the plugin, specify the width = 0 or the callback = None
  """
  return _ida_lines.set_user_defined_prefix(*args)

def tag_addr(*args):
  """
  tag_addr(ea) -> PyObject *
  """
  return _ida_lines.tag_addr(*args)

def tag_skipcode(*args):
  """
  tag_skipcode(line) -> int
  """
  return _ida_lines.tag_skipcode(*args)

def tag_skipcodes(*args):
  """
  tag_skipcodes(line) -> int
  """
  return _ida_lines.tag_skipcodes(*args)

def tag_advance(*args):
  """
  tag_advance(line, cnt) -> int
  """
  return _ida_lines.tag_advance(*args)

def generate_disassembly(*args):
  """
  generate_disassembly(ea, max_lines, as_stack, notags) -> PyObject *


  Generate disassembly lines (many lines) and put them into a buffer
  
  @param ea: address to generate disassembly for
  @param max_lines: how many lines max to generate
  @param as_stack: Display undefined items as 2/4/8 bytes
  @return:
      - None on failure
      - tuple(most_important_line_number, tuple(lines)) : Returns a tuple containing
        the most important line number and a tuple of generated lines
  """
  return _ida_lines.generate_disassembly(*args)
#<pycode(py_lines)>
import _ida_idaapi

# ---------------- Color escape sequence defitions -------------------------
COLOR_ADDR_SIZE = 16 if _ida_idaapi.BADADDR == 0xFFFFFFFFFFFFFFFFL else 8
SCOLOR_FG_MAX   = '\x28'             #  Max color number
SCOLOR_OPND1    = chr(cvar.COLOR_ADDR+1)  #  Instruction operand 1
SCOLOR_OPND2    = chr(cvar.COLOR_ADDR+2)  #  Instruction operand 2
SCOLOR_OPND3    = chr(cvar.COLOR_ADDR+3)  #  Instruction operand 3
SCOLOR_OPND4    = chr(cvar.COLOR_ADDR+4)  #  Instruction operand 4
SCOLOR_OPND5    = chr(cvar.COLOR_ADDR+5)  #  Instruction operand 5
SCOLOR_OPND6    = chr(cvar.COLOR_ADDR+6)  #  Instruction operand 6
SCOLOR_UTF8     = chr(cvar.COLOR_ADDR+10) #  Following text is UTF-8 encoded

# ---------------- Line prefix colors --------------------------------------
PALETTE_SIZE   =  (cvar.COLOR_FG_MAX+_ida_lines.COLOR_BG_MAX)

def requires_color_esc(c):
    """
    Checks if the given character requires escaping
    @param c: character (string of one char)
    @return: Boolean
    """
    t = ord(c[0])
    return c >= COLOR_ON and c <= COLOR_INV

def COLSTR(str, tag):
    """
    Utility function to create a colored line
    @param str: The string
    @param tag: Color tag constant. One of SCOLOR_XXXX
    """
    return SCOLOR_ON + tag + str + SCOLOR_OFF + tag

#</pycode(py_lines)>

if _BC695:
    COLOR_UTF8=COLOR_ADDR+10 # old value of COLOR_UTF8; shouldn't trigger anything
    add_long_cmt=add_extra_cmt
    describe=add_extra_line



E_PREV = cvar.E_PREV
E_NEXT = cvar.E_NEXT

