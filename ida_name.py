# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
IDA Plugin SDK API wrapper: name
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ida_name', [dirname(__file__)])
        except ImportError:
            import _ida_name
            return _ida_name
        if fp is not None:
            try:
                _mod = imp.load_module('_ida_name', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ida_name = swig_import_helper()
    del swig_import_helper
else:
    import _ida_name
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import ida_idaapi

import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        func.func_dict["bc695redef"] = True
        return func


def get_name(*args):
  """
  get_name(ea) -> qstring
  """
  return _ida_name.get_name(*args)

def get_colored_name(*args):
  """
  get_colored_name(ea) -> qstring
  """
  return _ida_name.get_colored_name(*args)
MAXNAMELEN = _ida_name.MAXNAMELEN
FUNC_IMPORT_PREFIX = _ida_name.FUNC_IMPORT_PREFIX

def set_name(*args):
  """
  set_name(ea, name, flags=0) -> bool
  """
  return _ida_name.set_name(*args)
SN_CHECK = _ida_name.SN_CHECK
SN_NOCHECK = _ida_name.SN_NOCHECK
SN_PUBLIC = _ida_name.SN_PUBLIC
SN_NON_PUBLIC = _ida_name.SN_NON_PUBLIC
SN_WEAK = _ida_name.SN_WEAK
SN_NON_WEAK = _ida_name.SN_NON_WEAK
SN_AUTO = _ida_name.SN_AUTO
SN_NON_AUTO = _ida_name.SN_NON_AUTO
SN_NOLIST = _ida_name.SN_NOLIST
SN_NOWARN = _ida_name.SN_NOWARN
SN_LOCAL = _ida_name.SN_LOCAL
SN_IDBENC = _ida_name.SN_IDBENC
SN_FORCE = _ida_name.SN_FORCE

def force_name(*args):
  """
  force_name(ea, name, flags=0) -> bool
  """
  return _ida_name.force_name(*args)

def del_global_name(*args):
  """
  del_global_name(ea) -> bool
  """
  return _ida_name.del_global_name(*args)

def del_local_name(*args):
  """
  del_local_name(ea) -> bool
  """
  return _ida_name.del_local_name(*args)

def set_dummy_name(*args):
  """
  set_dummy_name(_from, ea) -> bool
  """
  return _ida_name.set_dummy_name(*args)

def make_name_auto(*args):
  """
  make_name_auto(ea) -> bool
  """
  return _ida_name.make_name_auto(*args)

def make_name_user(*args):
  """
  make_name_user(ea) -> bool
  """
  return _ida_name.make_name_user(*args)
URK_NameChars = _ida_name.URK_NameChars
URK_MangleChars = _ida_name.URK_MangleChars
URK_StrlitChars = _ida_name.URK_StrlitChars
URK_TypeNameChars = _ida_name.URK_TypeNameChars
VNT_IDENT = _ida_name.VNT_IDENT
VNT_TYPE = _ida_name.VNT_TYPE
VNT_UDTMEM = _ida_name.VNT_UDTMEM
VNT_STRLIT = _ida_name.VNT_STRLIT
VNT_VISIBLE = _ida_name.VNT_VISIBLE

def is_valid_cp(*args):
  """
  is_valid_cp(cp, kind, data=None) -> bool
  """
  return _ida_name.is_valid_cp(*args)

def set_cp_validity(*args):
  """
  set_cp_validity(kind, cp, endcp=wchar32_t(-1), valid=True)
  """
  return _ida_name.set_cp_validity(*args)

def is_ident_cp(*args):
  """
  is_ident_cp(cp) -> bool
  """
  return _ida_name.is_ident_cp(*args)

def is_strlit_cp(*args):
  """
  is_strlit_cp(cp, specific_ranges=None) -> bool
  """
  return _ida_name.is_strlit_cp(*args)

def is_visible_cp(*args):
  """
  is_visible_cp(cp) -> bool
  """
  return _ida_name.is_visible_cp(*args)

def is_ident(*args):
  """
  is_ident(name) -> bool
  """
  return _ida_name.is_ident(*args)

def is_uname(*args):
  """
  is_uname(name) -> bool
  """
  return _ida_name.is_uname(*args)

def is_valid_typename(*args):
  """
  is_valid_typename(name) -> bool
  """
  return _ida_name.is_valid_typename(*args)

def extract_name(*args):
  """
  extract_name(line, x) -> ssize_t
  """
  return _ida_name.extract_name(*args)

def hide_name(*args):
  """
  hide_name(ea)
  """
  return _ida_name.hide_name(*args)

def show_name(*args):
  """
  show_name(ea)
  """
  return _ida_name.show_name(*args)

def get_name_ea(*args):
  """
  get_name_ea(_from, name) -> ea_t
  """
  return _ida_name.get_name_ea(*args)

def get_name_base_ea(*args):
  """
  get_name_base_ea(_from, to) -> ea_t
  """
  return _ida_name.get_name_base_ea(*args)

def get_name_value(*args):
  """
  get_name_value(_from, name) -> int
  """
  return _ida_name.get_name_value(*args)
NT_NONE = _ida_name.NT_NONE
NT_BYTE = _ida_name.NT_BYTE
NT_LOCAL = _ida_name.NT_LOCAL
NT_STKVAR = _ida_name.NT_STKVAR
NT_ENUM = _ida_name.NT_ENUM
NT_ABS = _ida_name.NT_ABS
NT_SEG = _ida_name.NT_SEG
NT_STROFF = _ida_name.NT_STROFF
NT_BMASK = _ida_name.NT_BMASK
NT_REGVAR = _ida_name.NT_REGVAR
GN_VISIBLE = _ida_name.GN_VISIBLE
GN_COLORED = _ida_name.GN_COLORED
GN_DEMANGLED = _ida_name.GN_DEMANGLED
GN_STRICT = _ida_name.GN_STRICT
GN_SHORT = _ida_name.GN_SHORT
GN_LONG = _ida_name.GN_LONG
GN_LOCAL = _ida_name.GN_LOCAL
GN_ISRET = _ida_name.GN_ISRET
GN_NOT_ISRET = _ida_name.GN_NOT_ISRET

def get_visible_name(*args):
  """
  get_visible_name(ea, gtn_flags=0) -> qstring
  """
  return _ida_name.get_visible_name(*args)

def get_short_name(*args):
  """
  get_short_name(ea, gtn_flags=0) -> qstring
  """
  return _ida_name.get_short_name(*args)

def get_long_name(*args):
  """
  get_long_name(ea, gtn_flags=0) -> qstring
  """
  return _ida_name.get_long_name(*args)

def get_colored_short_name(*args):
  """
  get_colored_short_name(ea, gtn_flags=0) -> qstring
  """
  return _ida_name.get_colored_short_name(*args)

def get_colored_long_name(*args):
  """
  get_colored_long_name(ea, gtn_flags=0) -> qstring
  """
  return _ida_name.get_colored_long_name(*args)

def get_demangled_name(*args):
  """
  get_demangled_name(ea, inhibitor, demform, gtn_flags=0) -> qstring
  """
  return _ida_name.get_demangled_name(*args)

def get_colored_demangled_name(*args):
  """
  get_colored_demangled_name(ea, inhibitor, demform, gtn_flags=0) -> qstring
  """
  return _ida_name.get_colored_demangled_name(*args)

def get_name_color(*args):
  """
  get_name_color(_from, ea) -> color_t
  """
  return _ida_name.get_name_color(*args)
GETN_APPZERO = _ida_name.GETN_APPZERO
GETN_NOFIXUP = _ida_name.GETN_NOFIXUP
GETN_NODUMMY = _ida_name.GETN_NODUMMY

def get_name_expr(*args):
  """
  get_name_expr(_from, n, ea, off, flags=0x0001) -> ssize_t
  """
  return _ida_name.get_name_expr(*args)

def get_nice_colored_name(*args):
  """
  get_nice_colored_name(ea, flags=0) -> ssize_t
  """
  return _ida_name.get_nice_colored_name(*args)
GNCN_NOSEG = _ida_name.GNCN_NOSEG
GNCN_NOCOLOR = _ida_name.GNCN_NOCOLOR
GNCN_NOLABEL = _ida_name.GNCN_NOLABEL
GNCN_NOFUNC = _ida_name.GNCN_NOFUNC
GNCN_SEG_FUNC = _ida_name.GNCN_SEG_FUNC
GNCN_SEGNUM = _ida_name.GNCN_SEGNUM
GNCN_REQFUNC = _ida_name.GNCN_REQFUNC
GNCN_REQNAME = _ida_name.GNCN_REQNAME
GNCN_NODBGNM = _ida_name.GNCN_NODBGNM
GNCN_PREFDBG = _ida_name.GNCN_PREFDBG

def append_struct_fields(*args):
  """
  append_struct_fields(disp, n, path, flags, delta, appzero) -> flags_t
  """
  return _ida_name.append_struct_fields(*args)

def is_public_name(*args):
  """
  is_public_name(ea) -> bool
  """
  return _ida_name.is_public_name(*args)

def make_name_public(*args):
  """
  make_name_public(ea)
  """
  return _ida_name.make_name_public(*args)

def make_name_non_public(*args):
  """
  make_name_non_public(ea)
  """
  return _ida_name.make_name_non_public(*args)

def is_weak_name(*args):
  """
  is_weak_name(ea) -> bool
  """
  return _ida_name.is_weak_name(*args)

def make_name_weak(*args):
  """
  make_name_weak(ea)
  """
  return _ida_name.make_name_weak(*args)

def make_name_non_weak(*args):
  """
  make_name_non_weak(ea)
  """
  return _ida_name.make_name_non_weak(*args)

def get_nlist_size(*args):
  """
  get_nlist_size() -> size_t
  """
  return _ida_name.get_nlist_size(*args)

def get_nlist_idx(*args):
  """
  get_nlist_idx(ea) -> size_t
  """
  return _ida_name.get_nlist_idx(*args)

def is_in_nlist(*args):
  """
  is_in_nlist(ea) -> bool
  """
  return _ida_name.is_in_nlist(*args)

def get_nlist_ea(*args):
  """
  get_nlist_ea(idx) -> ea_t
  """
  return _ida_name.get_nlist_ea(*args)

def get_nlist_name(*args):
  """
  get_nlist_name(idx) -> char const *
  """
  return _ida_name.get_nlist_name(*args)

def rebuild_nlist(*args):
  """
  rebuild_nlist()
  """
  return _ida_name.rebuild_nlist(*args)

def reorder_dummy_names(*args):
  """
  reorder_dummy_names()
  """
  return _ida_name.reorder_dummy_names(*args)
DEBNAME_EXACT = _ida_name.DEBNAME_EXACT
DEBNAME_LOWER = _ida_name.DEBNAME_LOWER
DEBNAME_UPPER = _ida_name.DEBNAME_UPPER
DEBNAME_NICE = _ida_name.DEBNAME_NICE
class ea_name_t(object):
    """
    Proxy of C++ ea_name_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ea = _swig_property(_ida_name.ea_name_t_ea_get, _ida_name.ea_name_t_ea_set)
    name = _swig_property(_ida_name.ea_name_t_name_get, _ida_name.ea_name_t_name_set)
    def __init__(self, *args):
        """
        __init__(self) -> ea_name_t
        __init__(self, _ea, _name) -> ea_name_t
        """
        this = _ida_name.new_ea_name_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_name.delete_ea_name_t
    __del__ = lambda self : None;
ea_name_t_swigregister = _ida_name.ea_name_t_swigregister
ea_name_t_swigregister(ea_name_t)


def set_debug_name(*args):
  """
  set_debug_name(ea, name) -> bool
  """
  return _ida_name.set_debug_name(*args)

def get_debug_name(*args):
  """
  get_debug_name(ea_ptr, how) -> ssize_t
  """
  return _ida_name.get_debug_name(*args)

def del_debug_names(*args):
  """
  del_debug_names(ea1, ea2)
  """
  return _ida_name.del_debug_names(*args)

def get_debug_name_ea(*args):
  """
  get_debug_name_ea(name) -> ea_t
  """
  return _ida_name.get_debug_name_ea(*args)
DQT_NPURGED_8 = _ida_name.DQT_NPURGED_8
DQT_NPURGED_4 = _ida_name.DQT_NPURGED_4
DQT_NPURGED_2 = _ida_name.DQT_NPURGED_2
DQT_COMPILER = _ida_name.DQT_COMPILER
DQT_NAME_TYPE = _ida_name.DQT_NAME_TYPE
DQT_FULL = _ida_name.DQT_FULL

def demangle_name(*args):
  """
  demangle_name(name, disable_mask, demreq=DQT_FULL) -> int32
  """
  return _ida_name.demangle_name(*args)

def is_name_defined_locally(*args):
  """
  is_name_defined_locally(pfn, name, ignore_name_def, ea1=BADADDR, ea2=BADADDR) -> bool
  """
  return _ida_name.is_name_defined_locally(*args)

def cleanup_name(*args):
  """
  cleanup_name(ea, name, flags=0) -> bool
  """
  return _ida_name.cleanup_name(*args)
CN_KEEP_TRAILING__DIGITS = _ida_name.CN_KEEP_TRAILING__DIGITS

def get_debug_names(*args):
  """
  get_debug_names(ea1, ea2) -> PyObject *
  """
  return _ida_name.get_debug_names(*args)

def get_ea_name(*args):
  """
  get_ea_name(ea, gtn_flags=0) -> qstring
  """
  return _ida_name.get_ea_name(*args)

def validate_name(*args):
  """
  validate_name(name, type, flags=0) -> PyObject *
  """
  return _ida_name.validate_name(*args)
#<pycode(py_name)>
import _ida_idaapi
import _ida_funcs
import bisect


class NearestName(object):
    """
    Utility class to help find the nearest name in a given ea/name dictionary
    """
    def __init__(self, ea_names):
        self.update(ea_names)


    def update(self, ea_names):
        """
        Updates the ea/names map
        """
        self._names = ea_names
        self._addrs = ea_names.keys()
        self._addrs.sort()


    def find(self, ea):
        """
        Returns a tupple (ea, name, pos) that is the nearest to the passed ea
        If no name is matched then None is returned
        """
        pos = bisect.bisect_left(self._addrs, ea)
        # no match
        if pos >= len(self._addrs):
            return None
        # exact match?
        if self._addrs[pos] != ea:
            pos -= 1 # go to previous element
        if pos < 0:
            return None
        return self[pos]


    def _get_item(self, index):
        ea = self._addrs[index]
        return (ea, self._names[ea], index)


    def __iter__(self):
        return (self._get_item(index) for index in xrange(0, len(self._addrs)))


    def __getitem__(self, index):
        """
        Returns the tupple (ea, name, index)
        """
        if index > len(self._addrs):
            raise StopIteration
        return self._get_item(index)

def calc_gtn_flags(fromaddr, ea):
    """
    Calculate flags for get_ea_name() function

    @param fromaddr: the referring address. May be BADADDR.
    @param ea: linear address

    @return: flags
    """
    gtn_flags = 0
    if fromaddr != _ida_idaapi.BADADDR:
        pfn = _ida_funcs.get_func(fromaddr)
        if _ida_funcs.func_contains(pfn, ea):
            gtn_flags = GN_LOCAL
    return gtn_flags

#</pycode(py_name)>

if _BC695:
    GN_INSNLOC=0
    @bc695redef
    def demangle_name(name, mask, demreq=DQT_FULL): # make flag optional, so demangle_name & demangle_name2 can use it
        return _ida_name.demangle_name(name, mask, demreq)
    demangle_name2=demangle_name
    @bc695redef
    def do_name_anyway(ea, name, maxlen=0):
        return force_name(ea, name)
    extract_name2=extract_name
    get_debug_name2=get_debug_name
    @bc695redef
    def get_true_name(ea0, ea1=None):
        if ea1 is None:
            ea = ea0
        else:
            ea = ea1
        return get_name(ea)
    is_ident_char=is_ident_cp
    is_visible_char=is_visible_cp
    @bc695redef
    def make_visible_name(name, sz=0):
        if sz > 0:
            name = name[0:sz]
        return _ida_name.validate_name(name, VNT_VISIBLE)
    @bc695redef
    def validate_name2(name, sz=0):
        if sz > 0:
            name = name[0:sz]
        return _ida_name.validate_name(name, VNT_IDENT)
    @bc695redef
    def validate_name3(name):
        return _ida_name.validate_name(name, VNT_IDENT)
    isident=is_ident



cvar = _ida_name.cvar
ignore_none = cvar.ignore_none
ignore_regvar = cvar.ignore_regvar
ignore_llabel = cvar.ignore_llabel
ignore_stkvar = cvar.ignore_stkvar
ignore_glabel = cvar.ignore_glabel

