# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
IDA Plugin SDK API wrapper: kernwin
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ida_kernwin', [dirname(__file__)])
        except ImportError:
            import _ida_kernwin
            return _ida_kernwin
        if fp is not None:
            try:
                _mod = imp.load_module('_ida_kernwin', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ida_kernwin = swig_import_helper()
    del swig_import_helper
else:
    import _ida_kernwin
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import ida_idaapi

import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        func.func_dict["bc695redef"] = True
        return func


def refresh_choosers(*args):
  """
  refresh_choosers()
  """
  return _ida_kernwin.refresh_choosers(*args)

def textctrl_info_t_create(*args):
  """
  textctrl_info_t_create() -> PyObject *
  """
  return _ida_kernwin.textctrl_info_t_create(*args)

def textctrl_info_t_destroy(*args):
  """
  textctrl_info_t_destroy(py_obj) -> bool
  """
  return _ida_kernwin.textctrl_info_t_destroy(*args)

def textctrl_info_t_get_clink(*args):
  """
  textctrl_info_t_get_clink(self) -> textctrl_info_t *
  """
  return _ida_kernwin.textctrl_info_t_get_clink(*args)

def textctrl_info_t_get_clink_ptr(*args):
  """
  textctrl_info_t_get_clink_ptr(self) -> PyObject *
  """
  return _ida_kernwin.textctrl_info_t_get_clink_ptr(*args)

def register_timer(*args):
  """
  register_timer(interval, py_callback) -> PyObject *


  Register a timer
  
  @param interval: Interval in milliseconds
  @param callback: A Python callable that takes no parameters and returns an integer.
                   The callback may return:
                   -1   : to unregister the timer
                   >= 0 : the new or same timer interval
  @return: None or a timer object
  """
  return _ida_kernwin.register_timer(*args)

def unregister_timer(*args):
  """
  unregister_timer(py_timerctx) -> PyObject *


  Unregister a timer
  
  @param timer_obj: a timer object previously returned by a register_timer()
  @return: Boolean
  @note: After the timer has been deleted, the timer_obj will become invalid.
  """
  return _ida_kernwin.unregister_timer(*args)

def choose_idasgn(*args):
  """
  choose_idasgn() -> PyObject *


  Opens the signature chooser
  
  @return: None or the selected signature name
  """
  return _ida_kernwin.choose_idasgn(*args)

def get_highlight(*args):
  """
  get_highlight(v) -> PyObject *


  Returns the currently highlighted identifier and flags
  
  @return: a tuple (text, flags), or None if nothing
           is highlighted or in case of error.
  """
  return _ida_kernwin.get_highlight(*args)

def py_load_custom_icon_fn(*args):
  """
  py_load_custom_icon_fn(filename) -> int
  """
  return _ida_kernwin.py_load_custom_icon_fn(*args)

def py_load_custom_icon_data(*args):
  """
  py_load_custom_icon_data(data, format) -> int
  """
  return _ida_kernwin.py_load_custom_icon_data(*args)

def msg(*args):
  """
  msg(o) -> PyObject *


  Prints text into IDA's Output window
  
  @param text: text to print
               Can be Unicode, or string in local encoding
  @return: number of bytes printed
  """
  return _ida_kernwin.msg(*args)

def ask_text(*args):
  """
  ask_text(max_size, defval, prompt) -> PyObject *


  Asks for a long text
  
  @param max_size: Maximum text length, 0 for unlimited
  @param defval: The default value
  @param prompt: The prompt value
  @return: None or the entered string
  """
  return _ida_kernwin.ask_text(*args)

def ask_str(*args):
  """
  ask_str(defval, hist, prompt) -> PyObject *


  Asks for a long text
  
  @param hist:   history id
  @param defval: The default value
  @param prompt: The prompt value
  @return: None or the entered string
  """
  return _ida_kernwin.ask_str(*args)

def str2ea(*args):
  """
  str2ea(str, screenEA=BADADDR) -> ea_t


  Converts a string express to EA. The expression evaluator may be called as well.
  
  @return: BADADDR or address value
  """
  return _ida_kernwin.str2ea(*args)

def process_ui_action(*args):
  """
  process_ui_action(name, flags=0) -> bool


  Invokes an IDA UI action by name
  
  @param name:  action name
  @return: Boolean
  """
  return _ida_kernwin.process_ui_action(*args)

def del_hotkey(*args):
  """
  del_hotkey(pyctx) -> bool


  Deletes a previously registered function hotkey
  
  @param ctx: Hotkey context previously returned by add_hotkey()
  
  @return: Boolean.
  """
  return _ida_kernwin.del_hotkey(*args)

def add_hotkey(*args):
  """
  add_hotkey(hotkey, pyfunc) -> PyObject *


  Associates a function call with a hotkey.
  Callable pyfunc will be called each time the hotkey is pressed
  
  @param hotkey: The hotkey
  @param pyfunc: Callable
  
  @return: Context object on success or None on failure.
  """
  return _ida_kernwin.add_hotkey(*args)

def take_database_snapshot(*args):
  """
  take_database_snapshot(ss) -> PyObject *
  """
  return _ida_kernwin.take_database_snapshot(*args)

def py_ss_restore_callback(*args):
  """
  py_ss_restore_callback(err_msg, userdata)
  """
  return _ida_kernwin.py_ss_restore_callback(*args)

def restore_database_snapshot(*args):
  """
  restore_database_snapshot(ss, pyfunc_or_none, pytuple_or_none) -> PyObject *
  """
  return _ida_kernwin.restore_database_snapshot(*args)

def execute_sync(*args):
  """
  execute_sync(py_callable, reqf) -> int


  Executes a function in the context of the main thread.
  If the current thread not the main thread, then the call is queued and
  executed afterwards.
  
  @param callable: A python callable object, must return an integer value
  @param reqf: one of MFF_ flags
  @return: -1 or the return value of the callable
  """
  return _ida_kernwin.execute_sync(*args)

def execute_ui_requests(*args):
  """
  execute_ui_requests(py_list) -> bool


  Inserts a list of callables into the UI message processing queue.
  When the UI is ready it will call one callable.
  A callable can request to be called more than once if it returns True.
  
  @param callable_list: A list of python callable objects.
  @note: A callable should return True if it wants to be called more than once.
  @return: Boolean. False if the list contains a non callabale item
  """
  return _ida_kernwin.execute_ui_requests(*args)
class UI_Hooks(object):
    """
    Proxy of C++ UI_Hooks class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _ida_kernwin.delete_UI_Hooks
    __del__ = lambda self : None;
    def hook(self, *args):
        """
        hook(self) -> bool


        Creates an UI hook
        
        @return: Boolean true on success
        """
        return _ida_kernwin.UI_Hooks_hook(self, *args)

    def unhook(self, *args):
        """
        unhook(self) -> bool


        Removes the UI hook
        @return: Boolean true on success
        """
        return _ida_kernwin.UI_Hooks_unhook(self, *args)

    def range(self, *args):
        """
        range(self)
        """
        return _ida_kernwin.UI_Hooks_range(self, *args)

    def idcstart(self, *args):
        """
        idcstart(self)
        """
        return _ida_kernwin.UI_Hooks_idcstart(self, *args)

    def idcstop(self, *args):
        """
        idcstop(self)
        """
        return _ida_kernwin.UI_Hooks_idcstop(self, *args)

    def suspend(self, *args):
        """
        suspend(self)
        """
        return _ida_kernwin.UI_Hooks_suspend(self, *args)

    def resume(self, *args):
        """
        resume(self)
        """
        return _ida_kernwin.UI_Hooks_resume(self, *args)

    def saving(self, *args):
        """
        saving(self)


        The kernel is saving the database.
        
        @return: Ignored
        """
        return _ida_kernwin.UI_Hooks_saving(self, *args)

    def saved(self, *args):
        """
        saved(self)


        The kernel has saved the database.
        
        @return: Ignored
        """
        return _ida_kernwin.UI_Hooks_saved(self, *args)

    def term(self, *args):
        """
        term(self)


        IDA is terminated and the database is already closed.
        The UI may close its windows in this callback.
        """
        return _ida_kernwin.UI_Hooks_term(self, *args)

    def debugger_menu_change(self, *args):
        """
        debugger_menu_change(self, enable) -> int
        """
        return _ida_kernwin.UI_Hooks_debugger_menu_change(self, *args)

    def widget_visible(self, *args):
        """
        widget_visible(self, widget)
        """
        return _ida_kernwin.UI_Hooks_widget_visible(self, *args)

    def widget_closing(self, *args):
        """
        widget_closing(self, widget)
        """
        return _ida_kernwin.UI_Hooks_widget_closing(self, *args)

    def widget_invisible(self, *args):
        """
        widget_invisible(self, widget)
        """
        return _ida_kernwin.UI_Hooks_widget_invisible(self, *args)

    def get_ea_hint(self, *args):
        """
        get_ea_hint(self, ea) -> PyObject *


        The UI wants to display a simple hint for an address in the navigation band
        
        @param ea: The address
        @return: String with the hint or None
        """
        return _ida_kernwin.UI_Hooks_get_ea_hint(self, *args)

    def get_item_hint(self, *args):
        """
        get_item_hint(self, ea, max_lines) -> PyObject *
        """
        return _ida_kernwin.UI_Hooks_get_item_hint(self, *args)

    def get_custom_viewer_hint(self, *args):
        """
        get_custom_viewer_hint(self, viewer, place) -> PyObject *
        """
        return _ida_kernwin.UI_Hooks_get_custom_viewer_hint(self, *args)

    def database_inited(self, *args):
        """
        database_inited(self, is_new_database, idc_script)
        """
        return _ida_kernwin.UI_Hooks_database_inited(self, *args)

    def ready_to_run(self, *args):
        """
        ready_to_run(self)
        """
        return _ida_kernwin.UI_Hooks_ready_to_run(self, *args)

    def preprocess_action(self, *args):
        """
        preprocess_action(self, name)


        IDA ui is about to handle a user action
        
        @param name: ui action name
                     (these names can be looked up in ida[tg]ui.cfg)
        @return: 0-ok, nonzero - a plugin has handled the action
        """
        return _ida_kernwin.UI_Hooks_preprocess_action(self, *args)

    def postprocess_action(self, *args):
        """
        postprocess_action(self)


        An ida ui action has been handled
        
        @return: Ignored
        """
        return _ida_kernwin.UI_Hooks_postprocess_action(self, *args)

    def updating_actions(self, *args):
        """
        updating_actions(self, ctx)


        The UI is about to batch-update some actions.
        
        @param ctx: The action_update_ctx_t instance
        @return: Ignored
        """
        return _ida_kernwin.UI_Hooks_updating_actions(self, *args)

    def updated_actions(self, *args):
        """
        updated_actions(self)


        The UI is done updating actions.
        
        @return: Ignored
        """
        return _ida_kernwin.UI_Hooks_updated_actions(self, *args)

    def populating_widget_popup(self, *args):
        """
        populating_widget_popup(self, widget, popup_handle)


        The UI is populating the TWidget's popup menu.
        Now is a good time to call idaapi.attach_action_to_popup()
        
        @param widget: The widget
        @param popup: The popup menu.
        @return: Ignored
        """
        return _ida_kernwin.UI_Hooks_populating_widget_popup(self, *args)

    def finish_populating_widget_popup(self, *args):
        """
        finish_populating_widget_popup(self, widget, popup_handle)


        The UI is about to be done populating the TWidget's popup menu.
        Now is a good time to call idaapi.attach_action_to_popup()
        
        @param widget: The widget
        @param popup: The popup menu.
        @return: Ignored
        """
        return _ida_kernwin.UI_Hooks_finish_populating_widget_popup(self, *args)

    def plugin_loaded(self, *args):
        """
        plugin_loaded(self, plugin_info)
        """
        return _ida_kernwin.UI_Hooks_plugin_loaded(self, *args)

    def plugin_unloading(self, *args):
        """
        plugin_unloading(self, plugin_info)
        """
        return _ida_kernwin.UI_Hooks_plugin_unloading(self, *args)

    def current_widget_changed(self, *args):
        """
        current_widget_changed(self, widget, prev_widget)
        """
        return _ida_kernwin.UI_Hooks_current_widget_changed(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> UI_Hooks
        """
        if self.__class__ == UI_Hooks:
            _self = None
        else:
            _self = self
        this = _ida_kernwin.new_UI_Hooks(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    def __disown__(self):
        self.this.disown()
        _ida_kernwin.disown_UI_Hooks(self)
        return weakref_proxy(self)
UI_Hooks_swigregister = _ida_kernwin.UI_Hooks_swigregister
UI_Hooks_swigregister(UI_Hooks)


def register_action(*args):
  """
  register_action(desc) -> bool
  """
  return _ida_kernwin.register_action(*args)

def get_registered_actions(*args):
  """
  get_registered_actions() -> PyObject *
  """
  return _ida_kernwin.get_registered_actions(*args)

def attach_dynamic_action_to_popup(*args):
  """
  attach_dynamic_action_to_popup(widget, popup_handle, desc, popuppath=None, flags=0) -> bool
  """
  return _ida_kernwin.attach_dynamic_action_to_popup(*args)
class disasm_line_t(object):
    """
    Proxy of C++ disasm_line_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _ida_kernwin.delete_disasm_line_t
    __del__ = lambda self : None;
    def __init__(self, *args):
        """
        __init__(self) -> disasm_line_t
        __init__(self, other) -> disasm_line_t
        """
        this = _ida_kernwin.new_disasm_line_t(*args)
        try: self.this.append(this)
        except: self.this = this
    at = _swig_property(_ida_kernwin.disasm_line_t_at_get, _ida_kernwin.disasm_line_t_at_set)
    line = _swig_property(_ida_kernwin.disasm_line_t_line_get, _ida_kernwin.disasm_line_t_line_set)
    prefix_color = _swig_property(_ida_kernwin.disasm_line_t_prefix_color_get, _ida_kernwin.disasm_line_t_prefix_color_set)
    bg_color = _swig_property(_ida_kernwin.disasm_line_t_bg_color_get, _ida_kernwin.disasm_line_t_bg_color_set)
    is_default = _swig_property(_ida_kernwin.disasm_line_t_is_default_get, _ida_kernwin.disasm_line_t_is_default_set)
disasm_line_t_swigregister = _ida_kernwin.disasm_line_t_swigregister
disasm_line_t_swigregister(disasm_line_t)


def gen_disasm_text(*args):
  """
  gen_disasm_text(text, ea1, ea2, truncate_lines)
  """
  return _ida_kernwin.gen_disasm_text(*args)

def set_nav_colorizer(*args):
  """
  set_nav_colorizer(new_py_colorizer) -> nav_colorizer_t *


  Set a new colorizer for the navigation band.
  
  The 'callback' is a function of 2 arguments:
     - ea (the EA to colorize for)
     - nbytes (the number of bytes at that EA)
  and must return a 'long' value.
  
  The previous colorizer is returned, allowing
  the new 'callback' to use 'call_nav_colorizer'
  with it.
  
  Note that the previous colorizer is returned
  only the first time set_nav_colorizer() is called:
  due to the way the colorizers API is defined in C,
  it is impossible to chain more than 2 colorizers
  in IDAPython: the original, IDA-provided colorizer,
  and a user-provided one.
  
  Example: colorizer inverting the color provided by the IDA colorizer:
      def my_colorizer(ea, nbytes):
          global ida_colorizer
          orig = idaapi.call_nav_colorizer(ida_colorizer, ea, nbytes)
          return long(~orig)
  
      ida_colorizer = idaapi.set_nav_colorizer(my_colorizer)
  """
  return _ida_kernwin.set_nav_colorizer(*args)

def call_nav_colorizer(*args):
  """
  call_nav_colorizer(col, ea, nbytes) -> uint32


  To be used with the IDA-provided colorizer, that is
  returned as result of the first call to set_nav_colorizer().
  
  This is a trivial trampoline, so that SWIG can generate a
  wrapper that will do the types checking.
  """
  return _ida_kernwin.call_nav_colorizer(*args)
mbox_internal = _ida_kernwin.mbox_internal
mbox_info = _ida_kernwin.mbox_info
mbox_warning = _ida_kernwin.mbox_warning
mbox_error = _ida_kernwin.mbox_error
mbox_nomem = _ida_kernwin.mbox_nomem
mbox_feedback = _ida_kernwin.mbox_feedback
mbox_readerror = _ida_kernwin.mbox_readerror
mbox_writeerror = _ida_kernwin.mbox_writeerror
mbox_filestruct = _ida_kernwin.mbox_filestruct
mbox_wait = _ida_kernwin.mbox_wait
mbox_hide = _ida_kernwin.mbox_hide
mbox_replace = _ida_kernwin.mbox_replace
chtype_generic = _ida_kernwin.chtype_generic
chtype_idasgn = _ida_kernwin.chtype_idasgn
chtype_entry = _ida_kernwin.chtype_entry
chtype_name = _ida_kernwin.chtype_name
chtype_stkvar_xref = _ida_kernwin.chtype_stkvar_xref
chtype_xref = _ida_kernwin.chtype_xref
chtype_enum = _ida_kernwin.chtype_enum
chtype_enum_by_value = _ida_kernwin.chtype_enum_by_value
chtype_func = _ida_kernwin.chtype_func
chtype_segm = _ida_kernwin.chtype_segm
chtype_struc = _ida_kernwin.chtype_struc
chtype_strpath = _ida_kernwin.chtype_strpath
chtype_idatil = _ida_kernwin.chtype_idatil
chtype_enum_by_value_and_size = _ida_kernwin.chtype_enum_by_value_and_size
chtype_srcp = _ida_kernwin.chtype_srcp
beep_default = _ida_kernwin.beep_default
TCCRT_INVALID = _ida_kernwin.TCCRT_INVALID
TCCRT_FLAT = _ida_kernwin.TCCRT_FLAT
TCCRT_GRAPH = _ida_kernwin.TCCRT_GRAPH
TCCRT_PROXIMITY = _ida_kernwin.TCCRT_PROXIMITY
TCCPT_INVALID = _ida_kernwin.TCCPT_INVALID
TCCPT_PLACE = _ida_kernwin.TCCPT_PLACE
TCCPT_SIMPLELINE_PLACE = _ida_kernwin.TCCPT_SIMPLELINE_PLACE
TCCPT_IDAPLACE = _ida_kernwin.TCCPT_IDAPLACE
TCCPT_ENUMPLACE = _ida_kernwin.TCCPT_ENUMPLACE
TCCPT_STRUCTPLACE = _ida_kernwin.TCCPT_STRUCTPLACE
VME_UNKNOWN = _ida_kernwin.VME_UNKNOWN
VME_LEFT_BUTTON = _ida_kernwin.VME_LEFT_BUTTON
VME_RIGHT_BUTTON = _ida_kernwin.VME_RIGHT_BUTTON
VME_MID_BUTTON = _ida_kernwin.VME_MID_BUTTON
SETMENU_POSMASK = _ida_kernwin.SETMENU_POSMASK
SETMENU_INS = _ida_kernwin.SETMENU_INS
SETMENU_APP = _ida_kernwin.SETMENU_APP
SETMENU_FIRST = _ida_kernwin.SETMENU_FIRST
CREATETB_ADV = _ida_kernwin.CREATETB_ADV
HIF_IDENTIFIER = _ida_kernwin.HIF_IDENTIFIER
HIF_REGISTER = _ida_kernwin.HIF_REGISTER
HIF_LOCKED = _ida_kernwin.HIF_LOCKED

def get_kernel_version(*args):
  """
  get_kernel_version() -> ssize_t
  """
  return _ida_kernwin.get_kernel_version(*args)
class place_t(object):
    """
    Proxy of C++ place_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    lnnum = _swig_property(_ida_kernwin.place_t_lnnum_get, _ida_kernwin.place_t_lnnum_set)
    def _print(self, *args):
        """
        _print(self, out_buf, ud)
        """
        return _ida_kernwin.place_t__print(self, *args)

    def touval(self, *args):
        """
        touval(self, ud) -> uval_t
        """
        return _ida_kernwin.place_t_touval(self, *args)

    def clone(self, *args):
        """
        clone(self) -> place_t
        """
        return _ida_kernwin.place_t_clone(self, *args)

    def copyfrom(self, *args):
        """
        copyfrom(self, _from)
        """
        return _ida_kernwin.place_t_copyfrom(self, *args)

    def makeplace(self, *args):
        """
        makeplace(self, ud, x, lnnum) -> place_t
        """
        return _ida_kernwin.place_t_makeplace(self, *args)

    def compare(self, *args):
        """
        compare(self, t2) -> int
        """
        return _ida_kernwin.place_t_compare(self, *args)

    def adjust(self, *args):
        """
        adjust(self, ud)
        """
        return _ida_kernwin.place_t_adjust(self, *args)

    def prev(self, *args):
        """
        prev(self, ud) -> bool
        """
        return _ida_kernwin.place_t_prev(self, *args)

    def next(self, *args):
        """
        next(self, ud) -> bool
        """
        return _ida_kernwin.place_t_next(self, *args)

    def beginning(self, *args):
        """
        beginning(self, ud) -> bool
        """
        return _ida_kernwin.place_t_beginning(self, *args)

    def ending(self, *args):
        """
        ending(self, ud) -> bool
        """
        return _ida_kernwin.place_t_ending(self, *args)

    def generate(self, *args):
        """
        generate(self, out, out_deflnnum, out_pfx_color, out_bgcolor, ud, maxsize) -> int
        """
        return _ida_kernwin.place_t_generate(self, *args)

    def id(self, *args):
        """
        id(self) -> int
        """
        return _ida_kernwin.place_t_id(self, *args)

    def name(self, *args):
        """
        name(self) -> char const *
        """
        return _ida_kernwin.place_t_name(self, *args)

    def toea(self, *args):
        """
        toea(self) -> ea_t
        """
        return _ida_kernwin.place_t_toea(self, *args)

    def rebase(self, *args):
        """
        rebase(self, arg2) -> bool
        """
        return _ida_kernwin.place_t_rebase(self, *args)

    def enter(self, *args):
        """
        enter(self, arg2) -> place_t
        """
        return _ida_kernwin.place_t_enter(self, *args)

    def leave(self, *args):
        """
        leave(self, arg2)
        """
        return _ida_kernwin.place_t_leave(self, *args)

    def as_idaplace_t(*args):
        """
        as_idaplace_t(p) -> idaplace_t
        """
        return _ida_kernwin.place_t_as_idaplace_t(*args)

    as_idaplace_t = staticmethod(as_idaplace_t)
    def as_enumplace_t(*args):
        """
        as_enumplace_t(p) -> enumplace_t
        """
        return _ida_kernwin.place_t_as_enumplace_t(*args)

    as_enumplace_t = staticmethod(as_enumplace_t)
    def as_structplace_t(*args):
        """
        as_structplace_t(p) -> structplace_t
        """
        return _ida_kernwin.place_t_as_structplace_t(*args)

    as_structplace_t = staticmethod(as_structplace_t)
    def as_simpleline_place_t(*args):
        """
        as_simpleline_place_t(p) -> simpleline_place_t
        """
        return _ida_kernwin.place_t_as_simpleline_place_t(*args)

    as_simpleline_place_t = staticmethod(as_simpleline_place_t)
    __swig_destroy__ = _ida_kernwin.delete_place_t
    __del__ = lambda self : None;
place_t_swigregister = _ida_kernwin.place_t_swigregister
place_t_swigregister(place_t)

def place_t_as_idaplace_t(*args):
  """
  place_t_as_idaplace_t(p) -> idaplace_t
  """
  return _ida_kernwin.place_t_as_idaplace_t(*args)

def place_t_as_enumplace_t(*args):
  """
  place_t_as_enumplace_t(p) -> enumplace_t
  """
  return _ida_kernwin.place_t_as_enumplace_t(*args)

def place_t_as_structplace_t(*args):
  """
  place_t_as_structplace_t(p) -> structplace_t
  """
  return _ida_kernwin.place_t_as_structplace_t(*args)

def place_t_as_simpleline_place_t(*args):
  """
  place_t_as_simpleline_place_t(p) -> simpleline_place_t
  """
  return _ida_kernwin.place_t_as_simpleline_place_t(*args)

DEFAULT_PLACE_LNNUM = _ida_kernwin.DEFAULT_PLACE_LNNUM
class simpleline_t(object):
    """
    Proxy of C++ simpleline_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    line = _swig_property(_ida_kernwin.simpleline_t_line_get, _ida_kernwin.simpleline_t_line_set)
    color = _swig_property(_ida_kernwin.simpleline_t_color_get, _ida_kernwin.simpleline_t_color_set)
    bgcolor = _swig_property(_ida_kernwin.simpleline_t_bgcolor_get, _ida_kernwin.simpleline_t_bgcolor_set)
    def __init__(self, *args):
        """
        __init__(self) -> simpleline_t
        __init__(self, c, str) -> simpleline_t
        __init__(self, str) -> simpleline_t
        __init__(self, str) -> simpleline_t
        """
        this = _ida_kernwin.new_simpleline_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_kernwin.delete_simpleline_t
    __del__ = lambda self : None;
simpleline_t_swigregister = _ida_kernwin.simpleline_t_swigregister
simpleline_t_swigregister(simpleline_t)

class simpleline_place_t(place_t):
    """
    Proxy of C++ simpleline_place_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    n = _swig_property(_ida_kernwin.simpleline_place_t_n_get, _ida_kernwin.simpleline_place_t_n_set)
    __swig_destroy__ = _ida_kernwin.delete_simpleline_place_t
    __del__ = lambda self : None;
simpleline_place_t_swigregister = _ida_kernwin.simpleline_place_t_swigregister
simpleline_place_t_swigregister(simpleline_place_t)

class idaplace_t(place_t):
    """
    Proxy of C++ idaplace_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ea = _swig_property(_ida_kernwin.idaplace_t_ea_get, _ida_kernwin.idaplace_t_ea_set)
    __swig_destroy__ = _ida_kernwin.delete_idaplace_t
    __del__ = lambda self : None;
idaplace_t_swigregister = _ida_kernwin.idaplace_t_swigregister
idaplace_t_swigregister(idaplace_t)

class enumplace_t(place_t):
    """
    Proxy of C++ enumplace_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    idx = _swig_property(_ida_kernwin.enumplace_t_idx_get, _ida_kernwin.enumplace_t_idx_set)
    bmask = _swig_property(_ida_kernwin.enumplace_t_bmask_get, _ida_kernwin.enumplace_t_bmask_set)
    value = _swig_property(_ida_kernwin.enumplace_t_value_get, _ida_kernwin.enumplace_t_value_set)
    serial = _swig_property(_ida_kernwin.enumplace_t_serial_get, _ida_kernwin.enumplace_t_serial_set)
    __swig_destroy__ = _ida_kernwin.delete_enumplace_t
    __del__ = lambda self : None;
enumplace_t_swigregister = _ida_kernwin.enumplace_t_swigregister
enumplace_t_swigregister(enumplace_t)

class structplace_t(place_t):
    """
    Proxy of C++ structplace_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    idx = _swig_property(_ida_kernwin.structplace_t_idx_get, _ida_kernwin.structplace_t_idx_set)
    offset = _swig_property(_ida_kernwin.structplace_t_offset_get, _ida_kernwin.structplace_t_offset_set)
    __swig_destroy__ = _ida_kernwin.delete_structplace_t
    __del__ = lambda self : None;
structplace_t_swigregister = _ida_kernwin.structplace_t_swigregister
structplace_t_swigregister(structplace_t)

PCF_EA_CAPABLE = _ida_kernwin.PCF_EA_CAPABLE

def internal_register_place_class(*args):
  """
  internal_register_place_class(tmplate, flags, owner, sdk_version) -> int
  """
  return _ida_kernwin.internal_register_place_class(*args)

def get_place_class(*args):
  """
  get_place_class(out_flags, out_sdk_version, id) -> place_t
  """
  return _ida_kernwin.get_place_class(*args)

def get_place_class_template(*args):
  """
  get_place_class_template(id) -> place_t
  """
  return _ida_kernwin.get_place_class_template(*args)

def is_place_class_ea_capable(*args):
  """
  is_place_class_ea_capable(id) -> bool
  """
  return _ida_kernwin.is_place_class_ea_capable(*args)

def get_place_class_id(*args):
  """
  get_place_class_id(name) -> int
  """
  return _ida_kernwin.get_place_class_id(*args)
class twinpos_t(object):
    """
    Proxy of C++ twinpos_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    at = _swig_property(_ida_kernwin.twinpos_t_at_get, _ida_kernwin.twinpos_t_at_set)
    x = _swig_property(_ida_kernwin.twinpos_t_x_get, _ida_kernwin.twinpos_t_x_set)
    def __init__(self, *args):
        """
        __init__(self) -> twinpos_t
        __init__(self, t) -> twinpos_t
        __init__(self, t, x0) -> twinpos_t
        """
        this = _ida_kernwin.new_twinpos_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_kernwin.twinpos_t___ne__(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_kernwin.twinpos_t___eq__(self, *args)

    def place_as_idaplace_t(self):
        return place_t.as_idaplace_t(self.at)
    def place_as_enumplace_t(self):
        return place_t.as_enumplace_t(self.at)
    def place_as_structplace_t(self):
        return place_t.as_structplace_t(self.at)
    def place_as_simpleline_place_t(self):
        return place_t.as_simpleline_place_t(self.at)

    def place(self, view):
        ptype = get_viewer_place_type(view)
        if ptype == TCCPT_IDAPLACE:
            return self.place_as_idaplace_t()
        elif ptype == TCCPT_ENUMPLACE:
            return self.place_as_enumplace_t()
        elif ptype == TCCPT_STRUCTPLACE:
            return self.place_as_structplace_t()
        elif ptype == TCCPT_SIMPLELINE_PLACE:
            return self.place_as_simpleline_place_t()
        else:
            return self.at

    __swig_destroy__ = _ida_kernwin.delete_twinpos_t
    __del__ = lambda self : None;
twinpos_t_swigregister = _ida_kernwin.twinpos_t_swigregister
twinpos_t_swigregister(twinpos_t)


def request_refresh(*args):
  """
  request_refresh(mask, cnd=True)
  """
  return _ida_kernwin.request_refresh(*args)

def clear_refresh_request(*args):
  """
  clear_refresh_request(mask)
  """
  return _ida_kernwin.clear_refresh_request(*args)

def is_refresh_requested(*args):
  """
  is_refresh_requested(mask) -> bool
  """
  return _ida_kernwin.is_refresh_requested(*args)
BWN_UNKNOWN = _ida_kernwin.BWN_UNKNOWN
BWN_EXPORTS = _ida_kernwin.BWN_EXPORTS
BWN_IMPORTS = _ida_kernwin.BWN_IMPORTS
BWN_NAMES = _ida_kernwin.BWN_NAMES
BWN_FUNCS = _ida_kernwin.BWN_FUNCS
BWN_STRINGS = _ida_kernwin.BWN_STRINGS
BWN_SEGS = _ida_kernwin.BWN_SEGS
BWN_SEGREGS = _ida_kernwin.BWN_SEGREGS
BWN_SELS = _ida_kernwin.BWN_SELS
BWN_SIGNS = _ida_kernwin.BWN_SIGNS
BWN_TILS = _ida_kernwin.BWN_TILS
BWN_LOCTYPS = _ida_kernwin.BWN_LOCTYPS
BWN_CALLS = _ida_kernwin.BWN_CALLS
BWN_PROBS = _ida_kernwin.BWN_PROBS
BWN_BPTS = _ida_kernwin.BWN_BPTS
BWN_THREADS = _ida_kernwin.BWN_THREADS
BWN_MODULES = _ida_kernwin.BWN_MODULES
BWN_TRACE = _ida_kernwin.BWN_TRACE
BWN_CALL_STACK = _ida_kernwin.BWN_CALL_STACK
BWN_XREFS = _ida_kernwin.BWN_XREFS
BWN_SEARCH = _ida_kernwin.BWN_SEARCH
BWN_FRAME = _ida_kernwin.BWN_FRAME
BWN_NAVBAND = _ida_kernwin.BWN_NAVBAND
BWN_ENUMS = _ida_kernwin.BWN_ENUMS
BWN_STRUCTS = _ida_kernwin.BWN_STRUCTS
BWN_DISASM = _ida_kernwin.BWN_DISASM
BWN_DUMP = _ida_kernwin.BWN_DUMP
BWN_NOTEPAD = _ida_kernwin.BWN_NOTEPAD
BWN_OUTPUT = _ida_kernwin.BWN_OUTPUT
BWN_CLI = _ida_kernwin.BWN_CLI
BWN_WATCH = _ida_kernwin.BWN_WATCH
BWN_LOCALS = _ida_kernwin.BWN_LOCALS
BWN_STKVIEW = _ida_kernwin.BWN_STKVIEW
BWN_CHOOSER = _ida_kernwin.BWN_CHOOSER
BWN_SHORTCUTCSR = _ida_kernwin.BWN_SHORTCUTCSR
BWN_SHORTCUTWIN = _ida_kernwin.BWN_SHORTCUTWIN
BWN_CPUREGS = _ida_kernwin.BWN_CPUREGS
BWN_SO_STRUCTS = _ida_kernwin.BWN_SO_STRUCTS
BWN_SO_OFFSETS = _ida_kernwin.BWN_SO_OFFSETS
BWN_CMDPALCSR = _ida_kernwin.BWN_CMDPALCSR
BWN_CMDPALWIN = _ida_kernwin.BWN_CMDPALWIN
BWN_SNIPPETS = _ida_kernwin.BWN_SNIPPETS
BWN_CUSTVIEW = _ida_kernwin.BWN_CUSTVIEW
BWN_ADDRWATCH = _ida_kernwin.BWN_ADDRWATCH
BWN_PSEUDOCODE = _ida_kernwin.BWN_PSEUDOCODE
BWN_STACK = _ida_kernwin.BWN_STACK
BWN_DISASMS = _ida_kernwin.BWN_DISASMS
BWN_DUMPS = _ida_kernwin.BWN_DUMPS
BWN_SEARCHS = _ida_kernwin.BWN_SEARCHS
IWID_EXPORTS = _ida_kernwin.IWID_EXPORTS
IWID_IMPORTS = _ida_kernwin.IWID_IMPORTS
IWID_NAMES = _ida_kernwin.IWID_NAMES
IWID_FUNCS = _ida_kernwin.IWID_FUNCS
IWID_STRINGS = _ida_kernwin.IWID_STRINGS
IWID_SEGS = _ida_kernwin.IWID_SEGS
IWID_SEGREGS = _ida_kernwin.IWID_SEGREGS
IWID_SELS = _ida_kernwin.IWID_SELS
IWID_SIGNS = _ida_kernwin.IWID_SIGNS
IWID_TILS = _ida_kernwin.IWID_TILS
IWID_LOCTYPS = _ida_kernwin.IWID_LOCTYPS
IWID_CALLS = _ida_kernwin.IWID_CALLS
IWID_PROBS = _ida_kernwin.IWID_PROBS
IWID_BPTS = _ida_kernwin.IWID_BPTS
IWID_THREADS = _ida_kernwin.IWID_THREADS
IWID_MODULES = _ida_kernwin.IWID_MODULES
IWID_TRACE = _ida_kernwin.IWID_TRACE
IWID_STACK = _ida_kernwin.IWID_STACK
IWID_XREFS = _ida_kernwin.IWID_XREFS
IWID_SEARCHS = _ida_kernwin.IWID_SEARCHS
IWID_FRAME = _ida_kernwin.IWID_FRAME
IWID_NAVBAND = _ida_kernwin.IWID_NAVBAND
IWID_ENUMS = _ida_kernwin.IWID_ENUMS
IWID_STRUCTS = _ida_kernwin.IWID_STRUCTS
IWID_DISASMS = _ida_kernwin.IWID_DISASMS
IWID_DUMPS = _ida_kernwin.IWID_DUMPS
IWID_NOTEPAD = _ida_kernwin.IWID_NOTEPAD
IWID_IDAMEMOS = _ida_kernwin.IWID_IDAMEMOS
IWID_ALL = _ida_kernwin.IWID_ALL

def is_chooser_widget(*args):
  """
  is_chooser_widget(t) -> bool
  """
  return _ida_kernwin.is_chooser_widget(*args)
CHITEM_BOLD = _ida_kernwin.CHITEM_BOLD
CHITEM_ITALIC = _ida_kernwin.CHITEM_ITALIC
CHITEM_UNDER = _ida_kernwin.CHITEM_UNDER
CHITEM_STRIKE = _ida_kernwin.CHITEM_STRIKE
CHITEM_GRAY = _ida_kernwin.CHITEM_GRAY
CHOOSER_NOMAINMENU = _ida_kernwin.CHOOSER_NOMAINMENU
CHOOSER_NOSTATUSBAR = _ida_kernwin.CHOOSER_NOSTATUSBAR
CHOOSER_NO_SELECTION = _ida_kernwin.CHOOSER_NO_SELECTION
CHOOSER_MULTI_SELECTION = _ida_kernwin.CHOOSER_MULTI_SELECTION
CHOOSER_POPUP_MENU = _ida_kernwin.CHOOSER_POPUP_MENU
CHOOSER_MENU_EDIT = _ida_kernwin.CHOOSER_MENU_EDIT
CHOOSER_MENU_JUMP = _ida_kernwin.CHOOSER_MENU_JUMP
CHOOSER_MENU_SEARCH = _ida_kernwin.CHOOSER_MENU_SEARCH
nat_lib = _ida_kernwin.nat_lib
nat_fun = _ida_kernwin.nat_fun
nat_cod = _ida_kernwin.nat_cod
nat_dat = _ida_kernwin.nat_dat
nat_und = _ida_kernwin.nat_und
nat_ext = _ida_kernwin.nat_ext
nat_err = _ida_kernwin.nat_err
nat_gap = _ida_kernwin.nat_gap
nat_cur = _ida_kernwin.nat_cur
nat_auto = _ida_kernwin.nat_auto
nat_last = _ida_kernwin.nat_last
CVH_USERDATA = _ida_kernwin.CVH_USERDATA
CVH_KEYDOWN = _ida_kernwin.CVH_KEYDOWN
CVH_POPUP = _ida_kernwin.CVH_POPUP
CVH_DBLCLICK = _ida_kernwin.CVH_DBLCLICK
CVH_CURPOS = _ida_kernwin.CVH_CURPOS
CVH_CLOSE = _ida_kernwin.CVH_CLOSE
CVH_CLICK = _ida_kernwin.CVH_CLICK
CVH_QT_AWARE = _ida_kernwin.CVH_QT_AWARE
CVH_HELP = _ida_kernwin.CVH_HELP
CVH_MOUSEMOVE = _ida_kernwin.CVH_MOUSEMOVE
CDVH_USERDATA = _ida_kernwin.CDVH_USERDATA
CDVH_SRCVIEW = _ida_kernwin.CDVH_SRCVIEW
CDVH_LINES_CLICK = _ida_kernwin.CDVH_LINES_CLICK
CDVH_LINES_DBLCLICK = _ida_kernwin.CDVH_LINES_DBLCLICK
CDVH_LINES_POPUP = _ida_kernwin.CDVH_LINES_POPUP
CDVH_LINES_DRAWICON = _ida_kernwin.CDVH_LINES_DRAWICON
CDVH_LINES_LINENUM = _ida_kernwin.CDVH_LINES_LINENUM
CDVH_LINES_ICONMARGIN = _ida_kernwin.CDVH_LINES_ICONMARGIN
CDVH_LINES_RADIX = _ida_kernwin.CDVH_LINES_RADIX
CDVH_LINES_ALIGNMENT = _ida_kernwin.CDVH_LINES_ALIGNMENT
VES_SHIFT = _ida_kernwin.VES_SHIFT
VES_ALT = _ida_kernwin.VES_ALT
VES_CTRL = _ida_kernwin.VES_CTRL
VES_MOUSE_LEFT = _ida_kernwin.VES_MOUSE_LEFT
VES_MOUSE_RIGHT = _ida_kernwin.VES_MOUSE_RIGHT
VES_MOUSE_MIDDLE = _ida_kernwin.VES_MOUSE_MIDDLE
VES_META = _ida_kernwin.VES_META
msg_activated = _ida_kernwin.msg_activated
msg_deactivated = _ida_kernwin.msg_deactivated
msg_click = _ida_kernwin.msg_click
msg_dblclick = _ida_kernwin.msg_dblclick
msg_closed = _ida_kernwin.msg_closed
msg_keydown = _ida_kernwin.msg_keydown
class renderer_pos_info_t(object):
    """
    Proxy of C++ renderer_pos_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> renderer_pos_info_t
        """
        this = _ida_kernwin.new_renderer_pos_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    node = _swig_property(_ida_kernwin.renderer_pos_info_t_node_get, _ida_kernwin.renderer_pos_info_t_node_set)
    cx = _swig_property(_ida_kernwin.renderer_pos_info_t_cx_get, _ida_kernwin.renderer_pos_info_t_cx_set)
    cy = _swig_property(_ida_kernwin.renderer_pos_info_t_cy_get, _ida_kernwin.renderer_pos_info_t_cy_set)
    sx = _swig_property(_ida_kernwin.renderer_pos_info_t_sx_get, _ida_kernwin.renderer_pos_info_t_sx_set)
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_kernwin.renderer_pos_info_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_kernwin.renderer_pos_info_t___ne__(self, *args)

    __swig_destroy__ = _ida_kernwin.delete_renderer_pos_info_t
    __del__ = lambda self : None;
renderer_pos_info_t_swigregister = _ida_kernwin.renderer_pos_info_t_swigregister
renderer_pos_info_t_swigregister(renderer_pos_info_t)

class view_mouse_event_location_t(object):
    """
    Proxy of C++ view_mouse_event_location_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ea = _swig_property(_ida_kernwin.view_mouse_event_location_t_ea_get, _ida_kernwin.view_mouse_event_location_t_ea_set)
    item = _swig_property(_ida_kernwin.view_mouse_event_location_t_item_get, _ida_kernwin.view_mouse_event_location_t_item_set)
    def __init__(self, *args):
        """
        __init__(self) -> view_mouse_event_location_t
        """
        this = _ida_kernwin.new_view_mouse_event_location_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_kernwin.delete_view_mouse_event_location_t
    __del__ = lambda self : None;
view_mouse_event_location_t_swigregister = _ida_kernwin.view_mouse_event_location_t_swigregister
view_mouse_event_location_t_swigregister(view_mouse_event_location_t)

class view_mouse_event_t(object):
    """
    Proxy of C++ view_mouse_event_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    rtype = _swig_property(_ida_kernwin.view_mouse_event_t_rtype_get, _ida_kernwin.view_mouse_event_t_rtype_set)
    x = _swig_property(_ida_kernwin.view_mouse_event_t_x_get, _ida_kernwin.view_mouse_event_t_x_set)
    y = _swig_property(_ida_kernwin.view_mouse_event_t_y_get, _ida_kernwin.view_mouse_event_t_y_set)
    location = _swig_property(_ida_kernwin.view_mouse_event_t_location_get, _ida_kernwin.view_mouse_event_t_location_set)
    state = _swig_property(_ida_kernwin.view_mouse_event_t_state_get, _ida_kernwin.view_mouse_event_t_state_set)
    button = _swig_property(_ida_kernwin.view_mouse_event_t_button_get, _ida_kernwin.view_mouse_event_t_button_set)
    renderer_pos = _swig_property(_ida_kernwin.view_mouse_event_t_renderer_pos_get, _ida_kernwin.view_mouse_event_t_renderer_pos_set)
    def __init__(self, *args):
        """
        __init__(self) -> view_mouse_event_t
        """
        this = _ida_kernwin.new_view_mouse_event_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_kernwin.delete_view_mouse_event_t
    __del__ = lambda self : None;
view_mouse_event_t_swigregister = _ida_kernwin.view_mouse_event_t_swigregister
view_mouse_event_t_swigregister(view_mouse_event_t)

view_activated = _ida_kernwin.view_activated
view_deactivated = _ida_kernwin.view_deactivated
view_keydown = _ida_kernwin.view_keydown
view_click = _ida_kernwin.view_click
view_dblclick = _ida_kernwin.view_dblclick
view_curpos = _ida_kernwin.view_curpos
view_created = _ida_kernwin.view_created
view_close = _ida_kernwin.view_close
view_switched = _ida_kernwin.view_switched
view_mouse_over = _ida_kernwin.view_mouse_over
view_loc_changed = _ida_kernwin.view_loc_changed
view_mouse_moved = _ida_kernwin.view_mouse_moved
lcr_unknown = _ida_kernwin.lcr_unknown
lcr_goto = _ida_kernwin.lcr_goto
lcr_user_switch = _ida_kernwin.lcr_user_switch
lcr_auto_switch = _ida_kernwin.lcr_auto_switch
lcr_jump = _ida_kernwin.lcr_jump
lcr_navigate = _ida_kernwin.lcr_navigate
lcr_scroll = _ida_kernwin.lcr_scroll
lcr_internal = _ida_kernwin.lcr_internal
LCMD_SYNC = _ida_kernwin.LCMD_SYNC
class locchange_md_t(object):
    """
    Proxy of C++ locchange_md_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self, _reason, _sync) -> locchange_md_t
        """
        this = _ida_kernwin.new_locchange_md_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def reason(self, *args):
        """
        reason(self) -> locchange_reason_t
        """
        return _ida_kernwin.locchange_md_t_reason(self, *args)

    def is_sync(self, *args):
        """
        is_sync(self) -> bool
        """
        return _ida_kernwin.locchange_md_t_is_sync(self, *args)

    __swig_destroy__ = _ida_kernwin.delete_locchange_md_t
    __del__ = lambda self : None;
locchange_md_t_swigregister = _ida_kernwin.locchange_md_t_swigregister
locchange_md_t_swigregister(locchange_md_t)

MFF_FAST = _ida_kernwin.MFF_FAST
MFF_READ = _ida_kernwin.MFF_READ
MFF_WRITE = _ida_kernwin.MFF_WRITE
MFF_NOWAIT = _ida_kernwin.MFF_NOWAIT
class ui_requests_t(object):
    """
    Proxy of C++ ui_requests_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> ui_requests_t
        """
        this = _ida_kernwin.new_ui_requests_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_kernwin.delete_ui_requests_t
    __del__ = lambda self : None;
ui_requests_t_swigregister = _ida_kernwin.ui_requests_t_swigregister
ui_requests_t_swigregister(ui_requests_t)

UIJMP_ACTIVATE = _ida_kernwin.UIJMP_ACTIVATE
UIJMP_DONTPUSH = _ida_kernwin.UIJMP_DONTPUSH
UIJMP_IDAVIEW = _ida_kernwin.UIJMP_IDAVIEW
class action_ctx_base_t(object):
    """
    Proxy of C++ action_ctx_base_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> action_ctx_base_t
        """
        this = _ida_kernwin.new_action_ctx_base_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def reset(self, *args):
        """
        reset(self)
        """
        return _ida_kernwin.action_ctx_base_t_reset(self, *args)

    widget = _swig_property(_ida_kernwin.action_ctx_base_t_widget_get, _ida_kernwin.action_ctx_base_t_widget_set)
    widget_type = _swig_property(_ida_kernwin.action_ctx_base_t_widget_type_get, _ida_kernwin.action_ctx_base_t_widget_type_set)
    widget_title = _swig_property(_ida_kernwin.action_ctx_base_t_widget_title_get, _ida_kernwin.action_ctx_base_t_widget_title_set)
    chooser_selection = _swig_property(_ida_kernwin.action_ctx_base_t_chooser_selection_get, _ida_kernwin.action_ctx_base_t_chooser_selection_set)
    action = _swig_property(_ida_kernwin.action_ctx_base_t_action_get, _ida_kernwin.action_ctx_base_t_action_set)
    cur_flags = _swig_property(_ida_kernwin.action_ctx_base_t_cur_flags_get, _ida_kernwin.action_ctx_base_t_cur_flags_set)
    def has_flag(self, *args):
        """
        has_flag(self, flag) -> bool
        """
        return _ida_kernwin.action_ctx_base_t_has_flag(self, *args)

    cur_ea = _swig_property(_ida_kernwin.action_ctx_base_t_cur_ea_get, _ida_kernwin.action_ctx_base_t_cur_ea_set)
    cur_extracted_ea = _swig_property(_ida_kernwin.action_ctx_base_t_cur_extracted_ea_get, _ida_kernwin.action_ctx_base_t_cur_extracted_ea_set)
    cur_func = _swig_property(_ida_kernwin.action_ctx_base_t_cur_func_get, _ida_kernwin.action_ctx_base_t_cur_func_set)
    cur_fchunk = _swig_property(_ida_kernwin.action_ctx_base_t_cur_fchunk_get, _ida_kernwin.action_ctx_base_t_cur_fchunk_set)
    cur_struc = _swig_property(_ida_kernwin.action_ctx_base_t_cur_struc_get, _ida_kernwin.action_ctx_base_t_cur_struc_set)
    cur_strmem = _swig_property(_ida_kernwin.action_ctx_base_t_cur_strmem_get, _ida_kernwin.action_ctx_base_t_cur_strmem_set)
    cur_enum = _swig_property(_ida_kernwin.action_ctx_base_t_cur_enum_get, _ida_kernwin.action_ctx_base_t_cur_enum_set)
    cur_seg = _swig_property(_ida_kernwin.action_ctx_base_t_cur_seg_get, _ida_kernwin.action_ctx_base_t_cur_seg_set)
    focus = _swig_property(_ida_kernwin.action_ctx_base_t_focus_get, _ida_kernwin.action_ctx_base_t_focus_set)
    reserved = _swig_property(_ida_kernwin.action_ctx_base_t_reserved_get, _ida_kernwin.action_ctx_base_t_reserved_set)
    def _get_reg(self, *args):
        """
        _get_reg(self) -> int
        """
        return _ida_kernwin.action_ctx_base_t__get_reg(self, *args)

    def _get_form_type(self, *args):
        """
        _get_form_type(self) -> twidget_type_t
        """
        return _ida_kernwin.action_ctx_base_t__get_form_type(self, *args)

    reg = property(_get_reg)

    form_type = property(_get_form_type)


    __swig_destroy__ = _ida_kernwin.delete_action_ctx_base_t
    __del__ = lambda self : None;
action_ctx_base_t_swigregister = _ida_kernwin.action_ctx_base_t_swigregister
action_ctx_base_t_swigregister(action_ctx_base_t)
ACF_HAS_SELECTION = _ida_kernwin.ACF_HAS_SELECTION
ACF_XTRN_EA = _ida_kernwin.ACF_XTRN_EA

class action_activation_ctx_t(action_ctx_base_t):
    """
    Proxy of C++ action_activation_ctx_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> action_activation_ctx_t
        """
        this = _ida_kernwin.new_action_activation_ctx_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_kernwin.delete_action_activation_ctx_t
    __del__ = lambda self : None;
action_activation_ctx_t_swigregister = _ida_kernwin.action_activation_ctx_t_swigregister
action_activation_ctx_t_swigregister(action_activation_ctx_t)

class action_update_ctx_t(action_ctx_base_t):
    """
    Proxy of C++ action_update_ctx_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> action_update_ctx_t
        """
        this = _ida_kernwin.new_action_update_ctx_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_kernwin.delete_action_update_ctx_t
    __del__ = lambda self : None;
action_update_ctx_t_swigregister = _ida_kernwin.action_update_ctx_t_swigregister
action_update_ctx_t_swigregister(action_update_ctx_t)

AHF_VERSION = _ida_kernwin.AHF_VERSION
AHF_VERSION_MASK = _ida_kernwin.AHF_VERSION_MASK
AST_ENABLE_ALWAYS = _ida_kernwin.AST_ENABLE_ALWAYS
AST_ENABLE_FOR_IDB = _ida_kernwin.AST_ENABLE_FOR_IDB
AST_ENABLE_FOR_WIDGET = _ida_kernwin.AST_ENABLE_FOR_WIDGET
AST_ENABLE = _ida_kernwin.AST_ENABLE
AST_DISABLE_ALWAYS = _ida_kernwin.AST_DISABLE_ALWAYS
AST_DISABLE_FOR_IDB = _ida_kernwin.AST_DISABLE_FOR_IDB
AST_DISABLE_FOR_WIDGET = _ida_kernwin.AST_DISABLE_FOR_WIDGET
AST_DISABLE = _ida_kernwin.AST_DISABLE

def is_action_enabled(*args):
  """
  is_action_enabled(s) -> bool
  """
  return _ida_kernwin.is_action_enabled(*args)
class action_desc_t(object):
    """
    Proxy of C++ action_desc_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    cb = _swig_property(_ida_kernwin.action_desc_t_cb_get, _ida_kernwin.action_desc_t_cb_set)
    name = _swig_property(_ida_kernwin.action_desc_t_name_get, _ida_kernwin.action_desc_t_name_set)
    label = _swig_property(_ida_kernwin.action_desc_t_label_get, _ida_kernwin.action_desc_t_label_set)
    owner = _swig_property(_ida_kernwin.action_desc_t_owner_get, _ida_kernwin.action_desc_t_owner_set)
    shortcut = _swig_property(_ida_kernwin.action_desc_t_shortcut_get, _ida_kernwin.action_desc_t_shortcut_set)
    tooltip = _swig_property(_ida_kernwin.action_desc_t_tooltip_get, _ida_kernwin.action_desc_t_tooltip_set)
    icon = _swig_property(_ida_kernwin.action_desc_t_icon_get, _ida_kernwin.action_desc_t_icon_set)
    flags = _swig_property(_ida_kernwin.action_desc_t_flags_get, _ida_kernwin.action_desc_t_flags_set)
    def __init__(self, *args):
        """
        __init__(self, name, label, handler, shortcut=None, tooltip=None, icon=-1, flags=0) -> action_desc_t
        """
        this = _ida_kernwin.new_action_desc_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_kernwin.delete_action_desc_t
    __del__ = lambda self : None;
action_desc_t_swigregister = _ida_kernwin.action_desc_t_swigregister
action_desc_t_swigregister(action_desc_t)
ADF_OWN_HANDLER = _ida_kernwin.ADF_OWN_HANDLER

AA_NONE = _ida_kernwin.AA_NONE
AA_LABEL = _ida_kernwin.AA_LABEL
AA_SHORTCUT = _ida_kernwin.AA_SHORTCUT
AA_TOOLTIP = _ida_kernwin.AA_TOOLTIP
AA_ICON = _ida_kernwin.AA_ICON
AA_STATE = _ida_kernwin.AA_STATE
AA_CHECKABLE = _ida_kernwin.AA_CHECKABLE
AA_CHECKED = _ida_kernwin.AA_CHECKED
AA_VISIBILITY = _ida_kernwin.AA_VISIBILITY

def cancel_exec_request(*args):
  """
  cancel_exec_request(req_id) -> bool
  """
  return _ida_kernwin.cancel_exec_request(*args)

def banner(*args):
  """
  banner(wait) -> bool
  """
  return _ida_kernwin.banner(*args)

def is_msg_inited(*args):
  """
  is_msg_inited() -> bool
  """
  return _ida_kernwin.is_msg_inited(*args)

def refresh_idaview(*args):
  """
  refresh_idaview()
  """
  return _ida_kernwin.refresh_idaview(*args)

def refresh_idaview_anyway(*args):
  """
  refresh_idaview_anyway()
  """
  return _ida_kernwin.refresh_idaview_anyway(*args)

def analyzer_options(*args):
  """
  analyzer_options()
  """
  return _ida_kernwin.analyzer_options(*args)

def get_screen_ea(*args):
  """
  get_screen_ea() -> ea_t
  """
  return _ida_kernwin.get_screen_ea(*args)

def get_opnum(*args):
  """
  get_opnum() -> int
  """
  return _ida_kernwin.get_opnum(*args)

def get_cursor(*args):
  """
  get_cursor() -> bool
  """
  return _ida_kernwin.get_cursor(*args)

def get_output_cursor(*args):
  """
  get_output_cursor() -> bool
  """
  return _ida_kernwin.get_output_cursor(*args)

def get_curline(*args):
  """
  get_curline() -> char *
  """
  return _ida_kernwin.get_curline(*args)

def open_url(*args):
  """
  open_url(url)
  """
  return _ida_kernwin.open_url(*args)

def get_hexdump_ea(*args):
  """
  get_hexdump_ea(hexdump_num) -> ea_t
  """
  return _ida_kernwin.get_hexdump_ea(*args)

def get_key_code(*args):
  """
  get_key_code(keyname) -> ushort
  """
  return _ida_kernwin.get_key_code(*args)

def lookup_key_code(*args):
  """
  lookup_key_code(key, shift, is_qt) -> ushort
  """
  return _ida_kernwin.lookup_key_code(*args)

def refresh_navband(*args):
  """
  refresh_navband(force)
  """
  return _ida_kernwin.refresh_navband(*args)

def refresh_chooser(*args):
  """
  refresh_chooser(title) -> bool
  """
  return _ida_kernwin.refresh_chooser(*args)

def close_chooser(*args):
  """
  close_chooser(title) -> bool
  """
  return _ida_kernwin.close_chooser(*args)

def set_dock_pos(*args):
  """
  set_dock_pos(src_ctrl, dest_ctrl, orient, left=0, top=0, right=0, bottom=0) -> bool


  Sets the dock orientation of a window relatively to another window.
  
  @param src: Source docking control
  @param dest: Destination docking control
  @param orient: One of DOR_XXXX constants
  @param left, top, right, bottom: These parameter if DOR_FLOATING is used, or if you want to specify the width of docked windows
  @return: Boolean
  
  Example:
      set_dock_pos('Structures', 'Enums', DOR_RIGHT) <- docks the Structures window to the right of Enums window
  """
  return _ida_kernwin.set_dock_pos(*args)

def free_custom_icon(*args):
  """
  free_custom_icon(icon_id)


  Frees an icon loaded with load_custom_icon()
  """
  return _ida_kernwin.free_custom_icon(*args)
class __qtimer_t(object):
    """
    Proxy of C++ __qtimer_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> __qtimer_t
        """
        this = _ida_kernwin.new___qtimer_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_kernwin.delete___qtimer_t
    __del__ = lambda self : None;
__qtimer_t_swigregister = _ida_kernwin.__qtimer_t_swigregister
__qtimer_t_swigregister(__qtimer_t)


def unregister_action(*args):
  """
  unregister_action(name) -> bool
  """
  return _ida_kernwin.unregister_action(*args)

def create_toolbar(*args):
  """
  create_toolbar(name, label, before=None, flags=0) -> bool
  """
  return _ida_kernwin.create_toolbar(*args)

def delete_toolbar(*args):
  """
  delete_toolbar(name) -> bool
  """
  return _ida_kernwin.delete_toolbar(*args)

def create_menu(*args):
  """
  create_menu(name, label, before=None) -> bool
  """
  return _ida_kernwin.create_menu(*args)

def delete_menu(*args):
  """
  delete_menu(name) -> bool
  """
  return _ida_kernwin.delete_menu(*args)

def attach_action_to_menu(*args):
  """
  attach_action_to_menu(menupath, name, flags) -> bool
  """
  return _ida_kernwin.attach_action_to_menu(*args)

def detach_action_from_menu(*args):
  """
  detach_action_from_menu(menupath, name) -> bool
  """
  return _ida_kernwin.detach_action_from_menu(*args)

def attach_action_to_toolbar(*args):
  """
  attach_action_to_toolbar(toolbar_name, name) -> bool
  """
  return _ida_kernwin.attach_action_to_toolbar(*args)

def detach_action_from_toolbar(*args):
  """
  detach_action_from_toolbar(toolbar_name, name) -> bool
  """
  return _ida_kernwin.detach_action_from_toolbar(*args)

def register_and_attach_to_menu(*args):
  """
  register_and_attach_to_menu(menupath, name, label, shortcut, flags, handler, owner) -> bool
  """
  return _ida_kernwin.register_and_attach_to_menu(*args)

def display_widget(*args):
  """
  display_widget(widget, options)
  """
  return _ida_kernwin.display_widget(*args)

def close_widget(*args):
  """
  close_widget(widget, options)
  """
  return _ida_kernwin.close_widget(*args)

def activate_widget(*args):
  """
  activate_widget(widget, take_focus)
  """
  return _ida_kernwin.activate_widget(*args)

def find_widget(*args):
  """
  find_widget(caption) -> TWidget *
  """
  return _ida_kernwin.find_widget(*args)

def get_current_widget(*args):
  """
  get_current_widget() -> TWidget *
  """
  return _ida_kernwin.get_current_widget(*args)

def get_widget_type(*args):
  """
  get_widget_type(widget) -> twidget_type_t
  """
  return _ida_kernwin.get_widget_type(*args)

def get_widget_title(*args):
  """
  get_widget_title(widget) -> bool
  """
  return _ida_kernwin.get_widget_title(*args)

def custom_viewer_jump(*args):
  """
  custom_viewer_jump(v, loc, flags) -> bool
  """
  return _ida_kernwin.custom_viewer_jump(*args)

def ea_viewer_history_push_and_jump(*args):
  """
  ea_viewer_history_push_and_jump(v, ea, x, y, lnnum) -> bool
  """
  return _ida_kernwin.ea_viewer_history_push_and_jump(*args)

def get_ea_viewer_history_info(*args):
  """
  get_ea_viewer_history_info(nback, nfwd, v) -> bool
  """
  return _ida_kernwin.get_ea_viewer_history_info(*args)

def repaint_custom_viewer(*args):
  """
  repaint_custom_viewer(custom_viewer)
  """
  return _ida_kernwin.repaint_custom_viewer(*args)

def jumpto(*args):
  """
    jumpto(ea, opnum=-1, uijmp_flags=0x0001) -> bool
    jumpto(custom_viewer, place, x, y) -> bool
    """
  return _ida_kernwin.jumpto(*args)

def get_custom_viewer_place(*args):
  """
  get_custom_viewer_place(custom_viewer, mouse) -> place_t
  """
  return _ida_kernwin.get_custom_viewer_place(*args)

def is_idaq(*args):
  """
  is_idaq() -> bool


  Returns True or False depending if IDAPython is hosted by IDAQ
  """
  return _ida_kernwin.is_idaq(*args)

def attach_action_to_popup(*args):
  """
  attach_action_to_popup(widget, popup_handle, name, popuppath=None, flags=0) -> bool
  """
  return _ida_kernwin.attach_action_to_popup(*args)

def detach_action_from_popup(*args):
  """
  detach_action_from_popup(widget, name) -> bool
  """
  return _ida_kernwin.detach_action_from_popup(*args)

def update_action_label(*args):
  """
  update_action_label(name, label) -> bool
  """
  return _ida_kernwin.update_action_label(*args)

def update_action_shortcut(*args):
  """
  update_action_shortcut(name, shortcut) -> bool
  """
  return _ida_kernwin.update_action_shortcut(*args)

def update_action_tooltip(*args):
  """
  update_action_tooltip(name, tooltip) -> bool
  """
  return _ida_kernwin.update_action_tooltip(*args)

def update_action_icon(*args):
  """
  update_action_icon(name, icon) -> bool
  """
  return _ida_kernwin.update_action_icon(*args)

def update_action_state(*args):
  """
  update_action_state(name, state) -> bool
  """
  return _ida_kernwin.update_action_state(*args)

def update_action_checkable(*args):
  """
  update_action_checkable(name, checkable) -> bool
  """
  return _ida_kernwin.update_action_checkable(*args)

def update_action_checked(*args):
  """
  update_action_checked(name, checked) -> bool
  """
  return _ida_kernwin.update_action_checked(*args)

def update_action_visibility(*args):
  """
  update_action_visibility(name, visible) -> bool
  """
  return _ida_kernwin.update_action_visibility(*args)

def get_action_label(*args):
  """
  get_action_label(name) -> bool
  """
  return _ida_kernwin.get_action_label(*args)

def get_action_shortcut(*args):
  """
  get_action_shortcut(name) -> bool
  """
  return _ida_kernwin.get_action_shortcut(*args)

def get_action_tooltip(*args):
  """
  get_action_tooltip(name) -> bool
  """
  return _ida_kernwin.get_action_tooltip(*args)

def get_action_icon(*args):
  """
  get_action_icon(name) -> bool
  """
  return _ida_kernwin.get_action_icon(*args)

def get_action_state(*args):
  """
  get_action_state(name) -> bool
  """
  return _ida_kernwin.get_action_state(*args)

def get_action_checkable(*args):
  """
  get_action_checkable(name) -> bool
  """
  return _ida_kernwin.get_action_checkable(*args)

def get_action_checked(*args):
  """
  get_action_checked(name) -> bool
  """
  return _ida_kernwin.get_action_checked(*args)

def get_action_visibility(*args):
  """
  get_action_visibility(name) -> bool
  """
  return _ida_kernwin.get_action_visibility(*args)

def set_custom_viewer_qt_aware(*args):
  """
  set_custom_viewer_qt_aware(custom_viewer) -> bool
  """
  return _ida_kernwin.set_custom_viewer_qt_aware(*args)

def get_custom_viewer_curline(*args):
  """
  get_custom_viewer_curline(custom_viewer, mouse) -> char const *
  """
  return _ida_kernwin.get_custom_viewer_curline(*args)

def get_output_curline(*args):
  """
  get_output_curline(mouse) -> bool
  """
  return _ida_kernwin.get_output_curline(*args)

def get_output_selected_text(*args):
  """
  get_output_selected_text() -> bool
  """
  return _ida_kernwin.get_output_selected_text(*args)

def get_current_viewer(*args):
  """
  get_current_viewer() -> TWidget *
  """
  return _ida_kernwin.get_current_viewer(*args)

def get_view_renderer_type(*args):
  """
  get_view_renderer_type(v) -> tcc_renderer_type_t
  """
  return _ida_kernwin.get_view_renderer_type(*args)

def set_view_renderer_type(*args):
  """
  set_view_renderer_type(v, rt)
  """
  return _ida_kernwin.set_view_renderer_type(*args)

def create_empty_widget(*args):
  """
  create_empty_widget(title, icon=-1) -> TWidget *
  """
  return _ida_kernwin.create_empty_widget(*args)

def read_selection(*args):
  """
  read_selection(v, p1, p2) -> bool


  Read the user selection, and store its information in p0 (from) and p1 (to).
  
  This can be used as follows:
  
  
  >>> p0 = idaapi.twinpos_t()
  p1 = idaapi.twinpos_t()
  view = idaapi.get_current_viewer()
  idaapi.read_selection(view, p0, p1)
  
  
  At that point, p0 and p1 hold information for the selection.
  But, the 'at' property of p0 and p1 is not properly typed.
  To specialize it, call #place() on it, passing it the view
  they were retrieved from. Like so:
  
  
  >>> place0 = p0.place(view)
  place1 = p1.place(view)
  
  
  This will effectively "cast" the place into a specialized type,
  holding proper information, depending on the view type (e.g.,
  disassembly, structures, enums, ...)
  
  @param view: The view to retrieve the selection for.
  @param p0: Storage for the "from" part of the selection.
  @param p1: Storage for the "to" part of the selection.
  @return: a bool value indicating success.
  """
  return _ida_kernwin.read_selection(*args)

def read_range_selection(*args):
  """
  read_range_selection(v) -> bool
  """
  return _ida_kernwin.read_range_selection(*args)

def unmark_selection(*args):
  """
  unmark_selection()
  """
  return _ida_kernwin.unmark_selection(*args)

def create_code_viewer(*args):
  """
  create_code_viewer(custview, flags=0, parent=None) -> TWidget *
  """
  return _ida_kernwin.create_code_viewer(*args)

def set_code_viewer_handler(*args):
  """
  set_code_viewer_handler(code_viewer, handler_id, handler_or_data) -> void *
  """
  return _ida_kernwin.set_code_viewer_handler(*args)

def set_code_viewer_user_data(*args):
  """
  set_code_viewer_user_data(code_viewer, ud) -> bool
  """
  return _ida_kernwin.set_code_viewer_user_data(*args)

def get_viewer_user_data(*args):
  """
  get_viewer_user_data(viewer) -> void *
  """
  return _ida_kernwin.get_viewer_user_data(*args)

def get_viewer_place_type(*args):
  """
  get_viewer_place_type(viewer) -> tcc_place_type_t
  """
  return _ida_kernwin.get_viewer_place_type(*args)

def set_code_viewer_line_handlers(*args):
  """
  set_code_viewer_line_handlers(code_viewer, click_handler, popup_handler, dblclick_handler, drawicon_handler, linenum_handler)
  """
  return _ida_kernwin.set_code_viewer_line_handlers(*args)

def set_code_viewer_lines_icon_margin(*args):
  """
  set_code_viewer_lines_icon_margin(code_viewer, margin) -> bool
  """
  return _ida_kernwin.set_code_viewer_lines_icon_margin(*args)

def set_code_viewer_lines_alignment(*args):
  """
  set_code_viewer_lines_alignment(code_viewer, align) -> bool
  """
  return _ida_kernwin.set_code_viewer_lines_alignment(*args)

def set_code_viewer_lines_radix(*args):
  """
  set_code_viewer_lines_radix(code_viewer, radix) -> bool
  """
  return _ida_kernwin.set_code_viewer_lines_radix(*args)

def set_code_viewer_is_source(*args):
  """
  set_code_viewer_is_source(code_viewer) -> bool
  """
  return _ida_kernwin.set_code_viewer_is_source(*args)

def get_tab_size(*args):
  """
  get_tab_size(path) -> int
  """
  return _ida_kernwin.get_tab_size(*args)

def clr_cancelled(*args):
  """
  clr_cancelled()
  """
  return _ida_kernwin.clr_cancelled(*args)

def set_cancelled(*args):
  """
  set_cancelled()
  """
  return _ida_kernwin.set_cancelled(*args)

def user_cancelled(*args):
  """
  user_cancelled() -> bool
  """
  return _ida_kernwin.user_cancelled(*args)

def ui_load_new_file(*args):
  """
  ui_load_new_file(temp_file, filename, pli, neflags, ploaders) -> bool
  """
  return _ida_kernwin.ui_load_new_file(*args)

def ui_run_debugger(*args):
  """
  ui_run_debugger(dbgopts, exename, argc, argv) -> bool
  """
  return _ida_kernwin.ui_run_debugger(*args)

def load_dbg_dbginfo(*args):
  """
  load_dbg_dbginfo(path, li=None, base=BADADDR, verbose=False) -> bool
  """
  return _ida_kernwin.load_dbg_dbginfo(*args)

def add_idc_hotkey(*args):
  """
  add_idc_hotkey(hotkey, idcfunc) -> int
  """
  return _ida_kernwin.add_idc_hotkey(*args)

def del_idc_hotkey(*args):
  """
  del_idc_hotkey(hotkey) -> bool
  """
  return _ida_kernwin.del_idc_hotkey(*args)

def get_user_strlist_options(*args):
  """
  get_user_strlist_options(out)
  """
  return _ida_kernwin.get_user_strlist_options(*args)

def set_highlight(*args):
  """
  set_highlight(viewer, str, flags) -> bool
  """
  return _ida_kernwin.set_highlight(*args)

def open_exports_window(*args):
  """
  open_exports_window(ea) -> TWidget *
  """
  return _ida_kernwin.open_exports_window(*args)

def open_imports_window(*args):
  """
  open_imports_window(ea) -> TWidget *
  """
  return _ida_kernwin.open_imports_window(*args)

def open_names_window(*args):
  """
  open_names_window(ea) -> TWidget *
  """
  return _ida_kernwin.open_names_window(*args)

def open_funcs_window(*args):
  """
  open_funcs_window(ea) -> TWidget *
  """
  return _ida_kernwin.open_funcs_window(*args)

def open_strings_window(*args):
  """
  open_strings_window(ea, selstart=BADADDR, selend=BADADDR) -> TWidget *
  """
  return _ida_kernwin.open_strings_window(*args)

def open_segments_window(*args):
  """
  open_segments_window(ea) -> TWidget *
  """
  return _ida_kernwin.open_segments_window(*args)

def open_segregs_window(*args):
  """
  open_segregs_window(ea) -> TWidget *
  """
  return _ida_kernwin.open_segregs_window(*args)

def open_selectors_window(*args):
  """
  open_selectors_window() -> TWidget *
  """
  return _ida_kernwin.open_selectors_window(*args)

def open_signatures_window(*args):
  """
  open_signatures_window() -> TWidget *
  """
  return _ida_kernwin.open_signatures_window(*args)

def open_tils_window(*args):
  """
  open_tils_window() -> TWidget *
  """
  return _ida_kernwin.open_tils_window(*args)

def open_loctypes_window(*args):
  """
  open_loctypes_window(ordinal) -> TWidget *
  """
  return _ida_kernwin.open_loctypes_window(*args)

def open_calls_window(*args):
  """
  open_calls_window(ea) -> TWidget *
  """
  return _ida_kernwin.open_calls_window(*args)

def open_problems_window(*args):
  """
  open_problems_window(ea) -> TWidget *
  """
  return _ida_kernwin.open_problems_window(*args)

def open_bpts_window(*args):
  """
  open_bpts_window(ea) -> TWidget *
  """
  return _ida_kernwin.open_bpts_window(*args)

def open_threads_window(*args):
  """
  open_threads_window() -> TWidget *
  """
  return _ida_kernwin.open_threads_window(*args)

def open_modules_window(*args):
  """
  open_modules_window() -> TWidget *
  """
  return _ida_kernwin.open_modules_window(*args)

def open_trace_window(*args):
  """
  open_trace_window() -> TWidget *
  """
  return _ida_kernwin.open_trace_window(*args)

def open_stack_window(*args):
  """
  open_stack_window() -> TWidget *
  """
  return _ida_kernwin.open_stack_window(*args)

def open_xrefs_window(*args):
  """
  open_xrefs_window(ea) -> TWidget *
  """
  return _ida_kernwin.open_xrefs_window(*args)

def open_frame_window(*args):
  """
  open_frame_window(pfn, offset) -> TWidget *
  """
  return _ida_kernwin.open_frame_window(*args)

def open_navband_window(*args):
  """
  open_navband_window(ea, zoom) -> TWidget *
  """
  return _ida_kernwin.open_navband_window(*args)

def open_enums_window(*args):
  """
  open_enums_window(const_id=BADADDR) -> TWidget *
  """
  return _ida_kernwin.open_enums_window(*args)

def open_structs_window(*args):
  """
  open_structs_window(id=BADADDR, offset=0) -> TWidget *
  """
  return _ida_kernwin.open_structs_window(*args)

def open_disasm_window(*args):
  """
  open_disasm_window(window_title, ranges=None) -> TWidget *
  """
  return _ida_kernwin.open_disasm_window(*args)

def open_hexdump_window(*args):
  """
  open_hexdump_window(window_title) -> TWidget *
  """
  return _ida_kernwin.open_hexdump_window(*args)

def open_notepad_window(*args):
  """
  open_notepad_window() -> TWidget *
  """
  return _ida_kernwin.open_notepad_window(*args)

def choose_til(*args):
  """
  choose_til() -> bool
  """
  return _ida_kernwin.choose_til(*args)

def choose_entry(*args):
  """
  choose_entry(title) -> ea_t
  """
  return _ida_kernwin.choose_entry(*args)

def choose_name(*args):
  """
  choose_name(title) -> ea_t
  """
  return _ida_kernwin.choose_name(*args)

def choose_stkvar_xref(*args):
  """
  choose_stkvar_xref(pfn, mptr) -> ea_t
  """
  return _ida_kernwin.choose_stkvar_xref(*args)

def choose_xref(*args):
  """
  choose_xref(to) -> ea_t
  """
  return _ida_kernwin.choose_xref(*args)

def choose_enum(*args):
  """
  choose_enum(title, default_id) -> enum_t
  """
  return _ida_kernwin.choose_enum(*args)

def choose_enum_by_value(*args):
  """
  choose_enum_by_value(title, default_id, value, nbytes) -> enum_t
  """
  return _ida_kernwin.choose_enum_by_value(*args)

def choose_func(*args):
  """
  choose_func(title, default_ea) -> func_t *
  """
  return _ida_kernwin.choose_func(*args)

def choose_segm(*args):
  """
  choose_segm(title, default_ea) -> segment_t *
  """
  return _ida_kernwin.choose_segm(*args)

def choose_struc(*args):
  """
  choose_struc(title) -> struc_t *
  """
  return _ida_kernwin.choose_struc(*args)

def choose_srcp(*args):
  """
  choose_srcp(title) -> sreg_range_t *
  """
  return _ida_kernwin.choose_srcp(*args)

def get_chooser_obj(*args):
  """
  get_chooser_obj(chooser_caption) -> void *
  """
  return _ida_kernwin.get_chooser_obj(*args)

def enable_chooser_item_attrs(*args):
  """
  enable_chooser_item_attrs(chooser_caption, enable) -> bool
  """
  return _ida_kernwin.enable_chooser_item_attrs(*args)

def show_wait_box(*args):
  """
  show_wait_box(format)
  """
  return _ida_kernwin.show_wait_box(*args)

def hide_wait_box(*args):
  """
  hide_wait_box()
  """
  return _ida_kernwin.hide_wait_box(*args)

def replace_wait_box(*args):
  """
  replace_wait_box(format)
  """
  return _ida_kernwin.replace_wait_box(*args)

def beep(*args):
  """
  beep(beep_type=beep_default)
  """
  return _ida_kernwin.beep(*args)

def display_copyright_warning(*args):
  """
  display_copyright_warning() -> bool
  """
  return _ida_kernwin.display_copyright_warning(*args)

def ask_for_feedback(*args):
  """
  ask_for_feedback(format)
  """
  return _ida_kernwin.ask_for_feedback(*args)

def _ask_addr(*args):
  """
  _ask_addr(addr, format) -> bool
  """
  return _ida_kernwin._ask_addr(*args)

def _ask_seg(*args):
  """
  _ask_seg(sel, format) -> bool
  """
  return _ida_kernwin._ask_seg(*args)

def _ask_long(*args):
  """
  _ask_long(value, format) -> bool
  """
  return _ida_kernwin._ask_long(*args)

def error(*args):
  """
  error(format)
  """
  return _ida_kernwin.error(*args)

def warning(*args):
  """
  warning(format)
  """
  return _ida_kernwin.warning(*args)

def info(*args):
  """
  info(format)
  """
  return _ida_kernwin.info(*args)

def nomem(*args):
  """
  nomem(format)
  """
  return _ida_kernwin.nomem(*args)
ASKBTN_YES = _ida_kernwin.ASKBTN_YES
ASKBTN_NO = _ida_kernwin.ASKBTN_NO
ASKBTN_CANCEL = _ida_kernwin.ASKBTN_CANCEL
ASKBTN_BTN1 = _ida_kernwin.ASKBTN_BTN1
ASKBTN_BTN2 = _ida_kernwin.ASKBTN_BTN2
ASKBTN_BTN3 = _ida_kernwin.ASKBTN_BTN3

def ask_yn(*args):
  """
  ask_yn(deflt, format) -> int
  """
  return _ida_kernwin.ask_yn(*args)

def ask_buttons(*args):
  """
  ask_buttons(Yes, No, Cancel, deflt, format) -> int
  """
  return _ida_kernwin.ask_buttons(*args)
HIST_SEG = _ida_kernwin.HIST_SEG
HIST_CMT = _ida_kernwin.HIST_CMT
HIST_SRCH = _ida_kernwin.HIST_SRCH
HIST_IDENT = _ida_kernwin.HIST_IDENT
HIST_FILE = _ida_kernwin.HIST_FILE
HIST_TYPE = _ida_kernwin.HIST_TYPE
HIST_CMD = _ida_kernwin.HIST_CMD
HIST_DIR = _ida_kernwin.HIST_DIR

def ask_file(*args):
  """
  ask_file(for_saving, defval, format) -> char *
  """
  return _ida_kernwin.ask_file(*args)
class addon_info_t(object):
    """
    Proxy of C++ addon_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    cb = _swig_property(_ida_kernwin.addon_info_t_cb_get, _ida_kernwin.addon_info_t_cb_set)
    id = _swig_property(_ida_kernwin.addon_info_t_id_get, _ida_kernwin.addon_info_t_id_set)
    name = _swig_property(_ida_kernwin.addon_info_t_name_get, _ida_kernwin.addon_info_t_name_set)
    producer = _swig_property(_ida_kernwin.addon_info_t_producer_get, _ida_kernwin.addon_info_t_producer_set)
    version = _swig_property(_ida_kernwin.addon_info_t_version_get, _ida_kernwin.addon_info_t_version_set)
    url = _swig_property(_ida_kernwin.addon_info_t_url_get, _ida_kernwin.addon_info_t_url_set)
    freeform = _swig_property(_ida_kernwin.addon_info_t_freeform_get, _ida_kernwin.addon_info_t_freeform_set)
    custom_data = _swig_property(_ida_kernwin.addon_info_t_custom_data_get, _ida_kernwin.addon_info_t_custom_data_set)
    custom_size = _swig_property(_ida_kernwin.addon_info_t_custom_size_get, _ida_kernwin.addon_info_t_custom_size_set)
    def __init__(self, *args):
        """
        __init__(self) -> addon_info_t
        """
        this = _ida_kernwin.new_addon_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_kernwin.delete_addon_info_t
    __del__ = lambda self : None;
addon_info_t_swigregister = _ida_kernwin.addon_info_t_swigregister
addon_info_t_swigregister(addon_info_t)
cvar = _ida_kernwin.cvar


def register_addon(*args):
  """
  register_addon(info) -> int
  """
  return _ida_kernwin.register_addon(*args)

def addon_count(*args):
  """
  addon_count() -> int
  """
  return _ida_kernwin.addon_count(*args)

def get_addon_info(*args):
  """
  get_addon_info(id, info) -> bool
  """
  return _ida_kernwin.get_addon_info(*args)

def get_addon_info_idx(*args):
  """
  get_addon_info_idx(index, info) -> bool
  """
  return _ida_kernwin.get_addon_info_idx(*args)

def add_spaces(*args):
  """
  add_spaces(str, bufsize, len) -> char *
  """
  return _ida_kernwin.add_spaces(*args)
class strarray_t(object):
    """
    Proxy of C++ strarray_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    code = _swig_property(_ida_kernwin.strarray_t_code_get, _ida_kernwin.strarray_t_code_set)
    text = _swig_property(_ida_kernwin.strarray_t_text_get, _ida_kernwin.strarray_t_text_set)
    def __init__(self, *args):
        """
        __init__(self) -> strarray_t
        """
        this = _ida_kernwin.new_strarray_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_kernwin.delete_strarray_t
    __del__ = lambda self : None;
strarray_t_swigregister = _ida_kernwin.strarray_t_swigregister
strarray_t_swigregister(strarray_t)

CLNL_RTRIM = _ida_kernwin.CLNL_RTRIM
CLNL_LTRIM = _ida_kernwin.CLNL_LTRIM
CLNL_FINDCMT = _ida_kernwin.CLNL_FINDCMT
CLNL_TRIM = _ida_kernwin.CLNL_TRIM

def qcleanline(*args):
  """
  qcleanline(cmt_char='\0', flags=((1 << 0)|(1 << 1))|(1 << 2)) -> ssize_t
  """
  return _ida_kernwin.qcleanline(*args)

def strarray(*args):
  """
  strarray(array, array_size, code) -> char const *
  """
  return _ida_kernwin.strarray(*args)

def ea2str(*args):
  """
  ea2str(ea) -> size_t
  """
  return _ida_kernwin.ea2str(*args)
IK_CANCEL = _ida_kernwin.IK_CANCEL
IK_BACK = _ida_kernwin.IK_BACK
IK_TAB = _ida_kernwin.IK_TAB
IK_CLEAR = _ida_kernwin.IK_CLEAR
IK_RETURN = _ida_kernwin.IK_RETURN
IK_SHIFT = _ida_kernwin.IK_SHIFT
IK_CONTROL = _ida_kernwin.IK_CONTROL
IK_MENU = _ida_kernwin.IK_MENU
IK_PAUSE = _ida_kernwin.IK_PAUSE
IK_CAPITAL = _ida_kernwin.IK_CAPITAL
IK_KANA = _ida_kernwin.IK_KANA
IK_ESCAPE = _ida_kernwin.IK_ESCAPE
IK_MODECHANGE = _ida_kernwin.IK_MODECHANGE
IK_SPACE = _ida_kernwin.IK_SPACE
IK_PRIOR = _ida_kernwin.IK_PRIOR
IK_NEXT = _ida_kernwin.IK_NEXT
IK_END = _ida_kernwin.IK_END
IK_HOME = _ida_kernwin.IK_HOME
IK_LEFT = _ida_kernwin.IK_LEFT
IK_UP = _ida_kernwin.IK_UP
IK_RIGHT = _ida_kernwin.IK_RIGHT
IK_DOWN = _ida_kernwin.IK_DOWN
IK_SELECT = _ida_kernwin.IK_SELECT
IK_PRINT = _ida_kernwin.IK_PRINT
IK_EXECUTE = _ida_kernwin.IK_EXECUTE
IK_SNAPSHOT = _ida_kernwin.IK_SNAPSHOT
IK_INSERT = _ida_kernwin.IK_INSERT
IK_DELETE = _ida_kernwin.IK_DELETE
IK_HELP = _ida_kernwin.IK_HELP
IK_LWIN = _ida_kernwin.IK_LWIN
IK_RWIN = _ida_kernwin.IK_RWIN
IK_APPS = _ida_kernwin.IK_APPS
IK_SLEEP = _ida_kernwin.IK_SLEEP
IK_NUMPAD0 = _ida_kernwin.IK_NUMPAD0
IK_NUMPAD1 = _ida_kernwin.IK_NUMPAD1
IK_NUMPAD2 = _ida_kernwin.IK_NUMPAD2
IK_NUMPAD3 = _ida_kernwin.IK_NUMPAD3
IK_NUMPAD4 = _ida_kernwin.IK_NUMPAD4
IK_NUMPAD5 = _ida_kernwin.IK_NUMPAD5
IK_NUMPAD6 = _ida_kernwin.IK_NUMPAD6
IK_NUMPAD7 = _ida_kernwin.IK_NUMPAD7
IK_NUMPAD8 = _ida_kernwin.IK_NUMPAD8
IK_NUMPAD9 = _ida_kernwin.IK_NUMPAD9
IK_MULTIPLY = _ida_kernwin.IK_MULTIPLY
IK_ADD = _ida_kernwin.IK_ADD
IK_SEPARATOR = _ida_kernwin.IK_SEPARATOR
IK_SUBTRACT = _ida_kernwin.IK_SUBTRACT
IK_DECIMAL = _ida_kernwin.IK_DECIMAL
IK_DIVIDE = _ida_kernwin.IK_DIVIDE
IK_F1 = _ida_kernwin.IK_F1
IK_F2 = _ida_kernwin.IK_F2
IK_F3 = _ida_kernwin.IK_F3
IK_F4 = _ida_kernwin.IK_F4
IK_F5 = _ida_kernwin.IK_F5
IK_F6 = _ida_kernwin.IK_F6
IK_F7 = _ida_kernwin.IK_F7
IK_F8 = _ida_kernwin.IK_F8
IK_F9 = _ida_kernwin.IK_F9
IK_F10 = _ida_kernwin.IK_F10
IK_F11 = _ida_kernwin.IK_F11
IK_F12 = _ida_kernwin.IK_F12
IK_F13 = _ida_kernwin.IK_F13
IK_F14 = _ida_kernwin.IK_F14
IK_F15 = _ida_kernwin.IK_F15
IK_F16 = _ida_kernwin.IK_F16
IK_F17 = _ida_kernwin.IK_F17
IK_F18 = _ida_kernwin.IK_F18
IK_F19 = _ida_kernwin.IK_F19
IK_F20 = _ida_kernwin.IK_F20
IK_F21 = _ida_kernwin.IK_F21
IK_F22 = _ida_kernwin.IK_F22
IK_F23 = _ida_kernwin.IK_F23
IK_F24 = _ida_kernwin.IK_F24
IK_NUMLOCK = _ida_kernwin.IK_NUMLOCK
IK_SCROLL = _ida_kernwin.IK_SCROLL
IK_OEM_FJ_MASSHOU = _ida_kernwin.IK_OEM_FJ_MASSHOU
IK_OEM_FJ_TOUROKU = _ida_kernwin.IK_OEM_FJ_TOUROKU
IK_LSHIFT = _ida_kernwin.IK_LSHIFT
IK_RSHIFT = _ida_kernwin.IK_RSHIFT
IK_LCONTROL = _ida_kernwin.IK_LCONTROL
IK_RCONTROL = _ida_kernwin.IK_RCONTROL
IK_LMENU = _ida_kernwin.IK_LMENU
IK_RMENU = _ida_kernwin.IK_RMENU
IK_BROWSER_BACK = _ida_kernwin.IK_BROWSER_BACK
IK_BROWSER_FORWARD = _ida_kernwin.IK_BROWSER_FORWARD
IK_BROWSER_REFRESH = _ida_kernwin.IK_BROWSER_REFRESH
IK_BROWSER_STOP = _ida_kernwin.IK_BROWSER_STOP
IK_BROWSER_SEARCH = _ida_kernwin.IK_BROWSER_SEARCH
IK_BROWSER_FAVORITES = _ida_kernwin.IK_BROWSER_FAVORITES
IK_BROWSER_HOME = _ida_kernwin.IK_BROWSER_HOME
IK_VOLUME_MUTE = _ida_kernwin.IK_VOLUME_MUTE
IK_VOLUME_DOWN = _ida_kernwin.IK_VOLUME_DOWN
IK_VOLUME_UP = _ida_kernwin.IK_VOLUME_UP
IK_MEDIA_NEXT_TRACK = _ida_kernwin.IK_MEDIA_NEXT_TRACK
IK_MEDIA_PREV_TRACK = _ida_kernwin.IK_MEDIA_PREV_TRACK
IK_MEDIA_STOP = _ida_kernwin.IK_MEDIA_STOP
IK_MEDIA_PLAY_PAUSE = _ida_kernwin.IK_MEDIA_PLAY_PAUSE
IK_LAUNCH_MAIL = _ida_kernwin.IK_LAUNCH_MAIL
IK_LAUNCH_MEDIA_SELECT = _ida_kernwin.IK_LAUNCH_MEDIA_SELECT
IK_LAUNCH_APP1 = _ida_kernwin.IK_LAUNCH_APP1
IK_LAUNCH_APP2 = _ida_kernwin.IK_LAUNCH_APP2
IK_OEM_1 = _ida_kernwin.IK_OEM_1
IK_OEM_PLUS = _ida_kernwin.IK_OEM_PLUS
IK_OEM_COMMA = _ida_kernwin.IK_OEM_COMMA
IK_OEM_MINUS = _ida_kernwin.IK_OEM_MINUS
IK_OEM_PERIOD = _ida_kernwin.IK_OEM_PERIOD
IK_OEM_2 = _ida_kernwin.IK_OEM_2
IK_OEM_3 = _ida_kernwin.IK_OEM_3
IK_OEM_4 = _ida_kernwin.IK_OEM_4
IK_OEM_5 = _ida_kernwin.IK_OEM_5
IK_OEM_6 = _ida_kernwin.IK_OEM_6
IK_OEM_7 = _ida_kernwin.IK_OEM_7
IK_OEM_102 = _ida_kernwin.IK_OEM_102
IK_PLAY = _ida_kernwin.IK_PLAY
IK_ZOOM = _ida_kernwin.IK_ZOOM
IK_OEM_CLEAR = _ida_kernwin.IK_OEM_CLEAR
CB_INIT = _ida_kernwin.CB_INIT
CB_YES = _ida_kernwin.CB_YES
CB_CLOSE = _ida_kernwin.CB_CLOSE
CB_INVISIBLE = _ida_kernwin.CB_INVISIBLE
class disasm_text_t(object):
    """
    Proxy of C++ qvector<(disasm_line_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> disasm_text_t
        __init__(self, x) -> disasm_text_t
        """
        this = _ida_kernwin.new_disasm_text_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_kernwin.delete_disasm_text_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> disasm_line_t
        """
        return _ida_kernwin.disasm_text_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_kernwin.disasm_text_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_kernwin.disasm_text_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_kernwin.disasm_text_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> disasm_line_t
        """
        return _ida_kernwin.disasm_text_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_kernwin.disasm_text_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_kernwin.disasm_text_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_kernwin.disasm_text_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=disasm_line_t())
        """
        return _ida_kernwin.disasm_text_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_kernwin.disasm_text_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_kernwin.disasm_text_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_kernwin.disasm_text_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_kernwin.disasm_text_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> disasm_line_t
        """
        return _ida_kernwin.disasm_text_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_kernwin.disasm_text_t_inject(self, *args)

    def begin(self, *args):
        """
        begin(self) -> disasm_line_t
        begin(self) -> disasm_line_t
        """
        return _ida_kernwin.disasm_text_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> disasm_line_t
        end(self) -> disasm_line_t
        """
        return _ida_kernwin.disasm_text_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> disasm_line_t
        """
        return _ida_kernwin.disasm_text_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> disasm_line_t
        erase(self, first, last) -> disasm_line_t
        """
        return _ida_kernwin.disasm_text_t_erase(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_kernwin.disasm_text_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> disasm_line_t
        """
        return _ida_kernwin.disasm_text_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_kernwin.disasm_text_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

disasm_text_t_swigregister = _ida_kernwin.disasm_text_t_swigregister
disasm_text_t_swigregister(disasm_text_t)

#<pycode(py_kernwin)>
DP_LEFT           = 0x0001
DP_TOP            = 0x0002
DP_RIGHT          = 0x0004
DP_BOTTOM         = 0x0008
DP_INSIDE         = 0x0010
# if not before, then it is after
# (use DP_INSIDE | DP_BEFORE to insert a tab before a given tab)
# this flag alone cannot be used to determine orientation
DP_BEFORE         = 0x0020
# used with combination of other flags
DP_TAB            = 0x0040
DP_FLOATING       = 0x0080

# ----------------------------------------------------------------------
def load_custom_icon(file_name=None, data=None, format=None):
    """
    Loads a custom icon and returns an identifier that can be used with other APIs

    If file_name is passed then the other two arguments are ignored.

    @param file_name: The icon file name
    @param data: The icon data
    @param format: The icon data format

    @return: Icon id or 0 on failure.
             Use free_custom_icon() to free it
    """
    if file_name is not None:
       return _ida_kernwin.py_load_custom_icon_fn(file_name)
    elif not (data is None and format is None):
       return _ida_kernwin.py_load_custom_icon_data(data, format)
    else:
      return 0

# ----------------------------------------------------------------------
def ask_long(defval, format):
    res, val = _ida_kernwin._ask_long(defval, format)

    if res == 1:
        return val
    else:
        return None

# ----------------------------------------------------------------------
def ask_addr(defval, format):
    res, ea = _ida_kernwin._ask_addr(defval, format)

    if res == 1:
        return ea
    else:
        return None

# ----------------------------------------------------------------------
def ask_seg(defval, format):
    res, sel = _ida_kernwin._ask_seg(defval, format)

    if res == 1:
        return sel
    else:
        return None

# ----------------------------------------------------------------------
def ask_ident(defval, format):
    return ask_str(defval, HIST_IDENT, format)

# ----------------------------------------------------------------------
class action_handler_t(object):
    def __init__(self):
        pass

    def activate(self, ctx):
        return 0

    def update(self, ctx):
        pass

# ----------------------------------------------------------------------
# bw-compat/deprecated. You shouldn't rely on this in new code
from ida_pro import str2user

#</pycode(py_kernwin)>


def choose_find(*args):
  """
  choose_find(title) -> PyObject *
  """
  return _ida_kernwin.choose_find(*args)

def choose_refresh(*args):
  """
  choose_refresh(self)
  """
  return _ida_kernwin.choose_refresh(*args)

def choose_close(*args):
  """
  choose_close(self)
  """
  return _ida_kernwin.choose_close(*args)

def choose_create(*args):
  """
  choose_create(self) -> int
  """
  return _ida_kernwin.choose_create(*args)

def choose_activate(*args):
  """
  choose_activate(self)
  """
  return _ida_kernwin.choose_activate(*args)

def choose_get_embedded(*args):
  """
  choose_get_embedded(self) -> PyObject *
  """
  return _ida_kernwin.choose_get_embedded(*args)

def choose_get_embedded_selection(*args):
  """
  choose_get_embedded_selection(self) -> PyObject *
  """
  return _ida_kernwin.choose_get_embedded_selection(*args)

def get_chooser_data(*args):
  """
  get_chooser_data(chooser_caption, n) -> PyObject *
  """
  return _ida_kernwin.get_chooser_data(*args)

def choose_get_widget(*args):
  """
  choose_get_widget(self) -> TWidget *
  """
  return _ida_kernwin.choose_get_widget(*args)
#<pycode(py_kernwin_choose)>
class Choose(object):
    """
    Chooser wrapper class.

    Some constants are defined in this class.
    Please refer to kernwin.hpp for more information.
    """

    CH_MODAL        = 0x01
    """
    Modal chooser
    """

    CH_MULTI        = 0x04
    """
    Allow multi selection.
    Refer the description of the OnInsertLine(), OnDeleteLine(),
    OnEditLine(), OnSelectLine(), OnRefresh(), OnSelectionChange() to
    see a difference between single and multi selection callbacks.
    """

    CH_NOBTNS       = 0x10

    CH_ATTRS        = 0x20

    CH_NOIDB        = 0x40
    """
    use the chooser even without an open database, same as x0=-2
    """

    CH_FORCE_DEFAULT = 0x80
    """
    If a non-modal chooser was already open, change selection to the given
    default one
    """

    CH_QFLT         =  0x1000
    """
    open with quick filter enabled and focused
    """

    CH_QFTYP_SHIFT  = 13
    CH_QFTYP_DEFAULT     = 0 << CH_QFTYP_SHIFT
    CH_QFTYP_NORMAL      = 1 << CH_QFTYP_SHIFT
    CH_QFTYP_WHOLE_WORDS = 2 << CH_QFTYP_SHIFT
    CH_QFTYP_REGEX       = 3 << CH_QFTYP_SHIFT
    CH_QFTYP_FUZZY       = 4 << CH_QFTYP_SHIFT
    CH_QFTYP_MASK        = 0x7 << CH_QFTYP_SHIFT

    CH_CAN_INS      = 0x000100
    """
    allow to insert new items
    """
    CH_CAN_DEL      = 0x000200
    """
    allow to delete existing item(s)
    """
    CH_CAN_EDIT     = 0x000400
    """
    allow to edit existing item(s)
    """
    CH_CAN_REFRESH  = 0x000800
    """
    allow to refresh chooser
    """

    CH_BUILTIN_SHIFT = 19
    CH_BUILTIN_MASK = 0x1F << CH_BUILTIN_SHIFT

    # column flags (are specified in the widths array)
    CHCOL_PLAIN  =  0x00000000
    CHCOL_PATH   =  0x00010000
    CHCOL_HEX    =  0x00020000
    CHCOL_DEC    =  0x00030000
    CHCOL_FORMAT =  0x00070000

    # special values of the chooser index
    NO_SELECTION   = -1
    """
    there is no selected item
    """
    EMPTY_CHOOSER  = -4
    """
    the chooser is initialized
    """
    ALREADY_EXISTS = -5
    """
    the non-modal chooser with the same data is already open
    """
    NO_ATTR        = -6
    """
    some mandatory attribute is missing
    """

    # return value of ins(), del(), edit(), enter(), refresh() callbacks
    NOTHING_CHANGED   = 0
    ALL_CHANGED       = 1
    SELECTION_CHANGED = 2

    # to construct `forbidden_cb`
    CHOOSE_HAVE_INIT    = 0x0001
    CHOOSE_HAVE_GETICON = 0x0002
    CHOOSE_HAVE_GETATTR = 0x0004
    CHOOSE_HAVE_INS     = 0x0008
    CHOOSE_HAVE_DEL     = 0x0010
    CHOOSE_HAVE_EDIT    = 0x0020
    CHOOSE_HAVE_ENTER   = 0x0040
    CHOOSE_HAVE_REFRESH = 0x0080
    CHOOSE_HAVE_SELECT  = 0x0100
    CHOOSE_HAVE_ONCLOSE = 0x0200

    class UI_Hooks_Trampoline(UI_Hooks):
        def __init__(self, v):
            UI_Hooks.__init__(self)
            self.hook()
            import weakref
            self.v = weakref.ref(v)

        def populating_widget_popup(self, form, popup_handle):
            chooser = self.v()
            if form == chooser.GetWidget() and \
               hasattr(chooser, "OnPopup") and \
               callable(getattr(chooser, "OnPopup")):
                chooser.OnPopup(form, popup_handle)

    def __init__(self, title, cols, flags = 0, popup_names = None,
                 icon=-1, x1=-1, y1=-1, x2=-1, y2=-1,
                 deflt = None,
                 embedded = False, width = None, height = None,
                 forbidden_cb = 0):
        """
        Constructs a chooser window.
        @param title: The chooser title
        @param cols: a list of colums; each list item is a list of two items
            example: [ ["Address", 10 | Choose.CHCOL_HEX],
                       ["Name",    30 | Choose.CHCOL_PLAIN] ]
        @param flags: One of CH_XXXX constants
        @param deflt: The index of the default item (0-based) for single
            selection choosers or the list of indexes for multi selection
            chooser
        @param popup_names: List of new captions to replace this list
            ["Insert", "Delete", "Edit", "Refresh"]
        @param icon: Icon index (the icon should exist in ida resources or
            an index to a custom loaded icon)
        @param x1, y1, x2, y2: The default location (for txt-version)
        @param embedded: Create as embedded chooser
        @param width: Embedded chooser width
        @param height: Embedded chooser height
        @param forbidden_cb: Explicitly forbidden callbacks
        """
        self.title = title
        self.flags = flags
        self.cols = cols
        if deflt == None:
          deflt = 0 if (flags & Choose.CH_MULTI) == 0 else [0]
        self.deflt = deflt
        self.popup_names = popup_names
        self.icon = icon
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        self.embedded = embedded
        self.width = width
        self.height = height
        self.forbidden_cb = forbidden_cb
        self.ui_hooks_trampoline = None # set on Show


    def Embedded(self):
        """
        Creates an embedded chooser (as opposed to Show())
        @return: Returns 0 on success or NO_ATTR
        """
        if not self.embedded:
          return Choose.NO_ATTR
        return _ida_kernwin.choose_create(self)


    def GetEmbSelection(self):
        """
        Returns the selection associated with an embedded chooser

        @return:
            - None if chooser is not embedded
            - A list with selection indexes (0-based)
        """
        return _ida_kernwin.choose_get_embedded_selection(self)


    def Show(self, modal=False):
        """
        Activates or creates a chooser window
        @param modal: Display as modal dialog
        @return: For all choosers it will return NO_ATTR if some mandatory
                 attribute is missing. The mandatory attributes are: flags,
                 title, cols, OnGetSize(), OnGetLine();
                 For modal choosers it will return the selected item index (0-based),
                 or NO_SELECTION if no selection,
                 or EMPTY_CHOOSER if the OnRefresh() callback returns EMPTY_CHOOSER;
                 For non-modal choosers it will return 0
                 or ALREADY_EXISTS if the chooser was already open and is active now;
        """
        if self.embedded:
          return Choose.NO_ATTR
        # it will be deleted and unhooked in py_choose_t::closed()
        self.ui_hooks_trampoline = self.UI_Hooks_Trampoline(self)
        if modal:
            self.flags |= Choose.CH_MODAL

            # Disable the timeout
            old = _ida_idaapi.set_script_timeout(0)
            n = _ida_kernwin.choose_create(self)
            _ida_idaapi.set_script_timeout(old)

            # Delete the modal chooser instance
            self.Close()

            return n
        else:
            self.flags &= ~Choose.CH_MODAL
            return _ida_kernwin.choose_create(self)


    def Activate(self):
        """
        Activates a visible chooser
        """
        return _ida_kernwin.choose_activate(self)


    def Refresh(self):
        """
        Causes the refresh callback to trigger
        """
        return _ida_kernwin.choose_refresh(self)


    def Close(self):
        """
        Closes the chooser
        """
        _ida_kernwin.choose_close(self)

    def GetWidget(self):
        """
        Return the TWidget underlying this view.

        @return: The TWidget underlying this view, or None.
        """
        return _ida_kernwin.choose_get_widget(self)

    def adjust_last_item(self, n):
        """
        Helper for OnDeleteLine() and OnRefresh() callbacks.
        They can be finished by the following line:
        return [Choose.ALL_CHANGED] + self.adjust_last_item(n)
        @param: line number of the remaining select item
        @return: list of selected lines numbers (one element or empty)
        """
        cnt = self.OnGetSize();
        if cnt == 0:
            return []
        # take in account deleting of the last item(s)
        if n >= cnt:
            n = cnt - 1
        return [n]
#</pycode(py_kernwin_choose)>


def textctrl_info_t_assign(*args):
  """
  textctrl_info_t_assign(self, other) -> bool
  """
  return _ida_kernwin.textctrl_info_t_assign(*args)

def textctrl_info_t_set_text(*args):
  """
  textctrl_info_t_set_text(self, s) -> bool
  """
  return _ida_kernwin.textctrl_info_t_set_text(*args)

def textctrl_info_t_get_text(*args):
  """
  textctrl_info_t_get_text(self) -> char const *
  """
  return _ida_kernwin.textctrl_info_t_get_text(*args)

def textctrl_info_t_set_flags(*args):
  """
  textctrl_info_t_set_flags(self, flags) -> bool
  """
  return _ida_kernwin.textctrl_info_t_set_flags(*args)

def textctrl_info_t_get_flags(*args):
  """
  textctrl_info_t_get_flags(self, flags) -> unsigned int
  """
  return _ida_kernwin.textctrl_info_t_get_flags(*args)

def textctrl_info_t_set_tabsize(*args):
  """
  textctrl_info_t_set_tabsize(self, tabsize) -> bool
  """
  return _ida_kernwin.textctrl_info_t_set_tabsize(*args)

def textctrl_info_t_get_tabsize(*args):
  """
  textctrl_info_t_get_tabsize(self, tabsize) -> unsigned int
  """
  return _ida_kernwin.textctrl_info_t_get_tabsize(*args)

def formchgcbfa_enable_field(*args):
  """
  formchgcbfa_enable_field(p_fa, fid, enable) -> bool
  """
  return _ida_kernwin.formchgcbfa_enable_field(*args)

def formchgcbfa_show_field(*args):
  """
  formchgcbfa_show_field(p_fa, fid, show) -> bool
  """
  return _ida_kernwin.formchgcbfa_show_field(*args)

def formchgcbfa_move_field(*args):
  """
  formchgcbfa_move_field(p_fa, fid, x, y, w, h) -> bool
  """
  return _ida_kernwin.formchgcbfa_move_field(*args)

def formchgcbfa_get_focused_field(*args):
  """
  formchgcbfa_get_focused_field(p_fa) -> int
  """
  return _ida_kernwin.formchgcbfa_get_focused_field(*args)

def formchgcbfa_set_focused_field(*args):
  """
  formchgcbfa_set_focused_field(p_fa, fid) -> bool
  """
  return _ida_kernwin.formchgcbfa_set_focused_field(*args)

def formchgcbfa_refresh_field(*args):
  """
  formchgcbfa_refresh_field(p_fa, fid)
  """
  return _ida_kernwin.formchgcbfa_refresh_field(*args)

def formchgcbfa_close(*args):
  """
  formchgcbfa_close(p_fa, close_normally)
  """
  return _ida_kernwin.formchgcbfa_close(*args)

def formchgcbfa_get_field_value(*args):
  """
  formchgcbfa_get_field_value(p_fa, fid, ft, sz) -> PyObject *
  """
  return _ida_kernwin.formchgcbfa_get_field_value(*args)

def formchgcbfa_set_field_value(*args):
  """
  formchgcbfa_set_field_value(p_fa, fid, ft, py_val) -> bool
  """
  return _ida_kernwin.formchgcbfa_set_field_value(*args)

def py_get_ask_form(*args):
  """
  py_get_ask_form() -> size_t
  """
  return _ida_kernwin.py_get_ask_form(*args)

def py_get_open_form(*args):
  """
  py_get_open_form() -> size_t
  """
  return _ida_kernwin.py_get_open_form(*args)

def py_register_compiled_form(*args):
  """
  py_register_compiled_form(py_form)
  """
  return _ida_kernwin.py_register_compiled_form(*args)

def py_unregister_compiled_form(*args):
  """
  py_unregister_compiled_form(py_form)
  """
  return _ida_kernwin.py_unregister_compiled_form(*args)
#<pycode(py_kernwin_askform)>
import ida_idaapi, _ida_idaapi
import ida_pro

#ICON WARNING|QUESTION|INFO|NONE
#AUTOHIDE NONE|DATABASE|REGISTRY|SESSION
#HIDECANCEL
#BUTTON YES|NO|CANCEL "Value|NONE"
#STARTITEM {id:ItemName}
#HELP / ENDHELP
try:
    import types
    import ctypes
    # On Windows, we use stdcall

    # Callback for buttons
    # typedef int (idaapi *buttoncb_t)(int button_code, form_actions_t &fa);

    _BUTTONCB_T = ctypes.WINFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.c_void_p)

    # Callback for form change
    # typedef int (idaapi *formchgcb_t)(int field_id, form_actions_t &fa);
    _FORMCHGCB_T = ctypes.WINFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.c_void_p)
except:
    try:
        _BUTTONCB_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.c_void_p)
        _FORMCHGCB_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.c_void_p)
    except:
        _BUTTONCB_T = _FORMCHGCB_T = None


# -----------------------------------------------------------------------
# textctrl_info_t clinked object
class textctrl_info_t(ida_idaapi.py_clinked_object_t):
    """
    Class representing textctrl_info_t
    """

    # Some constants
    TXTF_AUTOINDENT = 0x0001
    """
    Auto-indent on new line
    """
    TXTF_ACCEPTTABS = 0x0002
    """
    Tab key inserts 'tabsize' spaces
    """
    TXTF_READONLY   = 0x0004
    """
    Text cannot be edited (but can be selected and copied)
    """
    TXTF_SELECTED   = 0x0008
    """
    Shows the field with its text selected
    """
    TXTF_MODIFIED   = 0x0010
    """
    Gets/sets the modified status
    """
    TXTF_FIXEDFONT  = 0x0020
    """
    The control uses IDA's fixed font
    """

    def __init__(self, text="", flags=0, tabsize=0):
        ida_idaapi.py_clinked_object_t.__init__(self)
        if text:
            self.text = text
        if flags:
            self.flags = flags
        if tabsize:
            self.tabsize = tabsize

    def _create_clink(self):
        return _ida_kernwin.textctrl_info_t_create()

    def _del_clink(self, lnk):
        return _ida_kernwin.textctrl_info_t_destroy(lnk)

    def _get_clink_ptr(self):
        return _ida_kernwin.textctrl_info_t_get_clink_ptr(self)

    def assign(self, other):
        """
        Copies the contents of 'other' to 'self'
        """
        return _ida_kernwin.textctrl_info_t_assign(self, other)

    def __set_text(self, s):
        """
        Sets the text value
        """
        return _ida_kernwin.textctrl_info_t_set_text(self, s)

    def __get_text(self):
        """
        Sets the text value
        """
        return _ida_kernwin.textctrl_info_t_get_text(self)

    def __set_flags__(self, flags):
        """
        Sets the flags value
        """
        return _ida_kernwin.textctrl_info_t_set_flags(self, flags)

    def __get_flags__(self):
        """
        Returns the flags value
        """
        return _ida_kernwin.textctrl_info_t_get_flags(self)

    def __set_tabsize__(self, tabsize):
        """
        Sets the tabsize value
        """
        return _ida_kernwin.textctrl_info_t_set_tabsize(self, tabsize)

    def __get_tabsize__(self):
        """
        Returns the tabsize value
        """
        return _ida_kernwin.textctrl_info_t_get_tabsize(self)

    value   = property(__get_text, __set_text)
    """
    Alias for the text property
    """
    text    = property(__get_text, __set_text)
    """
    Text value
    """
    flags   = property(__get_flags__, __set_flags__)
    """
    Flags value
    """
    tabsize = property(__get_tabsize__, __set_tabsize__)

# -----------------------------------------------------------------------
class Form(object):

    FT_ASCII = 'A'
    """
    Ascii string - char *
    """
    FT_SEG = 'S'
    """
    Segment - sel_t *
    """
    FT_HEX = 'N'
    """
    Hex number - uval_t *
    """
    FT_SHEX = 'n'
    """
    Signed hex number - sval_t *
    """
    FT_COLOR = 'K'
    """
    Color button - bgcolor_t *
    """
    FT_ADDR = '$'
    """
    Address - ea_t *
    """
    FT_UINT64 = 'L'
    """
    default base uint64 - uint64
    """
    FT_INT64 = 'l'
    """
    default base int64 - int64
    """
    FT_RAWHEX = 'M'
    """
    Hex number, no 0x prefix - uval_t *
    """
    FT_FILE = 'f'
    """
    File browse - char * at least QMAXPATH
    """
    FT_DEC = 'D'
    """
    Decimal number - sval_t *
    """
    FT_OCT = 'O'
    """
    Octal number, C notation - sval_t *
    """
    FT_BIN = 'Y'
    """
    Binary number, 0b prefix - sval_t *
    """
    FT_CHAR = 'H'
    """
    Char value -- sval_t *
    """
    FT_IDENT = 'I'
    """
    Identifier - char * at least MAXNAMELEN
    """
    FT_BUTTON = 'B'
    """
    Button - def handler(code)
    """
    FT_DIR = 'F'
    """
    Path to directory - char * at least QMAXPATH
    """
    FT_TYPE = 'T'
    """
    Type declaration - char * at least MAXSTR
    """
    _FT_USHORT = '_US'
    """
    Unsigned short
    """
    FT_FORMCHG = '%/'
    """
    Form change callback - formchgcb_t
    """
    FT_ECHOOSER = 'E'
    """
    Embedded chooser - idaapi.Choose
    """
    FT_MULTI_LINE_TEXT = 't'
    """
    Multi text control - textctrl_info_t
    """
    FT_DROPDOWN_LIST   = 'b'
    """
    Dropdown list control - Form.DropdownControl
    """
    FT_HTML_LABEL = 'h'
    """
    HTML label to display (only for GUI version, and for dynamic labels; no input)
    """

    FT_CHKGRP = 'C'
    FT_CHKGRP2= 'c'
    FT_RADGRP = 'R'
    FT_RADGRP2= 'r'

    @staticmethod
    def fieldtype_to_ctype(tp, i64 = False):
        """
        Factory method returning a ctype class corresponding to the field type string
        """
        if tp in (Form.FT_SEG, Form.FT_HEX, Form.FT_RAWHEX, Form.FT_ADDR):
            return ctypes.c_ulonglong if i64 else ctypes.c_ulong
        elif tp in (Form.FT_SHEX, Form.FT_DEC, Form.FT_OCT, Form.FT_BIN, Form.FT_CHAR):
            return ctypes.c_longlong if i64 else ctypes.c_long
        elif tp == Form.FT_UINT64:
            return ctypes.c_ulonglong
        elif tp == Form.FT_INT64:
            return ctypes.c_longlong
        elif tp == Form.FT_COLOR:
            return ctypes.c_ulong
        elif tp == Form._FT_USHORT:
            return ctypes.c_ushort
        elif tp in (Form.FT_FORMCHG, Form.FT_ECHOOSER):
            return ctypes.c_void_p
        else:
            return None


    #
    # Generic argument helper classes
    #
    class NumericArgument(object):
        """
        Argument representing various integer arguments (ushort, uint32, uint64, etc...)
        @param tp: One of Form.FT_XXX
        """
        DefI64 = False
        def __init__(self, tp, value):
            cls = Form.fieldtype_to_ctype(tp, self.DefI64)
            if cls is None:
                raise TypeError("Invalid numeric field type: %s" % tp)
            # Get a pointer type to the ctype type
            self.arg = ctypes.pointer(cls(value))

        def __set_value(self, v):
            self.arg.contents.value = v
        value = property(lambda self: self.arg.contents.value, __set_value)


    class StringArgument(object):
        """
        Argument representing a character buffer
        """
        def __init__(self, size=None, value=None):
            if size is None:
                raise SyntaxError("The string size must be passed")

            if value is None:
                self.arg = ctypes.create_string_buffer(size)
            else:
                self.arg = ctypes.create_string_buffer(value, size)
            self.size = size

        def __set_value(self, v):
            self.arg.value = v
        value = property(lambda self: self.arg.value, __set_value)


    #
    # Base control class
    #
    class Control(object):
        def __init__(self):
            self.id = 0
            """
            Automatically assigned control ID
            """

            self.input_field_index = None
            """
            If this control is an input field, once Compile() returns this will hold its index. This is used only to compute the possible STARTITEM index
            """

            self.arg = None
            """
            Control argument value. This could be one element or a list/tuple (for multiple args per control)
            """

            self.form = None
            """
            Reference to the parent form. It is filled by Form.Add()
            """

            self.form_hasattr = False

        def get_tag(self):
            """
            Control tag character. One of Form.FT_XXXX.
            The form class will expand the {} notation and replace them with the tags
            """
            pass

        def get_arg(self):
            """
            Control returns the parameter to be pushed on the stack
            (Of ask_form())
            """
            return self.arg

        def free(self):
            """
            Free the control
            """
            # Release the parent form reference
            self.form = None

        def is_input_field(self):
            """
            Return True if this field acts as an input
            """
            return False

    #
    # Label controls
    #
    class LabelControl(Control):
        """
        Base class for static label control
        """
        def __init__(self, tp):
            Form.Control.__init__(self)
            self.tp = tp

        def get_tag(self):
            return '%%%d%s' % (self.id, self.tp)


    class StringLabel(LabelControl):
        """
        String label control
        """
        def __init__(self, value, tp=None, sz=1024):
            """
            Type field can be one of:
            A - ascii string
            T - type declaration
            I - ident
            F - folder
            f - file
            X - command
            """
            if tp is None:
                tp = Form.FT_ASCII
            Form.LabelControl.__init__(self, tp)
            self.size  = sz
            self.arg = ctypes.create_string_buffer(value, sz)


    class NumericLabel(LabelControl, NumericArgument):
        """
        Numeric label control
        """
        def __init__(self, value, tp=None):
            if tp is None:
                tp = Form.FT_HEX
            Form.LabelControl.__init__(self, tp)
            Form.NumericArgument.__init__(self, tp, value)


    #
    # Group controls
    #
    class GroupItemControl(Control):
        """
        Base class for group control items
        """
        def __init__(self, tag, parent):
            Form.Control.__init__(self)
            self.tag = tag
            self.parent = parent
            # Item position (filled when form is compiled)
            self.pos = 0

        def assign_pos(self):
            self.pos = self.parent.next_child_pos()

        def get_tag(self):
            return "%s%d" % (self.tag, self.id)

        def is_input_field(self):
            return True


    class ChkGroupItemControl(GroupItemControl):
        """
        Checkbox group item control
        """
        def __init__(self, tag, parent):
            Form.GroupItemControl.__init__(self, tag, parent)

        def __get_value(self):
            return (self.parent.value & (1 << self.pos)) != 0

        def __set_value(self, v):
            pv = self.parent.value
            if v:
                pv = pv | (1 << self.pos)
            else:
                pv = pv & ~(1 << self.pos)

            self.parent.value = pv

        checked = property(__get_value, __set_value)
        """
        Get/Sets checkbox item check status
        """


    class RadGroupItemControl(GroupItemControl):
        """
        Radiobox group item control
        """
        def __init__(self, tag, parent):
            Form.GroupItemControl.__init__(self, tag, parent)

        def __get_value(self):
            return self.parent.value == self.pos

        def __set_value(self, v):
            self.parent.value = self.pos

        selected = property(__get_value, __set_value)
        """
        Get/Sets radiobox item selection status
        """


    class GroupControl(Control, NumericArgument):
        """
        Base class for group controls
        """
        def __init__(self, children_names, tag, value=0):
            Form.Control.__init__(self)
            self.children_names = children_names
            self.tag = tag
            self._reset()
            Form.NumericArgument.__init__(self, Form._FT_USHORT, value)

        def _reset(self):
            self.childpos = 0

        def next_child_pos(self):
            v = self.childpos
            self.childpos += 1
            return v

        def get_tag(self):
            return "%d" % self.id


    class ChkGroupControl(GroupControl):
        """
        Checkbox group control class.
        It holds a set of checkbox controls
        """
        ItemClass = None
        """
        Group control item factory class instance
        We need this because later we won't be treating ChkGroupControl or RadGroupControl
        individually, instead we will be working with GroupControl in general.
        """
        def __init__(self, children_names, value=0, secondary=False):
            # Assign group item factory class
            if Form.ChkGroupControl.ItemClass is None:
                Form.ChkGroupControl.ItemClass = Form.ChkGroupItemControl

            Form.GroupControl.__init__(
                self,
                children_names,
                Form.FT_CHKGRP2 if secondary else Form.FT_CHKGRP,
                value)


    class RadGroupControl(GroupControl):
        """
        Radiobox group control class.
        It holds a set of radiobox controls
        """
        ItemClass = None
        def __init__(self, children_names, value=0, secondary=False):
            """
            Creates a radiogroup control.
            @param children_names: A tuple containing group item names
            @param value: Initial selected radio item
            @param secondory: Allows rendering one the same line as the previous group control.
                              Use this if you have another group control on the same line.
            """
            # Assign group item factory class
            if Form.RadGroupControl.ItemClass is None:
                Form.RadGroupControl.ItemClass = Form.RadGroupItemControl

            Form.GroupControl.__init__(
                self,
                children_names,
                Form.FT_RADGRP2 if secondary else Form.FT_RADGRP,
                value)


    #
    # Input controls
    #
    class InputControl(Control):
        """
        Generic form input control.
        It could be numeric control, string control, directory/file browsing, etc...
        """
        def __init__(self, tp, width, swidth, hlp = None):
            """
            @param width: Display width
            @param swidth: String width
            """
            Form.Control.__init__(self)
            self.tp = tp
            self.width = width
            self.switdh = swidth
            self.hlp = hlp

        def get_tag(self):
            return "%s%d:%s:%s:%s" % (
                self.tp, self.id,
                self.width,
                self.switdh,
                ":" if self.hlp is None else self.hlp)

        def is_input_field(self):
            return True


    class NumericInput(InputControl, NumericArgument):
        """
        A composite class serving as a base numeric input control class
        """
        def __init__(self, tp=None, value=0, width=50, swidth=10, hlp=None):
            if tp is None:
                tp = Form.FT_HEX
            Form.InputControl.__init__(self, tp, width, swidth, hlp)
            Form.NumericArgument.__init__(self, self.tp, value)


    class ColorInput(NumericInput):
        """
        Color button input control
        """
        def __init__(self, value = 0):
            """
            @param value: Initial color value in RGB
            """
            Form.NumericInput.__init__(self, tp=Form.FT_COLOR, value=value)


    class StringInput(InputControl, StringArgument):
        """
        Base string input control class.
        This class also constructs a StringArgument
        """
        def __init__(self,
                     tp=None,
                     width=1024,
                     swidth=40,
                     hlp=None,
                     value=None,
                     size=None):
            """
            @param width: String size. But in some cases it has special meaning. For example in FileInput control.
                          If you want to define the string buffer size then pass the 'size' argument
            @param swidth: Control width
            @param value: Initial value
            @param size: String size
            """
            if tp is None:
                tp = Form.FT_ASCII
            if not size:
                size = width
            Form.InputControl.__init__(self, tp, width, swidth, hlp)
            Form.StringArgument.__init__(self, size=size, value=value)


    class FileInput(StringInput):
        """
        File Open/Save input control
        """
        def __init__(self,
                     width=512,
                     swidth=80,
                     save=False, open=False,
                     hlp=None, value=None):

            if save == open:
                raise ValueError("Invalid mode. Choose either open or save")
            if width < 512:
                raise ValueError("Invalid width. Must be greater than 512.")

            # The width field is overloaded in this control and is used
            # to denote the type of the FileInput dialog (save or load)
            # On the other hand it is passed as is to the StringArgument part
            Form.StringInput.__init__(
                self,
                tp=Form.FT_FILE,
                width="1" if save else "0",
                swidth=swidth,
                hlp=hlp,
                size=width,
                value=value)


    class DirInput(StringInput):
        """
        Directory browsing control
        """
        def __init__(self,
                     width=512,
                     swidth=80,
                     hlp=None,
                     value=None):

            if width < 512:
                raise ValueError("Invalid width. Must be greater than 512.")

            Form.StringInput.__init__(
                self,
                tp=Form.FT_DIR,
                width=width,
                swidth=swidth,
                hlp=hlp,
                size=width,
                value=value)


    class ButtonInput(InputControl):
        """
        Button control.
        A handler along with a 'code' (numeric value) can be associated with the button.
        This way one handler can handle many buttons based on the button code (or in other terms id or tag)
        """
        def __init__(self, handler, code="", swidth="", hlp=None):
            """
            @param handler: Button handler. A callback taking one argument which is the code.
            @param code: A code associated with the button and that is later passed to the handler.
            """
            Form.InputControl.__init__(
                self,
                Form.FT_BUTTON,
                code,
                swidth,
                hlp)
            self.handler = handler
            self.arg = _BUTTONCB_T(self.helper_cb)

        def helper_cb(self, button_code, p_fa):
            # Remember the pointer to the forms_action in the parent form
            self.form.p_fa = p_fa

            # Call user's handler
            r = self.handler(button_code)
            return 0 if r is None else r

        def is_input_field(self):
            return False


    class FormChangeCb(Control):
        """
        Form change handler.
        This can be thought of like a dialog procedure.
        Everytime a form action occurs, this handler will be called along with the control id.
        The programmer can then call various form actions accordingly:
          - EnableField
          - ShowField
          - MoveField
          - GetFieldValue
          - etc...

        Special control IDs: -1 (The form is initialized) and -2 (Ok has been clicked)

        """
        def __init__(self, handler):
            """
            Constructs the handler.
            @param handler: The handler (preferrably a member function of a class derived from the Form class).
            """
            Form.Control.__init__(self)

            # Save the handler
            self.handler = handler

            # Create a callback stub
            # We use this mechanism to create an intermediate step
            # where we can create an 'fa' adapter for use by Python
            self.arg = _FORMCHGCB_T(self.helper_cb)

        def helper_cb(self, fid, p_fa):
            # Remember the pointer to the forms_action in the parent form
            self.form.p_fa = p_fa

            # Call user's handler
            r = self.handler(fid)
            return 0 if r is None else r

        def get_tag(self):
            return Form.FT_FORMCHG

        def free(self):
            Form.Control.free(self)
            # Remove reference to the handler
            # (Normally the handler is a member function in the parent form)
            self.handler = None


    class EmbeddedChooserControl(InputControl):
        """
        Embedded chooser control.
        This control links to a Chooser2 control created with the 'embedded=True'
        """
        def __init__(self,
                     chooser=None,
                     swidth=40,
                     hlp=None):
            """
            Embedded chooser control

            @param chooser: A chooser2 instance (must be constructed with 'embedded=True')
            """

            # !! Make sure a chooser instance is passed !!
            if chooser is None or not isinstance(chooser, Choose):
                raise ValueError("Invalid chooser passed.")

            # Create an embedded chooser structure from the Choose instance
            if chooser.Embedded() != 0:
                raise ValueError("Failed to create embedded chooser instance.")

            # Construct input control
            Form.InputControl.__init__(self, Form.FT_ECHOOSER, "", swidth)

            # Get a pointer to the chooser_info_t and the selection vector
            # (These two parameters are the needed arguments for the ask_form())
            emb, sel = _ida_kernwin.choose_get_embedded(chooser)

            # Get a pointer to a c_void_p constructed from an address
            p_embedded = ctypes.pointer(ctypes.c_void_p.from_address(emb))
            p_sel      = ctypes.pointer(ctypes.c_void_p.from_address(sel))

            # - Create the embedded chooser info on control creation
            # - Do not free the embeded chooser because after we get the args
            #   via Compile() the user can still call Execute() which relies
            #   on the already computed args
            self.arg   = (p_embedded, p_sel)

            # Save chooser instance
            self.chooser = chooser

            # Add a bogus 'size' attribute
            self.size = 0


        value = property(lambda self: self.chooser)
        """
        Returns the embedded chooser instance
        """


        def free(self):
            """
            Frees the embedded chooser data
            """
            self.chooser.Close()
            self.chooser = None
            Form.Control.free(self)


    class DropdownListControl(InputControl, ida_pro._qstrvec_t):
        """
        Dropdown control
        This control allows manipulating a dropdown control
        """
        def __init__(self, items=[], readonly=True, selval=0, width=50, swidth=50, hlp = None):
            """
            @param items: A string list of items used to prepopulate the control
            @param readonly: Specifies whether the dropdown list is editable or not
            @param selval: The preselected item index (when readonly) or text value (when editable)
            @param width: the control width (n/a if the dropdown list is readonly)
            @param swidth: string width
            """

            # Ignore the width if readonly was set
            if readonly:
                width = 0

            # Init the input control base class
            Form.InputControl.__init__(
                self,
                Form.FT_DROPDOWN_LIST,
                width,
                swidth,
                hlp)

            # Init the associated qstrvec
            ida_pro._qstrvec_t.__init__(self, items)

            # Remember if readonly or not
            self.readonly = readonly

            if readonly:
                # Create a C integer and remember it
                self.__selval = ctypes.c_int(selval)
                val_addr      = ctypes.addressof(self.__selval)
            else:
                # Create an strvec with one qstring
                self.__selval = ida_pro._qstrvec_t([selval])
                # Get address of the first element
                val_addr      = self.__selval.addressof(0)

            # Two arguments:
            # - argument #1: a pointer to the qstrvec containing the items
            # - argument #2: an integer to hold the selection
            #         or
            #            #2: a qstring to hold the dropdown text control value
            self.arg = (
                ctypes.pointer(ctypes.c_void_p.from_address(self.clink_ptr)),
                ctypes.pointer(ctypes.c_void_p.from_address(val_addr))
            )


        def __set_selval(self, val):
            if self.readonly:
                self.__selval.value = val
            else:
                self.__selval[0] = val

        def __get_selval(self):
            # Return the selection index
            # or the entered text value
            return self.__selval.value if self.readonly else self.__selval[0]

        value  = property(__get_selval, __set_selval)
        selval = property(__get_selval, __set_selval)
        """
        Read/write the selection value.
        The value is used as an item index in readonly mode or text value in editable mode
        This value can be used only after the form has been closed.
        """

        def free(self):
            self._free()


        def set_items(self, items):
            """
            Sets the dropdown list items
            """
            self.from_list(items)


    class MultiLineTextControl(InputControl, textctrl_info_t):
        """
        Multi line text control.
        This class inherits from textctrl_info_t. Thus the attributes are also inherited
        This control allows manipulating a multilinetext control
        """
        def __init__(self, text="", flags=0, tabsize=0, width=50, swidth=50, hlp = None):
            """
            @param text: Initial text value
            @param flags: One of textctrl_info_t.TXTF_.... values
            @param tabsize: Tab size
            @param width: Display width
            @param swidth: String width
            """
            # Init the input control base class
            Form.InputControl.__init__(self, Form.FT_MULTI_LINE_TEXT, width, swidth, hlp)

            # Init the associated textctrl_info base class
            textctrl_info_t.__init__(self, text=text, flags=flags, tabsize=tabsize)

            # Get the argument as a pointer from the embedded ti
            self.arg = ctypes.pointer(ctypes.c_void_p.from_address(self.clink_ptr))


        def free(self):
            self._free()


    #
    # Form class
    #
    def __init__(self, form, controls):
        """
        Contruct a Form class.
        This class wraps around ask_form() or open_form() and provides an easier / alternative syntax for describing forms.
        The form control names are wrapped inside the opening and closing curly braces and the control themselves are
        defined and instantiated via various form controls (subclasses of Form).

        @param form: The form string
        @param controls: A dictionary containing the control name as a _key_ and control object as _value_
        """
        self._reset()
        self.form = form
        """
        Form string
        """
        self.controls = controls
        """
        Dictionary of controls
        """
        self.__args = None

        self.title = None
        """
        The Form title. It will be filled when the form is compiled
        """

        self.modal = True
        """
        By default, forms are modal
        """

        self.openform_flags = 0
        """
        If non-modal, these flags will be passed to open_form.
        This is an OR'ed combination of the PluginForm.FORM_* values.
        """


    def Free(self):
        """
        Frees all resources associated with a compiled form.
        Make sure you call this function when you finish using the form.
        """

        # Free all the controls
        for name, ctrl in self.__controls.items():
            if ctrl.parent_hasattr:
                delattr(self, name)
                ctrl.parent_hasattr = False
            ctrl.free()

        # Reset the controls
        # (Note that we are not removing the form control attributes, no need)
        self._reset()

        # Unregister, so we don't try and free it again at closing-time.
        _ida_kernwin.py_unregister_compiled_form(self)


    def _reset(self):
        """
        Resets the Form class state variables
        """
        self.__controls = {}
        self.__ctrl_id = 1


    def __getitem__(self, name):
        """
        Returns a control object by name
        """
        return self.__controls[name]


    def Add(self, name, ctrl, mkattr = True):
        """
        Low level function. Prefer AddControls() to this function.
        This function adds one control to the form.

        @param name: Control name
        @param ctrl: Control object
        @param mkattr: Create control name / control object as a form attribute
        """
        # Assign a unique ID
        ctrl.id = self.__ctrl_id
        self.__ctrl_id += 1

        # Create attribute with control name
        if mkattr:
            setattr(self, name, ctrl)
            ctrl.parent_hasattr = True

        # Remember the control
        self.__controls[name] = ctrl

        # Link the form to the control via its form attribute
        ctrl.form = self

        # Is it a group? Add each child
        if isinstance(ctrl, Form.GroupControl):
            self._AddGroup(ctrl, mkattr)


    def FindControlById(self, id):
        """
        Finds a control instance given its id
        """
        for ctrl in self.__controls.values():
            if ctrl.id == id:
                return ctrl
        return None


    @staticmethod
    def _ParseFormTitle(form):
        """
        Parses the form's title from the form text
        """
        help_state = 0
        for i, line in enumerate(form.split("\n")):
            if line.startswith("STARTITEM ") or line.startswith("BUTTON "):
                continue
            # Skip "HELP" and remember state
            elif help_state == 0 and line == "HELP":
                help_state = 1 # Mark inside HELP
                continue
            elif help_state == 1 and line == "ENDHELP":
                help_state = 2 # Mark end of HELP
                continue
            return line.strip()

        return None


    def _AddGroup(self, Group, mkattr=True):
        """
        Internal function.
        This function expands the group item names and creates individual group item controls

        @param Group: The group class (checkbox or radio group class)
        """

        # Create group item controls for each child
        for child_name in Group.children_names:
            self.Add(
                child_name,
                # Use the class factory
                Group.ItemClass(Group.tag, Group),
                mkattr)


    def AddControls(self, controls, mkattr=True):
        """
        Adds controls from a dictionary.
        The dictionary key is the control name and the value is a Form.Control object
        @param controls: The control dictionary
        """
        for name, ctrl in controls.items():
            # Add the control
            self.Add(name, ctrl, mkattr)


    def CompileEx(self, form):
        """
        Low level function.
        Compiles (parses the form syntax and adds the control) the form string and
        returns the argument list to be passed the argument list to ask_form().

        The form controls are wrapped inside curly braces: {ControlName}.

        A special operator can be used to return the index of a given control by its name: {id:ControlName}.
        This is useful when you use the STARTITEM form keyword to set the initially focused control.
        (note that, technically, the index is not the same as the ID; that's because STARTITEM
        uses raw, 0-based indexes rather than control IDs to determine the focused widget.)

        @param form: Compiles the form and returns the arguments needed to be passed to ask_form()
        """
        # First argument is the form string
        args = [None]

        # Second argument, if form is not modal, is the set of flags
        if not self.modal:
            args.append(self.openform_flags | 0x80) # Add FORM_QWIDGET

        ctrlcnt = 1

        # Reset all group control internal flags
        for ctrl in self.__controls.values():
            if isinstance(ctrl, Form.GroupControl):
                ctrl._reset()

        def next_control(form, p, first_pass):
            i1 = form.find("{", p)
            if i1 < 0:
                return form, None, None, None
            if form[i1 - 1] == '\\' and i1 > 0:
                if first_pass:
                    return next_control(form, i1 + 1, first_pass)
                else:
                    # Remove escape sequence and restart search
                    form = form[:i1 - 1] + form[i1:]
                    return next_control(form, i1, first_pass)
            i2 = form.find("}", i1)
            if i2 < 0:
                raise SyntaxError("No matching closing brace '}'")
            ctrlname = form[i1 + 1:i2]
            if not ctrlname:
                raise ValueError("Control %d has an invalid name!" % ctrlcnt)
            return form, i1, i2, ctrlname


        last_input_field_index = 0
        # First pass: assign input_field_index values to controls
        p = 0
        while True:
            form, i1, i2, ctrlname = next_control(form, p, first_pass=True)
            if ctrlname is None:
                break
            p = i2

            if ctrlname.startswith("id:"):
                continue

            ctrl = self.__controls.get(ctrlname, None)
            if ctrl is None:
                raise ValueError("No matching control '%s'" % ctrlname)

            # If this control is an input, assign its index
            if ctrl.is_input_field():
                ctrl.input_field_index = last_input_field_index
                last_input_field_index += 1


        p = 0
        while True:
            form, i1, i2, ctrlname = next_control(form, p, first_pass=False)
            if ctrlname is None:
                break

            # Is it the IDOF operator?
            if ctrlname.startswith("id:"):
                idfunc = True
                # Take actual ctrlname
                ctrlname = ctrlname[3:]
            else:
                idfunc = False

            # Find the control
            ctrl = self.__controls.get(ctrlname, None)
            if ctrl is None:
                raise ValueError("No matching control '%s'" % ctrlname)

            # Replace control name by tag
            if idfunc:
                tag = str(ctrl.input_field_index if ctrl.input_field_index is not None else ctrl.id)
            else:
                tag = ctrl.get_tag()
            taglen = len(tag)
            form = form[:i1] + tag + form[i2+1:]

            # Set new position
            p = i1 + taglen

            # Was it an IDOF() ? No need to push parameters
            # Just ID substitution is fine
            if idfunc:
                continue


            # For GroupItem controls, there are no individual arguments
            # The argument is assigned for the group itself
            if isinstance(ctrl, Form.GroupItemControl):
                # GroupItem controls will have their position dynamically set
                ctrl.assign_pos()
            else:
                # Push argument(s)
                # (Some controls need more than one argument)
                arg = ctrl.get_arg()
                if isinstance(arg, (types.ListType, types.TupleType)):
                    # Push all args
                    args.extend(arg)
                else:
                    # Push one arg
                    args.append(arg)

            ctrlcnt += 1

        # If no FormChangeCb instance was passed, and thus there's no '%/'
        # in the resulting form string, let's provide a minimal one, so that
        # we will retrieve 'p_fa', and thus actions that rely on it will work.
        if form.find(Form.FT_FORMCHG) < 0:
            form = form + Form.FT_FORMCHG
            fccb = Form.FormChangeCb(lambda *args: 1)
            self.Add("___dummyfchgcb", fccb)
            # Regardless of the actual position of '%/' in the form
            # string, a formchange callback _must_ be right after
            # the form string.
            if self.modal:
                inspos = 1
            else:
                inspos = 2
            args.insert(inspos, fccb.get_arg())

        # Patch in the final form string
        args[0] = form

        self.title = self._ParseFormTitle(form)
        return args


    def Compile(self):
        """
        Compiles a form and returns the form object (self) and the argument list.
        The form object will contain object names corresponding to the form elements

        @return: It will raise an exception on failure. Otherwise the return value is ignored
        """

        # Reset controls
        self._reset()

        # Insert controls
        self.AddControls(self.controls)

        # Compile form and get args
        self.__args = self.CompileEx(self.form)

        # Register this form, to make sure it will be freed at closing-time.
        _ida_kernwin.py_register_compiled_form(self)

        return (self, self.__args)


    def Compiled(self):
        """
        Checks if the form has already been compiled

        @return: Boolean
        """
        return self.__args is not None


    def _ChkCompiled(self):
        if not self.Compiled():
            raise SyntaxError("Form is not compiled")


    def Execute(self):
        """
        Displays a modal dialog containing the compiled form.
        @return: 1 - ok ; 0 - cancel
        """
        self._ChkCompiled()
        if not self.modal:
            raise SyntaxError("Form is not modal. Open() should be instead")

        return ask_form(*self.__args)


    def Open(self):
        """
        Opens a widget containing the compiled form.
        """
        self._ChkCompiled()
        if self.modal:
            raise SyntaxError("Form is modal. Execute() should be instead")

        open_form(*self.__args)


    def EnableField(self, ctrl, enable):
        """
        Enable or disable an input field
        @return: False - no such control
        """
        return _ida_kernwin.formchgcbfa_enable_field(self.p_fa, ctrl.id, enable)


    def ShowField(self, ctrl, show):
        """
        Show or hide an input field
        @return: False - no such control
        """
        return _ida_kernwin.formchgcbfa_show_field(self.p_fa, ctrl.id, show)


    def MoveField(self, ctrl, x, y, w, h):
        """
        Move/resize an input field

        @return: False - no such fiel
        """
        return _ida_kernwin.formchgcbfa_move_field(self.p_fa, ctrl.id, x, y, w, h)


    def GetFocusedField(self):
        """
        Get currently focused input field.
        @return: None if no field is selected otherwise the control ID
        """
        id = _ida_kernwin.formchgcbfa_get_focused_field(self.p_fa)
        return self.FindControlById(id)


    def SetFocusedField(self, ctrl):
        """
        Set currently focused input field
        @return: False - no such control
        """
        return _ida_kernwin.formchgcbfa_set_focused_field(self.p_fa, ctrl.id)


    def RefreshField(self, ctrl):
        """
        Refresh a field
        @return: False - no such control
        """
        return _ida_kernwin.formchgcbfa_refresh_field(self.p_fa, ctrl.id)


    def Close(self, close_normally):
        """
        Close the form
        @param close_normally:
                   1: form is closed normally as if the user pressed Enter
                   0: form is closed abnormally as if the user pressed Esc
        @return: None
        """
        return _ida_kernwin.formchgcbfa_close(self.p_fa, close_normally)


    def GetControlValue(self, ctrl):
        """
        Returns the control's value depending on its type
        @param ctrl: Form control instance
        @return:
            - color button, radio controls: integer
            - file/dir input, string input and string label: string
            - embedded chooser control (0-based indices of selected items): integer list
            - for multilinetext control: textctrl_info_t
            - dropdown list controls: string (when editable) or index (when readonly)
            - None: on failure
        """
        tid, sz = self.ControlToFieldTypeIdAndSize(ctrl)
        r = _ida_kernwin.formchgcbfa_get_field_value(
                    self.p_fa,
                    ctrl.id,
                    tid,
                    sz)
        # Multilinetext? Unpack the tuple into a new textctrl_info_t instance
        if r is not None and tid == 7:
            return textctrl_info_t(text=r[0], flags=r[1], tabsize=r[2])
        else:
            return r


    def SetControlValue(self, ctrl, value):
        """
        Set the control's value depending on its type
        @param ctrl: Form control instance
        @param value:
            - embedded chooser: a 0-base indices list to select embedded chooser items
            - multilinetext: a textctrl_info_t
            - dropdown list: an integer designating the selection index if readonly
                             a string designating the edit control value if not readonly
        @return: Boolean true on success
        """
        tid, _ = self.ControlToFieldTypeIdAndSize(ctrl)
        return _ida_kernwin.formchgcbfa_set_field_value(
                    self.p_fa,
                    ctrl.id,
                    tid,
                    value)


    @staticmethod
    def ControlToFieldTypeIdAndSize(ctrl):
        """
        Converts a control object to a tuple containing the field id
        and the associated buffer size
        """
        # Input control depend on the associated buffer size (supplied by the user)

        # Make sure you check instances types taking into account inheritance
        if isinstance(ctrl, Form.DropdownListControl):
            return (8, 1 if ctrl.readonly else 0)
        elif isinstance(ctrl, Form.MultiLineTextControl):
            return (7, 0)
        elif isinstance(ctrl, Form.EmbeddedChooserControl):
            return (5, 0)
        # Group items or controls
        elif isinstance(ctrl, (Form.GroupItemControl, Form.GroupControl)):
            return (2, 0)
        elif isinstance(ctrl, Form.StringLabel):
            return (3, min(_ida_kernwin.MAXSTR, ctrl.size))
        elif isinstance(ctrl, Form.ColorInput):
            return (4, 0)
        elif isinstance(ctrl, Form.NumericInput):
            # Pass the numeric control type
            return (6, ord(ctrl.tp[0]))
        elif isinstance(ctrl, Form.InputControl):
            return (1, ctrl.size)
        else:
            raise NotImplementedError, "Not yet implemented"

# --------------------------------------------------------------------------
# Instantiate ask_form function pointer
try:
    import ctypes
    # Setup the numeric argument size
    Form.NumericArgument.DefI64 = _ida_idaapi.BADADDR == 0xFFFFFFFFFFFFFFFFL
    ask_form__ = ctypes.CFUNCTYPE(ctypes.c_long)(_ida_kernwin.py_get_ask_form())
    open_form__ = ctypes.CFUNCTYPE(ctypes.c_long)(_ida_kernwin.py_get_open_form())
except:
    def ask_form__(*args):
        warning("ask_form() needs ctypes library in order to work")
        return 0
    def open_form__(*args):
        warning("open_form() needs ctypes library in order to work")


def ask_form(*args):
    """
    Calls ask_form()
    @param: Compiled Arguments obtain through the Form.Compile() function
    @return: 1 = ok, 0 = cancel
    """
    old = _ida_idaapi.set_script_timeout(0)
    r = ask_form__(*args)
    _ida_idaapi.set_script_timeout(old)
    return r

def open_form(*args):
    """
    Calls open_form()
    @param: Compiled Arguments obtain through the Form.Compile() function
    """
    old = _ida_idaapi.set_script_timeout(0)
    r = open_form__(*args)
    _ida_idaapi.set_script_timeout(old)
#</pycode(py_kernwin_askform)>


def install_command_interpreter(*args):
  """
  install_command_interpreter(py_obj) -> int
  """
  return _ida_kernwin.install_command_interpreter(*args)

def remove_command_interpreter(*args):
  """
  remove_command_interpreter(cli_idx)
  """
  return _ida_kernwin.remove_command_interpreter(*args)
#<pycode(py_kernwin_cli)>
import ida_idaapi

class cli_t(ida_idaapi.pyidc_opaque_object_t):
    """
    cli_t wrapper class.

    This class allows you to implement your own command line interface handlers.
    """

    def __init__(self):
        self.__cli_idx = -1
        self.__clink__ = None


    def register(self, flags = 0, sname = None, lname = None, hint = None):
        """
        Registers the CLI.

        @param flags: Feature bits. No bits are defined yet, must be 0
        @param sname: Short name (displayed on the button)
        @param lname: Long name (displayed in the menu)
        @param hint:  Hint for the input line

        @return Boolean: True-Success, False-Failed
        """

        # Already registered?
        if self.__cli_idx >= 0:
            return True

        if sname is not None: self.sname = sname
        if lname is not None: self.lname = lname
        if hint is not None:  self.hint  = hint

        # Register
        self.__cli_idx = _ida_kernwin.install_command_interpreter(self)
        return False if self.__cli_idx < 0 else True


    def unregister(self):
        """
        Unregisters the CLI (if it was registered)
        """
        if self.__cli_idx < 0:
            return False

        _ida_kernwin.remove_command_interpreter(self.__cli_idx)
        self.__cli_idx = -1
        return True


    def __del__(self):
        self.unregister()

    #
    # Implement these methods in the subclass:
    #
#<pydoc>
#    def OnExecuteLine(self, line):
#        """
#        The user pressed Enter. The CLI is free to execute the line immediately or ask for more lines.
#
#        This callback is mandatory.
#
#        @param line: typed line(s)
#        @return Boolean: True-executed line, False-ask for more lines
#        """
#        return True
#
#    def OnKeydown(self, line, x, sellen, vkey, shift):
#        """
#        A keyboard key has been pressed
#        This is a generic callback and the CLI is free to do whatever it wants.
#
#        This callback is optional.
#
#        @param line: current input line
#        @param x: current x coordinate of the cursor
#        @param sellen: current selection length (usually 0)
#        @param vkey: virtual key code. if the key has been handled, it should be returned as zero
#        @param shift: shift state
#
#        @return:
#            None - Nothing was changed
#            tuple(line, x, sellen, vkey): if either of the input line or the x coordinate or the selection length has been modified.
#            It is possible to return a tuple with None elements to preserve old values. Example: tuple(new_line, None, None, None) or tuple(new_line)
#        """
#        return None
#
#    def OnCompleteLine(self, prefix, n, line, prefix_start):
#        """
#        The user pressed Tab. Find a completion number N for prefix PREFIX
#
#        This callback is optional.
#
#        @param prefix: Line prefix at prefix_start (string)
#        @param n: completion number (int)
#        @param line: the current line (string)
#        @param prefix_start: the index where PREFIX starts in LINE (int)
#
#        @return: None if no completion could be generated otherwise a String with the completion suggestion
#        """
#        return None
#</pydoc>

#</pycode(py_kernwin_cli)>

class View_Hooks(object):
    """
    Proxy of C++ View_Hooks class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _ida_kernwin.delete_View_Hooks
    __del__ = lambda self : None;
    def hook(self, *args):
        """
        hook(self) -> bool
        """
        return _ida_kernwin.View_Hooks_hook(self, *args)

    def unhook(self, *args):
        """
        unhook(self) -> bool
        """
        return _ida_kernwin.View_Hooks_unhook(self, *args)

    def view_activated(self, *args):
        """
        view_activated(self, view)
        """
        return _ida_kernwin.View_Hooks_view_activated(self, *args)

    def view_deactivated(self, *args):
        """
        view_deactivated(self, view)
        """
        return _ida_kernwin.View_Hooks_view_deactivated(self, *args)

    def view_keydown(self, *args):
        """
        view_keydown(self, view, key, state)
        """
        return _ida_kernwin.View_Hooks_view_keydown(self, *args)

    def view_click(self, *args):
        """
        view_click(self, view, event)
        """
        return _ida_kernwin.View_Hooks_view_click(self, *args)

    def view_dblclick(self, *args):
        """
        view_dblclick(self, view, event)
        """
        return _ida_kernwin.View_Hooks_view_dblclick(self, *args)

    def view_curpos(self, *args):
        """
        view_curpos(self, view)
        """
        return _ida_kernwin.View_Hooks_view_curpos(self, *args)

    def view_created(self, *args):
        """
        view_created(self, view)
        """
        return _ida_kernwin.View_Hooks_view_created(self, *args)

    def view_close(self, *args):
        """
        view_close(self, view)
        """
        return _ida_kernwin.View_Hooks_view_close(self, *args)

    def view_switched(self, *args):
        """
        view_switched(self, view, rt)
        """
        return _ida_kernwin.View_Hooks_view_switched(self, *args)

    def view_mouse_over(self, *args):
        """
        view_mouse_over(self, view, event)
        """
        return _ida_kernwin.View_Hooks_view_mouse_over(self, *args)

    def view_loc_changed(self, *args):
        """
        view_loc_changed(self, view, now, was)
        """
        return _ida_kernwin.View_Hooks_view_loc_changed(self, *args)

    def view_mouse_moved(self, *args):
        """
        view_mouse_moved(self, view, event)
        """
        return _ida_kernwin.View_Hooks_view_mouse_moved(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> View_Hooks
        """
        if self.__class__ == View_Hooks:
            _self = None
        else:
            _self = self
        this = _ida_kernwin.new_View_Hooks(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    def __disown__(self):
        self.this.disown()
        _ida_kernwin.disown_View_Hooks(self)
        return weakref_proxy(self)
View_Hooks_swigregister = _ida_kernwin.View_Hooks_swigregister
View_Hooks_swigregister(View_Hooks)

#<pycode(py_kernwin_viewhooks)>
# -----------------------------------------------------------------------
#                           CustomIDAMemo
# -----------------------------------------------------------------------
class CustomIDAMemo(View_Hooks):
    def __init__(self):
        View_Hooks.__init__(self)

    def _graph_item_tuple(self, ve):
        item = None
        if ve.rtype in [TCCRT_GRAPH, TCCRT_PROXIMITY]:
            item = ve.location.item
        if item is not None:
            if item.is_node:
                return (item.node,)
            else:
                return (item.elp.e.src, item.elp.e.dst)
        else:
            return ()

    @staticmethod
    def _dummy_cb(*args):
        pass

    def _get_cb(self, view, cb_name):
        cb = CustomIDAMemo._dummy_cb
        if view == self.GetWidget():
            cb = getattr(self, cb_name, cb)
        return cb

    def _get_cb_arity(self, cb):
        from inspect import getargspec
        return len(getargspec(cb).args)

    def view_activated(self, view):
        return self._get_cb(view, "OnViewActivated")()

    def view_deactivated(self, view):
        return self._get_cb(view, "OnViewDeactivated")()

    def view_keydown(self, view, key, state):
        return self._get_cb(view, "OnViewKeydown")(key, state)

    def view_click(self, view, ve):
        cb = self._get_cb(view, "OnViewClick")
        if cb != CustomIDAMemo._dummy_cb:
            arity = self._get_cb_arity(cb)
            args = [ve.x, ve.y, ve.state]
            if arity >= 5:
                args.append(ve.button)
                if arity >= 6:
                    args.append(ve.renderer_pos)
            return cb(*tuple(args))

    def view_dblclick(self, view, ve):
        cb = self._get_cb(view, "OnViewDblclick")
        if cb != CustomIDAMemo._dummy_cb:
            arity = self._get_cb_arity(cb)
            args = [ve.x, ve.y, ve.state]
            if arity >= 5:
                args.append(ve.renderer_pos)
            return cb(*tuple(args))

    def view_curpos(self, view, *args):
        return self._get_cb(view, "OnViewCurpos")()

    def view_close(self, view, *args):
        rc = self._get_cb(view, "OnClose")()
        if view == self.GetWidget():
            ida_idaapi.pycim_view_close(self)
        return rc

    def view_switched(self, view, rt):
        return self._get_cb(view, "OnViewSwitched")(rt)

    def view_mouse_over(self, view, ve):
        cb = self._get_cb(view, "OnViewMouseOver")
        if cb != CustomIDAMemo._dummy_cb:
            arity = self._get_cb_arity(cb)
            gitpl = self._graph_item_tuple(ve)
            args = [ve.x, ve.y, ve.state, len(gitpl), gitpl]
            if arity >= 7:
                args.append(ve.renderer_pos)
            return cb(*tuple(args))

    def view_loc_changed(self, view, now, was):
        return self._get_cb(view, "OnViewLocationChanged")(now, was)

    def view_mouse_moved(self, view, ve):
        cb = self._get_cb(view, "OnViewMouseMoved")
        if cb != CustomIDAMemo._dummy_cb:
            gitpl = self._graph_item_tuple(ve)
            return cb(ve.x, ve.y, ve.state, len(gitpl), gitpl, ve.renderer_pos)

    # End of hooks->wrapper trampolines


    def Refresh(self):
        """
        Refreshes the view. This causes the OnRefresh() to be called
        """
        ida_idaapi.pygc_refresh(self)

    def GetCurrentRendererType(self):
        return ida_idaapi.pygc_get_current_renderer_type(self)

    def SetCurrentRendererType(self, rtype):
        """
        Set the current view's renderer.

        @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
        """
        ida_idaapi.pygc_set_current_renderer_type(self, rtype)

    def SetNodeInfo(self, node_index, node_info, flags):
        """
        Set the properties for the given node.

        Example usage (set second nodes's bg color to red):
          inst = ...
          p = idaapi.node_info_t()
          p.bg_color = 0x00ff0000
          inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)

        @param node_index: The node index.
        @param node_info: An idaapi.node_info_t instance.
        @param flags: An OR'ed value of NIF_* values.
        """
        ida_idaapi.pygc_set_node_info(self, node_index, node_info, flags)

    def SetNodesInfos(self, values):
        """
        Set the properties for the given nodes.

        Example usage (set first three nodes's bg color to purple):
          inst = ...
          p = idaapi.node_info_t()
          p.bg_color = 0x00ff00ff
          inst.SetNodesInfos({0 : p, 1 : p, 2 : p})

        @param values: A dictionary of 'int -> node_info_t' objects.
        """
        ida_idaapi.pygc_set_nodes_infos(self, values)

    def GetNodeInfo(self, node):
        """
        Get the properties for the given node.

        @param node: The index of the node.
        @return: A tuple (bg_color, frame_color, ea, text), or None.
        """
        return ida_idaapi.pygc_get_node_info(self, node)

    def DelNodesInfos(self, *nodes):
        """
        Delete the properties for the given node(s).

        @param nodes: A list of node IDs
        """
        return ida_idaapi.pygc_del_nodes_infos(self, nodes)

    def CreateGroups(self, groups_infos):
        """
        Send a request to modify the graph by creating a
        (set of) group(s), and perform an animation.

        Each object in the 'groups_infos' list must be of the format:
        {
          "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
          "text" : <string>                    # The synthetic text for that group
        }

        @param groups_infos: A list of objects that describe those groups.
        @return: A [<int>, <int>, ...] list of group nodes, or None (failure).
        """
        return ida_idaapi.pygc_create_groups(self, groups_infos)

    def DeleteGroups(self, groups, new_current = -1):
        """
        Send a request to delete the specified groups in the graph,
        and perform an animation.

        @param groups: A list of group node numbers.
        @param new_current: A node to focus on after the groups have been deleted
        @return: True on success, False otherwise.
        """
        return ida_idaapi.pygc_delete_groups(self, groups, new_current)

    def SetGroupsVisibility(self, groups, expand, new_current = -1):
        """
        Send a request to expand/collapse the specified groups in the graph,
        and perform an animation.

        @param groups: A list of group node numbers.
        @param expand: True to expand the group, False otherwise.
        @param new_current: A node to focus on after the groups have been expanded/collapsed.
        @return: True on success, False otherwise.
        """
        return ida_idaapi.pygc_set_groups_visibility(self, groups, expand, new_current)

    def GetWidget(self):
        """
        Return the TWidget underlying this view.

        @return: The TWidget underlying this view, or None.
        """
        return ida_idaapi.pycim_get_widget(self)

# ----------------------------------------------------------------------
# bw-compat/deprecated. You shouldn't rely on this in new code
import ida_idaapi
ida_idaapi.CustomIDAMemo = CustomIDAMemo

#</pycode(py_kernwin_viewhooks)>


def pyidag_bind(*args):
  """
  pyidag_bind(self) -> bool
  """
  return _ida_kernwin.pyidag_bind(*args)

def pyidag_unbind(*args):
  """
  pyidag_unbind(self) -> bool
  """
  return _ida_kernwin.pyidag_unbind(*args)
#<pycode(py_kernwin_idaview)>
#-------------------------------------------------------------------------
#                             IDAViewWrapper
#-------------------------------------------------------------------------
import _ida_kernwin
class IDAViewWrapper(CustomIDAMemo):
    """
    Deprecated. Use View_Hooks instead.

    Because the lifecycle of an IDAView is not trivial to track (e.g., a user
    might close, then re-open the same disassembly view), this wrapper doesn't
    bring anything superior to the View_Hooks: quite the contrary, as the
    latter is much more generic (and better maps IDA's internal model.)
    """
    def __init__(self, title):
        CustomIDAMemo.__init__(self)
        self._title = title

    def Bind(self):
        rc = _ida_kernwin.pyidag_bind(self)
        if rc:
            self.hook()
        return rc

    def Unbind(self):
        rc = _ida_kernwin.pyidag_unbind(self)
        if rc:
            self.unhook()
        return rc

#</pycode(py_kernwin_idaview)>


def pyscv_init(*args):
  """
  pyscv_init(py_link, title) -> PyObject *
  """
  return _ida_kernwin.pyscv_init(*args)

def pyscv_refresh(*args):
  """
  pyscv_refresh(py_this) -> bool
  """
  return _ida_kernwin.pyscv_refresh(*args)

def pyscv_delete(*args):
  """
  pyscv_delete(py_this) -> bool
  """
  return _ida_kernwin.pyscv_delete(*args)

def pyscv_refresh_current(*args):
  """
  pyscv_refresh_current(py_this) -> bool
  """
  return _ida_kernwin.pyscv_refresh_current(*args)

def pyscv_get_current_line(*args):
  """
  pyscv_get_current_line(py_this, mouse, notags) -> PyObject *
  """
  return _ida_kernwin.pyscv_get_current_line(*args)

def pyscv_is_focused(*args):
  """
  pyscv_is_focused(py_this) -> bool
  """
  return _ida_kernwin.pyscv_is_focused(*args)

def pyscv_count(*args):
  """
  pyscv_count(py_this) -> size_t
  """
  return _ida_kernwin.pyscv_count(*args)

def pyscv_show(*args):
  """
  pyscv_show(py_this) -> bool
  """
  return _ida_kernwin.pyscv_show(*args)

def pyscv_close(*args):
  """
  pyscv_close(py_this)
  """
  return _ida_kernwin.pyscv_close(*args)

def pyscv_jumpto(*args):
  """
  pyscv_jumpto(py_this, ln, x, y) -> bool
  """
  return _ida_kernwin.pyscv_jumpto(*args)

def pyscv_get_line(*args):
  """
  pyscv_get_line(py_this, nline) -> PyObject *
  """
  return _ida_kernwin.pyscv_get_line(*args)

def pyscv_get_pos(*args):
  """
  pyscv_get_pos(py_this, mouse) -> PyObject *
  """
  return _ida_kernwin.pyscv_get_pos(*args)

def pyscv_clear_lines(*args):
  """
  pyscv_clear_lines(py_this) -> PyObject *
  """
  return _ida_kernwin.pyscv_clear_lines(*args)

def pyscv_add_line(*args):
  """
  pyscv_add_line(py_this, py_sl) -> bool
  """
  return _ida_kernwin.pyscv_add_line(*args)

def pyscv_insert_line(*args):
  """
  pyscv_insert_line(py_this, nline, py_sl) -> bool
  """
  return _ida_kernwin.pyscv_insert_line(*args)

def pyscv_patch_line(*args):
  """
  pyscv_patch_line(py_this, nline, offs, value) -> bool
  """
  return _ida_kernwin.pyscv_patch_line(*args)

def pyscv_del_line(*args):
  """
  pyscv_del_line(py_this, nline) -> bool
  """
  return _ida_kernwin.pyscv_del_line(*args)

def pyscv_get_selection(*args):
  """
  pyscv_get_selection(py_this) -> PyObject *
  """
  return _ida_kernwin.pyscv_get_selection(*args)

def pyscv_get_current_word(*args):
  """
  pyscv_get_current_word(py_this, mouse) -> PyObject *
  """
  return _ida_kernwin.pyscv_get_current_word(*args)

def pyscv_edit_line(*args):
  """
  pyscv_edit_line(py_this, nline, py_sl) -> bool
  """
  return _ida_kernwin.pyscv_edit_line(*args)

def pyscv_get_widget(*args):
  """
  pyscv_get_widget(py_this) -> TWidget *
  """
  return _ida_kernwin.pyscv_get_widget(*args)
#<pycode(py_kernwin_custview)>
class simplecustviewer_t(object):
    """
    The base class for implementing simple custom viewers
    """
    def __init__(self):
        self.__this = None

    def __del__(self):
        """
        Destructor. It also frees the associated C++ object
        """
        try:
            _ida_kernwin.pyscv_delete(self.__this)
        except:
            pass

    @staticmethod
    def __make_sl_arg(line, fgcolor=None, bgcolor=None):
        return line if (fgcolor is None and bgcolor is None) else (line, fgcolor, bgcolor)

    def Create(self, title):
        """
        Creates the custom view. This should be the first method called after instantiation

        @param title: The title of the view
        @return: Boolean whether it succeeds or fails. It may fail if a window with the same title is already open.
                 In this case better close existing windows
        """
        self.title = title
        self.__this = _ida_kernwin.pyscv_init(self, title)
        return True if self.__this else False

    def Close(self):
        """
        Destroys the view.
        One has to call Create() afterwards.
        Show() can be called and it will call Create() internally.
        @return: Boolean
        """
        return _ida_kernwin.pyscv_close(self.__this)

    def Show(self):
        """
        Shows an already created view. It the view was close, then it will call Create() for you
        @return: Boolean
        """
        return _ida_kernwin.pyscv_show(self.__this)

    def Refresh(self):
        return _ida_kernwin.pyscv_refresh(self.__this)

    def RefreshCurrent(self):
        """
        Refreshes the current line only
        """
        return _ida_kernwin.pyscv_refresh_current(self.__this)

    def Count(self):
        """
        Returns the number of lines in the view
        """
        return _ida_kernwin.pyscv_count(self.__this)

    def GetSelection(self):
        """
        Returns the selected range or None
        @return:
            - tuple(x1, y1, x2, y2)
            - None if no selection
        """
        return _ida_kernwin.pyscv_get_selection(self.__this)

    def ClearLines(self):
        """
        Clears all the lines
        """
        _ida_kernwin.pyscv_clear_lines(self.__this)

    def AddLine(self, line, fgcolor=None, bgcolor=None):
        """
        Adds a colored line to the view
        @return: Boolean
        """
        return _ida_kernwin.pyscv_add_line(self.__this, self.__make_sl_arg(line, fgcolor, bgcolor))

    def InsertLine(self, lineno, line, fgcolor=None, bgcolor=None):
        """
        Inserts a line in the given position
        @return: Boolean
        """
        return _ida_kernwin.pyscv_insert_line(self.__this, lineno, self.__make_sl_arg(line, fgcolor, bgcolor))

    def EditLine(self, lineno, line, fgcolor=None, bgcolor=None):
        """
        Edits an existing line.
        @return: Boolean
        """
        return _ida_kernwin.pyscv_edit_line(self.__this, lineno, self.__make_sl_arg(line, fgcolor, bgcolor))

    def PatchLine(self, lineno, offs, value):
        """
        Patches an existing line character at the given offset. This is a low level function. You must know what you're doing
        """
        return _ida_kernwin.pyscv_patch_line(self.__this, lineno, offs, value)

    def DelLine(self, lineno):
        """
        Deletes an existing line
        @return: Boolean
        """
        return _ida_kernwin.pyscv_del_line(self.__this, lineno)

    def GetLine(self, lineno):
        """
        Returns a line
        @param lineno: The line number
        @return:
            Returns a tuple (colored_line, fgcolor, bgcolor) or None
        """
        return _ida_kernwin.pyscv_get_line(self.__this, lineno)

    def GetCurrentWord(self, mouse = 0):
        """
        Returns the current word
        @param mouse: Use mouse position or cursor position
        @return: None if failed or a String containing the current word at mouse or cursor
        """
        return _ida_kernwin.pyscv_get_current_word(self.__this, mouse)

    def GetCurrentLine(self, mouse = 0, notags = 0):
        """
        Returns the current line.
        @param mouse: Current line at mouse pos
        @param notags: If True then tag_remove() will be called before returning the line
        @return: Returns the current line (colored or uncolored) or None on failure
        """
        return _ida_kernwin.pyscv_get_current_line(self.__this, mouse, notags)

    def GetPos(self, mouse = 0):
        """
        Returns the current cursor or mouse position.
        @param mouse: return mouse position
        @return: Returns a tuple (lineno, x, y)
        """
        return _ida_kernwin.pyscv_get_pos(self.__this, mouse)

    def GetLineNo(self, mouse = 0):
        """
        Calls GetPos() and returns the current line number or -1 on failure
        """
        r = self.GetPos(mouse)
        return -1 if not r else r[0]

    def Jump(self, lineno, x=0, y=0):
        return _ida_kernwin.pyscv_jumpto(self.__this, lineno, x, y)

    def IsFocused(self):
        """
        Returns True if the current view is the focused view
        """
        return _ida_kernwin.pyscv_is_focused(self.__this)

    def GetWidget(self):
        """
        Return the TWidget underlying this view.

        @return: The TWidget underlying this view, or None.
        """
        return _ida_kernwin.pyscv_get_widget(self.__this)



    # Here are all the supported events
#<pydoc>
#    def OnClick(self, shift):
#        """
#        User clicked in the view
#        @param shift: Shift flag
#        @return: Boolean. True if you handled the event
#        """
#        print "OnClick, shift=%d" % shift
#        return True
#
#    def OnDblClick(self, shift):
#        """
#        User dbl-clicked in the view
#        @param shift: Shift flag
#        @return: Boolean. True if you handled the event
#        """
#        print "OnDblClick, shift=%d" % shift
#        return True
#
#    def OnCursorPosChanged(self):
#        """
#        Cursor position changed.
#        @return: Nothing
#        """
#        print "OnCurposChanged"
#
#    def OnClose(self):
#        """
#        The view is closing. Use this event to cleanup.
#        @return: Nothing
#        """
#        print "OnClose"
#
#    def OnKeydown(self, vkey, shift):
#        """
#        User pressed a key
#        @param vkey: Virtual key code
#        @param shift: Shift flag
#        @return: Boolean. True if you handled the event
#        """
#        print "OnKeydown, vk=%d shift=%d" % (vkey, shift)
#        return False
#
#    def OnPopup(self):
#        """
#        Context menu popup is about to be shown. Create items dynamically if you wish
#        @return: Boolean. True if you handled the event
#        """
#        print "OnPopup"
#
#    def OnHint(self, lineno):
#        """
#        Hint requested for the given line number.
#        @param lineno: The line number (zero based)
#        @return:
#            - tuple(number of important lines, hint string)
#            - None: if no hint available
#        """
#        return (1, "OnHint, line=%d" % lineno)
#
#    def OnPopupMenu(self, menu_id):
#        """
#        A context (or popup) menu item was executed.
#        @param menu_id: ID previously registered with add_popup_menu()
#        @return: Boolean
#        """
#        print "OnPopupMenu, menu_id=" % menu_id
#        return True
#</pydoc>
#</pycode(py_kernwin_custview)>


def plgform_new(*args):
  """
  plgform_new() -> PyObject *
  """
  return _ida_kernwin.plgform_new(*args)

def plgform_show(*args):
  """
  plgform_show(py_link, py_obj, caption, options=WOPN_TAB|WOPN_MENU|WOPN_RESTORE) -> bool
  """
  return _ida_kernwin.plgform_show(*args)

def plgform_close(*args):
  """
  plgform_close(py_link, options)
  """
  return _ida_kernwin.plgform_close(*args)
#<pycode(py_kernwin_plgform)>
import sys
class PluginForm(object):
    """
    PluginForm class.

    This form can be used to host additional controls. Please check the PyQt example.
    """

    WOPN_MDI      = 0x01
    """
    start by default as MDI (obsolete)
    """
    WOPN_TAB      = 0x02
    """
    attached by default to a tab
    """
    WOPN_RESTORE  = 0x04
    """
    restore state from desktop config
    """
    WOPN_ONTOP    = 0x08
    """
    form should be "ontop
    """
    WOPN_MENU     = 0x10
    """
    form must be listed in the windows menu (automatically set for all plugins)
    """
    WOPN_CENTERED = 0x20
    """
    form will be centered on the screen
    """
    WOPN_PERSIST  = 0x40
    """
    form will persist until explicitly closed with Close()
    """


    def __init__(self):
        """
        """
        self.__clink__ = _ida_kernwin.plgform_new()



    def Show(self, caption, options = 0):
        """
        Creates the form if not was not created or brings to front if it was already created

        @param caption: The form caption
        @param options: One of PluginForm.WOPN_ constants
        """
        options |= PluginForm.WOPN_TAB|PluginForm.WOPN_MENU|PluginForm.WOPN_RESTORE
        return _ida_kernwin.plgform_show(self.__clink__, self, caption, options)


    @staticmethod
    def FormToPyQtWidget(form, ctx = sys.modules['__main__']):
        """
        Use this method to convert a TWidget* to a QWidget to be used by PyQt

        @param ctx: Context. Reference to a module that already imported SIP and QtGui modules
        """
        if type(form).__name__ == "SwigPyObject":
            ptr_l = long(form)
        else:
            ptr_l = form
        for key, modname in [("sip", "sip"), ("QtWidgets", "PyQt5.QtWidgets")]:
            if not hasattr(ctx, key):
                print "Note: FormToPyQtWidget: importing '%s' module into %s" % (key, ctx)
                import importlib
                setattr(ctx, key, importlib.import_module(modname))
        vptr = ctx.sip.voidptr(ptr_l)
        return ctx.sip.wrapinstance(vptr.__int__(), ctx.QtWidgets.QWidget)


    @staticmethod
    def FormToPySideWidget(form, ctx = sys.modules['__main__']):
        """
        Use this method to convert a TWidget* to a QWidget to be used by PySide

        @param ctx: Context. Reference to a module that already imported QtGui module
        """
        if form is None:
            return None
        if type(form).__name__ == "SwigPyObject":
            # Since 'form' is a SwigPyObject, we first need to convert it to a PyCObject.
            # However, there's no easy way of doing it, so we'll use a rather brutal approach:
            # converting the SwigPyObject to a 'long' (will go through 'SwigPyObject_long',
            # that will return the pointer's value as a long), and then convert that value
            # back to a pointer into a PyCObject.
            ptr_l = long(form)
            from ctypes import pythonapi, c_void_p, py_object
            pythonapi.PyCObject_FromVoidPtr.restype  = py_object
            pythonapi.PyCObject_AsVoidPtr.argtypes = [c_void_p, c_void_p]
            form = pythonapi.PyCObject_FromVoidPtr(ptr_l, 0)
        return ctx.QtGui.QWidget.FromCObject(form)


    def OnCreate(self, form):
        """
        This event is called when the plugin form is created.
        The programmer should populate the form when this event is triggered.

        @return: None
        """
        pass


    def OnClose(self, form):
        """
        Called when the plugin form is closed

        @return: None
        """
        pass


    def Close(self, options):
        """
        Closes the form.

        @param options: Close options (WCLS_SAVE, WCLS_NO_CONTEXT, ...)

        @return: None
        """
        return _ida_kernwin.plgform_close(self.__clink__, options)

    WCLS_SAVE           = 0x1
    """
    Save state in desktop config
    """

    WCLS_NO_CONTEXT     = 0x2
    """
    Don't change the current context (useful for toolbars)
    """

    WCLS_DONT_SAVE_SIZE = 0x4
    """
    Don't save size of the window
    """

    WCLS_CLOSE_LATER    = 0x8
    """
    This flag should be used when Close() is called from an event handler
    """
#</pycode(py_kernwin_plgform)>

if _BC695:
    AST_DISABLE_FOR_FORM=AST_DISABLE_FOR_WIDGET
    AST_ENABLE_FOR_FORM=AST_ENABLE_FOR_WIDGET
    CB_CLOSE_IDB=CB_INVISIBLE
    chtype_generic2=chtype_generic
    chtype_segreg=chtype_srcp
    close_tform=close_widget
    find_tform=find_widget
    get_current_tform=get_current_widget
    get_highlighted_identifier=get_highlight
    get_tform_title=get_widget_title
    get_tform_type=get_widget_type
    is_chooser_tform=is_chooser_widget
    open_tform=display_widget
    pyscv_get_tcustom_control=pyscv_get_widget
    pyscv_get_tform=pyscv_get_widget
    __read_selection70 = read_selection
    def read_selection(*args):
        if len(args) == 0:
            # bw-compat
            t0, t1, view = twinpos_t(), twinpos_t(), get_current_viewer()
            sel = __read_selection70(view, t0, t1)
            import ida_idaapi
            a0, a1 = ida_idaapi.BADADDR, ida_idaapi.BADADDR
            if sel:
                a0, a1 = t0.place(view).toea(), t1.place(view).toea()
            return sel, a0, a1
        else:
            return __read_selection70(*args)
    readsel2=read_selection
    switchto_tform=activate_widget
    umsg=msg
    def __wrap_hooks_callback(klass, new_name, old_name, do_call):
        bkp_name = "__real_%s" % new_name
        def __wrapper(self, *args):
            rc = getattr(self, bkp_name)(*args)
            cb = getattr(self, old_name, None)
            if cb:
                rc = do_call(cb, *args)
            return rc
        setattr(klass, bkp_name, getattr(klass, new_name))
        setattr(klass, new_name, __wrapper)
    def __wrap_uihooks_callback(name, do_call):
        return __wrap_hooks_callback(UI_Hooks, name, name.replace("widget", "tform"), do_call)
    __wrap_uihooks_callback("widget_visible", lambda cb, *args: cb(args[0], args[0]))
    __wrap_uihooks_callback("widget_invisible", lambda cb, *args: cb(args[0], args[0]))
    __wrap_uihooks_callback("populating_widget_popup", lambda cb, *args: cb(*args))
    __wrap_uihooks_callback("finish_populating_widget_popup", lambda cb, *args: cb(*args))
    __wrap_uihooks_callback("current_widget_changed", lambda cb, *args: cb(*args))
    AskUsingForm=ask_form
    HIST_ADDR=0
    HIST_NUM=0
    KERNEL_VERSION_MAGIC1=0
    KERNEL_VERSION_MAGIC2=0
    OpenForm=open_form
    _askaddr=_ida_kernwin._ask_addr
    _asklong=_ida_kernwin._ask_long
    _askseg=_ida_kernwin._ask_seg
    askaddr=ask_addr
    askbuttons_c=ask_buttons
    askfile_c=ask_file
    @bc695redef
    def askfile2_c(forsave, defdir, filters, fmt):
        if filters:
            fmt = "FILTER %s\n%s" % (filters, fmt)
        return ask_file(forsave, defdir, fmt)
    askident=ask_ident
    asklong=ask_long
    @bc695redef
    def askqstr(defval, fmt):
        return ask_str(defval, 0, fmt)
    askseg=ask_seg
    @bc695redef
    def askstr(hist, defval, fmt):
        return ask_str(defval, hist, fmt)
    asktext=ask_text
    askyn_c=ask_yn
    choose2_activate=choose_activate
    choose2_close=choose_close
    choose2_create=choose_create
    choose2_find=choose_find
    choose2_get_embedded=choose_get_embedded
    choose2_get_embedded_selection=choose_get_embedded_selection
    choose2_refresh=choose_refresh
    clearBreak=clr_cancelled
    py_get_AskUsingForm=py_get_ask_form
    py_get_OpenForm=py_get_open_form
    setBreak=set_cancelled
    wasBreak=user_cancelled
    refresh_lists=refresh_choosers
    #--------------------------------------------------------------------------
    class BC695_control_cmd:
        def __init__(self, cmd_id, caption, flags, menu_index, icon, emb, shortcut, is_chooser):
            self.cmd_id = cmd_id
            self.caption = caption
            self.flags = flags
            self.menu_index = menu_index
            self.icon = icon
            self.emb = emb
            self.shortcut = shortcut
            self.is_chooser = is_chooser
        @staticmethod
        def add_to_control(control, caption, flags, menu_index, icon, emb, shortcut, is_chooser):
            if getattr(control, "commands", None) is None:
                setattr(control, "commands", [])
            found = filter(lambda x: x.caption == caption, control.commands)
            if len(found) == 1:
                cmd_id = found[0].cmd_id
            else:
                cmd_id = len(control.commands)
                cmd = BC695_control_cmd(cmd_id, caption, flags, menu_index, icon, emb, shortcut, is_chooser)
                control.commands.append(cmd)
            return cmd_id
        @staticmethod
        def populate_popup(control, widget, popup):
            cmds = getattr(control, "commands", [])
            for cmd in cmds:
                if (cmd.flags & CHOOSER_POPUP_MENU) != 0:
                    desc = action_desc_t(None, cmd.caption, BC695_control_cmd_ah_t(control, cmd), cmd.shortcut, None, cmd.icon)
                    attach_dynamic_action_to_popup(widget, popup, desc)
    class BC695_control_cmd_ah_t(action_handler_t):
        def __init__(self, control, cmd):
            action_handler_t.__init__(self)
            self.control = control
            self.cmd = cmd
        def activate(self, ctx):
            if self.cmd.is_chooser:
                idx = ctx.chooser_selection[0]
                self.control.OnCommand(idx, self.cmd.cmd_id)
            else:
                self.control.OnCommand(self.cmd.cmd_id)
        def update(self, ctx):
            return AST_ENABLE_ALWAYS
    class Choose2(object):
        """
        v.6.95 compatible chooser wrapper class.
        """
        CH_MODAL        = 0x01
        CH_MULTI        = 0x04
        CH_MULTI_EDIT   = 0x08
        """
        The OnEditLine() callback will be called for all
        selected items using the START_SEL/END_SEL
        protocol.
        This bit implies #CH_MULTI.
        """
        CH_NOBTNS       = 0x10
        CH_ATTRS        = 0x20
        CH_NOIDB        = 0x40
        CH_BUILTIN_SHIFT = 19
        CH_BUILTIN_MASK = 0x1F << CH_BUILTIN_SHIFT
        # column flags (are specified in the widths array)
        CHCOL_PLAIN  =  0x00000000
        CHCOL_PATH   =  0x00010000
        CHCOL_HEX    =  0x00020000
        CHCOL_DEC    =  0x00030000
        CHCOL_FORMAT =  0x00070000
        # special values of the chooser index
        NO_SELECTION   = -1
        """
        there is no selected item
        """
        START_SEL      = -2
        """
        before calling the first selected item
        """
        END_SEL        = -3
        """
        after calling the last selected item
        """
        # the v.7.0 chooser object implementing the v.6.95 chooser
        class ChooseWrapper(Choose):
            def __init__(self, v695_chooser):
                self.link = v695_chooser
                # check what non-base callbacks we have
                forbidden_cb = 0
                for cb in [("OnInsertLine", Choose.CHOOSE_HAVE_INS    ),
                           ("OnDeleteLine", Choose.CHOOSE_HAVE_DEL    ),
                           ("OnEditLine",   Choose.CHOOSE_HAVE_EDIT   ),
                           ("OnSelectLine", Choose.CHOOSE_HAVE_ENTER  ),
                           ("OnRefresh",    Choose.CHOOSE_HAVE_REFRESH),
                           ("OnSelectionChange", Choose.CHOOSE_HAVE_SELECT)]:
                    if not hasattr(self.link, cb[0]) or \
                       not callable(getattr(self.link, cb[0])):
                        forbidden_cb |= cb[1]
                Choose.__init__(
                        self, self.link.title, self.link.cols,
                        forbidden_cb = forbidden_cb)
            # redirect base callbacks to the v.6.95 chooser
            def __getattr__(self, attr):
                if attr in ["OnGetSize",
                            "OnGetLine",
                            "OnGetIcon",
                            "OnGetLineAttr",
                            "OnClose"]:
                    return getattr(self.link, attr)
                return getattr(self.link, attr)
            def Show(self, modal = False):
                # set `flags` and `deflt`
                self.flags = self.link.flags
                if self.link.deflt == -1:
                    self.deflt = 0
                else:
                    self.deflt = self.link.deflt - 1
                    self.flags |= Choose.CH_FORCE_DEFAULT
                if (self.flags & Choose.CH_MULTI) != 0:
                    self.deflt = [self.deflt]
                # copy simple attributes from v.6.95
                for attr in ["title", "cols", "popup_names", "icon",
                             "x1", "y1", "x2", "y2",
                             "embedded", "width", "height"]:
                    if hasattr(self.link, attr):
                        setattr(self, attr, getattr(self.link, attr))
                    else:
                        delattr(self, attr)
                return Choose.Show(self, modal)
            def OnInsertLine(self, n):
                # assert: hasattr(self.link, "OnInsertLine")
                self.link.OnInsertLine()
                # we preserve the selection
                return (Choose.ALL_CHANGED, n)
                if (self.link.flags & Choose2.CH_MULTI) == 0:
                    return (Choose.ALL_CHANGED, n)
                else:
                    return [Choose.ALL_CHANGED] + n
            def OnDeleteLine(self, n):
                # assert: hasattr(self.link, "OnDeleteLine")
                res = None
                if (self.link.flags & Choose2.CH_MULTI) == 0:
                    res = self.link.OnDeleteLine(n)
                else:
                  # assert: n is iterable and n
                  # call the callback multiple times
                  self.link.OnDeleteLine(Choose2.START_SEL)
                  res = None
                  for idx in n:
                      new_idx = self.link.OnDeleteLine(idx)
                      if res == None:
                          res = new_idx
                  self.link.OnDeleteLine(Choose2.END_SEL)
                return [Choose.ALL_CHANGED] + self.adjust_last_item(res)
            def OnEditLine(self, n):
                # assert: hasattr(self.link, "OnEditLine")
                if (self.link.flags & Choose2.CH_MULTI) == 0:
                    self.link.OnEditLine(n)
                    return (Choose.ALL_CHANGED, n) # preserve the selection
                # assert: n is iterable and n
                if (self.link.flags & Choose2.CH_MULTI_EDIT) == 0:
                    self.link.OnEditLine(n[0])
                    return [Choose.ALL_CHANGED] + n # preserve the selection
                # call the callback multiple times
                self.link.OnEditLine(Choose2.START_SEL)
                for idx in n:
                    self.link.OnEditLine(idx)
                self.link.OnEditLine(Choose2.END_SEL)
                return [Choose.ALL_CHANGED] + n # preserve the selection
            def OnSelectLine(self, n):
                # assert: hasattr(self.link, "OnSelectLine")
                if (self.link.flags & Choose2.CH_MULTI) == 0:
                    self.link.OnSelectLine(n)
                    return (Choose.ALL_CHANGED, n)
                # assert: n is iterable and n
                idx = n.pop(0)
                self.link.OnSelectLine(idx)
                # preserve all but the first item
                return [Choose.ALL_CHANGED] + n
            def OnRefresh(self, n):
                # assert: hasattr(self.link, "OnRefresh")
                if (self.link.flags & Choose2.CH_MULTI) != 0:
                  # ignore all but the first item
                  n = n[0] if n else Choose.NO_SELECTION
                res = self.link.OnRefresh(n)
                return (Choose.ALL_CHANGED, res)
            def OnSelectionChange(self, n):
                # assert: hasattr(self.link, "OnSelectionChange")
                if (self.link.flags & Choose2.CH_MULTI) == 0:
                  n = [n] if n != Choose.NO_SELECTION else []
                self.link.OnSelectionChange(n)
            def OnPopup(self, widget, popup_handle):
                BC695_control_cmd.populate_popup(
                    self.link,
                    widget,
                    popup_handle)
        def __init__(self, title, cols, flags=0, popup_names=None,
                     icon=-1, x1=-1, y1=-1, x2=-1, y2=-1, deflt=-1,
                     embedded=False, width=None, height=None):
            """
            Constructs a chooser window.
            @param title: The chooser title
            @param cols: a list of colums; each list item is a list of two items
                example: [ ["Address", 10 | Choose2.CHCOL_HEX],
                           ["Name", 30 | Choose2.CHCOL_PLAIN] ]
            @param flags: One of CH_XXXX constants
            @param deflt: Default starting item (1-based).
                0 means that no item is selected,
                -1 means that the first item selected for a new window and
                that the selection is not updated for an existing window
            @param popup_names: list of new captions to replace this list
                ["Insert", "Delete", "Edit", "Refresh"]
            @param icon: Icon index (the icon should exist in ida resources or
                an index to a custom loaded icon)
            @param x1, y1, x2, y2: The default location (for txt-version)
            @param embedded: Create as embedded chooser
            @param width: Embedded chooser width
            @param height: Embedded chooser height
            """
            # remember attributes
            self.title = title
            self.flags = flags
            self.cols = cols
            self.deflt = deflt
            self.popup_names = popup_names
            self.icon = icon
            self.x1 = x1
            self.y1 = y1
            self.x2 = x2
            self.y2 = y2
            self.embedded = embedded
            self.width = width
            self.height = height
            # construct the v.7.0 chooser object
            self.chobj = Choose2.ChooseWrapper(self)
        # redirect methods to the v.7.0 chooser
        def __getattr__(self, attr):
            if attr not in ["GetEmbSelection",
                            "Activate",
                            "Refresh",
                            "Close",
                            "GetWidget"]:
                raise AttributeError(attr)
            return getattr(self.chobj, attr)
        def Embedded(self):
            """
            Creates an embedded chooser (as opposed to Show())
            @return: Returns 1 on success
            """
            return 1 if self.chobj.Embedded() == 0 else 0
        def Show(self, modal=False):
            """
            Activates or creates a chooser window
            @param modal: Display as modal dialog
            @return: For modal choosers it will return the selected item index (0-based)
                     or -1 in the case of error,
                     For non-modal choosers it will return 0
                     or -1 if the chooser was already open and is active now
            """
            ret = self.chobj.Show(modal)
            return -1 if ret < 0 else ret
        def AddCommand(self,
                       caption,
                       flags = _ida_kernwin.CHOOSER_POPUP_MENU,
                       menu_index = -1,
                       icon = -1,
                       emb=None,
                       shortcut=None):
            # Use the 'emb' as a sentinel. It will be passed the correct value
            # from the EmbeddedChooserControl
            if self.embedded and ((emb is None) or (emb != 2002)):
                raise RuntimeError("Please add a command through "
                                   "EmbeddedChooserControl.AddCommand()")
            return BC695_control_cmd.add_to_control(
                       self, caption, flags, menu_index, icon, emb, None,
                       is_chooser=True)
        # callbacks
        # def OnGetSize(self):
        # def OnGetLine(self, n):
        # def OnGetIcon(self, n):
        # def OnGetLineAttr(self, n):
        # def OnInsertLine(self):
        # def OnDeleteLine(self, n):
        # def OnEditLine(self, n):
        # def OnSelectLine(self, n):
        # def OnRefresh(self, n):
        # def OnSelectionChange(self, sel_list):
        # def OnClose(self):
        # def OnCommand(self, n, cmd_id):


if _BC695:
    PluginForm.FORM_MDI = PluginForm.WOPN_MDI
    PluginForm.FORM_TAB = PluginForm.WOPN_TAB
    PluginForm.FORM_RESTORE = PluginForm.WOPN_RESTORE
    PluginForm.FORM_ONTOP = PluginForm.WOPN_ONTOP
    PluginForm.FORM_MENU = PluginForm.WOPN_MENU
    PluginForm.FORM_CENTERED = PluginForm.WOPN_CENTERED
    PluginForm.FORM_PERSIST = PluginForm.WOPN_PERSIST
    PluginForm.FORM_SAVE = PluginForm.WCLS_SAVE
    PluginForm.FORM_NO_CONTEXT = PluginForm.WCLS_NO_CONTEXT
    PluginForm.FORM_DONT_SAVE_SIZE = PluginForm.WCLS_DONT_SAVE_SIZE
    PluginForm.FORM_CLOSE_LATER = PluginForm.WCLS_CLOSE_LATER




